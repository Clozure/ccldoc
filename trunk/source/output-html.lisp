(in-package :ccldoc)

(defun output-html (doc filename &key external-format (if-exists :supersede))
  (with-open-file (s filename :direction :output :if-exists if-exists
		     :external-format external-format)
    (format s "<!DOCTYPE html>~%")
    (format s "<html>~%")
    (write-html doc s)
    (format s "</html>~%")
    (truename s)))

(defmethod write-html ((clause document) stream)
  (write-string "<title>" stream)
  (write-html (clause-title clause) stream)
  (format stream "</title>~%")
  (fresh-line stream)
  (format stream "<body>~%")
  (write-html (clause-body clause) stream)
  (format stream "</body>~%"))

(defmethod write-html ((clause index-section) stream)
  (declare (ignore stream))
  (warn "ignoring index-section"))

(defmethod write-html ((clause glossary-section) stream)
  (declare (ignore stream))
  (warn "ignoring glossary-section"))

(defmethod write-html ((clause section) stream)
  (let ((tag (case (section-level clause)
	       (0 :h1)
	       (1 :h2)
	       (2 :h3)
	       (3 :h4)
	       (4 :h5)
	       (otherwise :h6))))
    (format stream "<~a>" tag)
    (write-html (clause-title clause) stream)
    (format stream "</~a>~%" tag)
    (write-html (clause-body clause) stream)))

(defmethod write-html ((clause glossentry) stream)
  (declare (ignore stream))
  (warn "ignoring glossentry"))

(defmethod write-html ((clause code-block) stream)
  (write-string "<pre>" stream)
  (write-html (clause-body clause) stream)
  (format stream "~&</pre>~%"))

(defmethod write-html ((clause block) stream)
  (format stream "<blockquote>~%")
  (write-html (clause-body clause) stream)
  (format stream "~&</blockquote>~%"))

(defmethod write-html ((clause para) stream)
  (write-string "<p>" stream)
  (let ((body (clause-body clause)))
    (when body
      (write-html (clause-body clause) stream)))
  (write-string "</p>" stream)
  (fresh-line stream))

(defmethod write-html ((clause docerror) stream)
  (write-string "<span color=#f00>" stream)
  (write-string (clause-text clause) stream)
  (write-string "</span>")
  (fresh-line stream))

(defmethod write-html ((clause link) stream)
  (format stream "<a href=\"~a\">" (link-url clause))
  (write-html (clause-body clause) stream)
  (format stream "</a>~%"))

(defmethod write-html ((clause table) stream)
  (write-string "<table>" stream)
  (loop for row across (clause-items clause)
	do (write-html row stream))
  (write-string "</table>" stream)
  (fresh-line stream))

(defmethod write-html ((clause row) stream)
  (write-string "<tr>" stream)
  (loop for item across (clause-items clause)
	do (progn (write-string "<td>" stream)
		  (write-html item stream)
		  (fresh-line stream)))
  (write-string "</tr>" stream)
  (fresh-line stream))

(defmethod write-html ((clause listing) stream)
  (multiple-value-bind (start-tag end-tag)
      (case (listing-type clause)
	(:bullet (values "<ul>" "</ul>"))
	(:number (values "<ol>" "</ol>"))
	(:definition (values "<dl>" "</dl>"))
	(otherwise (values "" "")))
    (write-string start-tag stream)
    (loop for item across (clause-items clause)
	  do (write-html item stream))
    (write-string end-tag stream)
    (fresh-line stream)))

(defmethod write-html ((clause indexed-clause) stream)
  (write-html (clause-body clause) stream))

(defmethod write-html ((clause markup) stream)
  (let ((tag (ecase (markup-type clause)
	       (:emphasis :emph)
	       (:code :code)
	       (:param :it)
	       (:sample :it)
	       (:system :code))))
    (format stream "<~a>" tag)
    (write-html (clause-body clause) stream)
    (format stream "</~a>" tag)))

(defmethod write-html ((clause item) stream)
  (let ((body (clause-body clause)))
    (when body
      (write-string "<li>" stream)
      (write-html (clause-body clause) stream)
      (fresh-line stream))))

(defmethod write-html ((clause term-item) stream)
  (write-string "<dt>" stream)
  (write-html (clause-term clause) stream)
  (write-string "</dt>" stream)
  (fresh-line stream)
  (write-string "<dd>" stream)
  (write-html (clause-body clause) stream)
  (write-string "</dd>" stream)
  (fresh-line stream))

(defmethod write-html ((clause xref) stream)
  (format stream "<a href=\"#~a\">" (clause-external-id (xref-target clause)))
  (write-html (or (clause-body clause)
		  (xref-default-body clause))
	      stream)
  (write-string "</a>" stream))

(defun html-formatted-signature (signature)
  (let ((words (split-sequence #\space
			       (cl-who:escape-string (string-downcase
						      signature)))))
    (with-output-to-string (s)
      (format s "<code>~a</code> " (pop words))
      (dolist (w words)
	(cond ((member w (list "&amp;key" "&amp;optional" "&amp;rest"
			       "&amp;allow-other-keys")
		       :test 'equalp)
	       (format s "<code>~a</code> " w))
	      ((char= (char w 0) #\()
	       (write-string "(" s)
	       (format s "<i>~a</i>" (string-trim "()" w))
	       (write-string ") " s))
	      (t
	       (format s "<i>~a</i> " w)))))))

(defmethod write-html ((clause definition) stream)
  (write-string "<div class=definition>" stream)
  (fresh-line stream)
  (write-string "[" stream)
  (write-html (dspec-type-name (clause-name clause)) stream)
  (write-string "]<br>" stream)
  (write-string (html-formatted-signature (clause-text (definition-signature
							   clause)))
		stream)
  (when (definition-summary clause)
    (write-html (definition-summary clause) stream)
    (fresh-line stream))
  (write-html (clause-body clause) stream)
  (write-string "</div>" stream)
  (fresh-line stream))

(defmethod write-html ((clause cons) stream)
  (dolist (c clause)
    (write-html c stream)))

(defmethod write-html ((clause string) stream)
  (write-string (cl-who:escape-string-minimal clause) stream))
