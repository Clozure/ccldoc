<?xml version="1.0" encoding="utf-8"?>
                    <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
                    
                    
<book lang="en">
  <bookinfo>
    <title>Clozure CL Documentation</title>
  </bookinfo>
  <chapter id="about-clozure-cl">
    <title>About Clozure CL</title>
    <section id="introduction-to-clozure-cl">
      <title>Introduction to Clozure CL</title>
      <para>Clozure CL is a fast, mature, open source Common Lisp
      implementation that runs on Linux, Mac OS X, FreeBSD, and Windows.
      Clozure CL was forked from Macintosh Common Lisp (MCL) in 1998
      and the development has been entirely separate since.</para>
      <para>      When it was forked from MCL in 1998, the new Lisp was named
      OpenMCL. Subsequently, Clozure renamed its Lisp to Clozure CL, partly
      because its ancestor MCL has been released as open
      source. Clozure thought it might be confusing for users if there
      were two independent open-source projects with such similar
      names. The new name also reflects Clozure CL's current status as the
      flagship product of Clozure Associates.</para>
      <para>      Furthermore, the new name refers to Clozure CL's ancestry: in its
      early years, MCL was known as Coral Common Lisp, or &quot;CCL&quot;. For
      years the package that contains most of Clozure CL's
      implementation-specific symbols has been named &quot;CCL&quot;, an acronym
      that once stood for the name of the Lisp product. It seems
      fitting that &quot;CCL&quot; once again stands for the name of the
      product.</para>
      <para>      Some commands and source files may still refer to &quot;OpenMCL&quot;
      instead of Clozure CL.</para>
      <para>      Clozure CL compiles to native code and supports multithreading
      using native OS threads. It includes a foreign-function interface,
      and supports both Lisp code that calls external code, and external
      code that calls Lisp code. Clozure CL can create standalone executables
      on all supported platforms.</para>
      <para>      On Mac OS X, Clozure CL supports building GUI applications that
      use OS X's native Cocoa frameworks, and the OS X distributions
      include an IDE written with Cocoa, and distributed with complete
      sources.</para>
      <para>      On all supported platforms, Clozure CL can run as a command-line
      process, or as an inferior Emacs process using either SLIME or
      ILISP.</para>
      <para>Features of Clozure CL include</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>Very fast compilation speed.</para></listitem>
          <listitem><para>A fast, precise, compacting, generational
      garbage collector written in hand-optimized C. The sizes of the
      generations are fully configurable. Typically, a generation can
      be collected in a millisecond on modern
      systems.</para></listitem>
          <listitem><para>Fast execution speed, competitive with other
      Common Lisp implementations on most
      benchmarks.</para></listitem>
          <listitem><para>Robust and stable. Customers report that their
      CPU-intensive, multi-threaded applications run for extended
      periods on Clozure CL without difficulty.</para></listitem>
          <listitem><para>Full native OS threads on all platforms. Threads
      are automatically distributed across multiple cores. The API
      includes support for shared memory, locking, and blocking for OS
      operations such as I/O.</para></listitem>
          <listitem><para>Full Unicode support.</para></listitem>
          <listitem><para>Full SLIME integration.</para></listitem>
          <listitem><para>An IDE on Mac OS X, fully integrated with
      the Macintosh window system and User Interface
      standards.</para></listitem>
          <listitem><para>Excellent debugging facilities. The names of all
      local variables are available in a backtrace.</para></listitem>
          <listitem><para>A complete, mature foreign function interface,
      including a powerful bridge to Objective-C and Cocoa on Mac OS
      X.</para></listitem>
          <listitem><para>Many extensions including: files mapped to
      Common Lisp vectors for fast file I/O; thread-local hash tables
      and streams to eliminate locking overhead; cons hashing support;
      and much more</para></listitem>
          <listitem><para>Very efficient use of memory</para></listitem>
        </itemizedlist>
      </blockquote>
      <para>Although it's an open-source project, available free of
      charge under a liberal license, Clozure CL is also a fully-supported
      product of Clozure Associates. Clozure continues to extend,
      improve, and develop Clozure CL in response to customer and user
      needs, and offers full support and development services for
      Clozure CL.</para>
    </section>
  </chapter>
  <chapter id="obtaining-installing-and-running-clozure-cl">
    <title>Obtaining, Installing, and Running Clozure CL</title>
    <section id="releases-and-system-requirements">
      <title>Releases and System Requirements</title>
      <para>As of this writing, Clozure CL 1.7 is the latest release; it was
    made in August 2011.  For up-to-date information about releases,
    please see <ulink url="http://ccl.clozure.com/">http://ccl.clozure.com/</ulink>.</para>
      <para>Clozure CL 1.7 runs on the following platforms:</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>Linux (x86, x86-64, ppc32, ppc64, armv7)</para></listitem>
          <listitem><para>Mac OS X 10.5 and later (x86, x86-64)</para></listitem>
          <listitem><para>FreeBSD 6.x and later (x86, x86-64)</para></listitem>
          <listitem><para>Solaris (x86, x86-64)</para></listitem>
          <listitem><para>Microsoft Windows XP and later (x86, x86-64)</para></listitem>
        </itemizedlist>
      </blockquote>
      <section id="32--vs-64-bit-versions">
        <title>32- vs 64-bit versions</title>
        <para>Naturally, 64-bit versions of Clozure CL require 64-bit processors, 
      for example, a G5 or Core 2.  Some early Intel-based Macintoshes
      used processors that don't support
      64-bit operation, so the 64-bit Clozure CL will not run on them, although
      the 32-bit Clozure CL will.
      </para>
      </section>
      <section id="32-bit-x86-versions-require-sse2">
        <title>32-bit x86 versions require SSE2</title>
        <para>The 32-bit x86 versions of Clozure CL depend on the presence of the SSE2 instructions.
      Most x86 processors manufactured and sold in the last several years support SSE2 (all Apple Intel-based Macs do, for instance),
      but there are some exceptions.
      The <ulink url="http://en.wikipedia.org/wiki/SSE2">Wikipedia article on SSE2</ulink> lists processor models that support SSE2
      (and also mentions some of the more notable exceptions).
      </para>
      </section>
      <section id="linuxppc">
        <title>LinuxPPC</title>
        <para>Clozure CL requires version 2.2.13 (or later) of the Linux
      kernel and version 2.1.3 (or later) of the GNU C library (glibc)
      at a bare minimum.</para>
      </section>
      <section id="linux-x86">
        <title>Linux x86</title>
        <para>
	Because of the nature of Linux distributions, it's difficult
	to give precise version number requirements.  In general, a
	&quot;fairly modern&quot; (no more than 2 or three years old) kernel and
	C library are more likely to work well than older
	versions.</para>
      </section>
      <section id="linux-arm-v7">
        <title>Linux ARM v7</title>
        <para>The Linux ARM port is relatively new and is still a work-in-progress.
      Clozure CL
needs some features (such as hardware floating-point, locking and
memory-serialization primitives) that are only found in chips
that implement architecture version 7 (ARMv7); technically, it needs
the ARMv7 &quot;application profile&quot;, which is sometimes called ARMv7a.</para>
        <para>In practice, <emphasis>most</emphasis> ARM consumer devices released in the last few
years implement ARMv7, but there are exceptions, and it is 
not practical to enumerate all of the ARM devices that CCL should
run on.</para>
        <para>In addition to hardware issues, Clozure CL expects Linux to run in little-endian
mode and expects software to follow &quot;soft float&quot; calling conventions.
The latter has to do with how C functions accept floating-point arguments
and return floating-point values.
</para>
      </section>
      <section id="freebsd-x86">
        <title>FreeBSD x86</title>
        <para>Clozure CL should run on
    FreeBSD 6.x and 7.x.
    FreeBSD 7 users will need to install the &quot;compat6x&quot; package in order to use
    the distributed Clozure CL kernel, which is built on a FreeBSD 6.x system.</para>
      </section>
      <section id="mac-os-x-x86">
        <title>Mac OS X x86</title>
        <para> Clozure CL 1.7 runs on Mac OS X (x86) versions 10.5 and later, including 10.7 (Lion),</para>
        <para> Clozure CL 1.6 runs on Mac OS X PPC as well as x86 processors.</para>
      </section>
      <section id="microsoft-windows">
        <title>Microsoft Windows</title>
        <para>
      For Clozure CL versions prior to 1.7, the 32-bit executable does not run under 64-bit Windows.
    </para>
      </section>
    </section>
    <section id="obtaining-clozure-cl">
      <title>Obtaining Clozure CL</title>
      <para>There are three ways to obtain Clozure CL.  For Mac OS X,
    there are disk images that can be used to install Clozure CL in
    the usual Macintosh way. For other OSes, Subversion is the best
    way to obtain Clozure CL.  Mac OS X users can also use Subversion
    if they prefer. Tarballs are available for those who prefer them,
    but if you have Subversion installed, it is simpler and more
    flexible to use Subversion than tarballs.</para>
      <para> There are three popular ways to use Clozure CL: as a
      stand-alone double-clickable application (Mac OS X only), as a
      command-line application, or with Emacs and SLIME.</para>
      <para>The following sections describe these options.</para>
      <section id="the-mac-way">
        <title>The Mac Way</title>
        <para>If you are using Mac OS X then you can install and use
         Clozure CL in the usual Macintosh way.  Download and mount a
         disk image, then drag the ccl folder to the Applications folder
	 or wherever you wish.
         After that you can double-click the Clozure CL application found
	 inside the ccl directory.  The disk images for version 1.7 are available at
         <ulink url="ftp://clozure.com/pub/release/1.7/">ftp://clozure.com/pub/release/1.7/</ulink></para>
        <para>        So that Clozure CL can locate its source code, and for other
        reasons explained in
        <xref linkend="predefined-logical-hosts"/>, you keep the
        Clozure CL application
        in the <literal>ccl</literal> directory.  If you use a shell,
        you can set the value of the
        <code>CCL_DEFAULT_DIRECTORY</code> environment variable
        to explicitly indicate the location of
        the <literal>ccl</literal> directory. If you choose to do
        that, then the <literal>ccl</literal> directory and the Clozure CL
        application can each be in any location you find
        convenient.</para>
      </section>
      <section id="tarballs">
        <title>Tarballs</title>
        <para>Tarball distributions of Clozure CL release version 1.7 are available at
      <ulink url="ftp://clozure.com/pub/release/1.7/">ftp://clozure.com/pub/release/1.7/</ulink>.
      Download and extract
      one on your local disk.  Then edit the Clozure CL shell script to set
      the value of <code>CCL_DEFAULT_DIRECTORY</code> and start
      up the appropriate Clozure CL kernel. See <xref linkend="the-ccl-shell-script"/> for more information about the
      Clozure CL shell scripts.</para>
      </section>
      <section id="getting-clozure-cl-with-subversion">
        <title>Getting Clozure CL with Subversion</title>
        <para>It is very easy to download and configure Clozure CL to obtain sources from the Subversion repository.
      This is the preferred way to get either the
      latest, or a specific version of Clozure CL, unless you prefer
      the Mac Way.  Subversion is a source code control system that is
      in wide use.  Many OSes come with Subversion
      pre-installed. A complete, buildable and runnable set of Clozure CL
      sources and binaries can be retrieved with a single Subversion command.
      </para>
        <blockquote>
          <title>Note</title>
          <para>Unless stated otherwise, examples in this chapter are given for Mac OS X in particular
        or Unix-based host environments in general.</para>
          <para>        For Windows, special care must be taken to install a working development environment.
        For more information see the Clozure CL Wiki at URL: <ulink url="http://trac.clozure.com/ccl/wiki/WindowsNotes">http://trac.clozure.com/ccl/wiki/WindowsNotes</ulink></para>
        </blockquote>
        <section id="checking-subversion-installation">
          <title>Checking Subversion Installation</title>
          <para>Make sure that Subversion is installed on your system.  Bring up a command
      line shell and type:
        <programlisting>
shell&gt; svn</programlisting> 
        If Subversion is installed, you will see something like:
        <programlisting>
Type 'svn help' for usage</programlisting>
        If Subversion is not installed, you will see something
        like:
        <programlisting>
-bash: svn: command not found</programlisting>
        If Subversion is not installed, you'll need to figure out how
        to install it on your OS. You can find information about
        obtaining and installing Subversion at
        the <ulink url="http://subversion.tigris.org">Subversion
        web page</ulink>.</para>
        </section>
        <section id="downloading-clozure-cl-using-subversion">
          <title>Downloading Clozure CL Using Subversion</title>
          <para>Before you download Clozure CL you should consider:
      Do you want to run the most recent source code, or the current stable release version?
      If you don't know how to answer this question, then you probably want the release version.
      </para>
          <section id="downloading-the-trunk">
            <title>Downloading the Trunk</title>
            <para>Day-to-day development of Clozure CL takes place in an area
      of the Subversion repository known as &quot;the trunk&quot;.  At most times,
      the trunk is perfectly usable, but occasionally it can be unstable
      or totally broken.
      If you wish to live on the bleeding edge, download sources from the trunk.</para>
            <para> For example, the following command will fetch a copy of the trunk
      for Mac OS X (Darwin) with x86 processors (both 32- and 64-bit versions):
      </para>
            <programlisting>svn co http://svn.clozure.com/publicsvn/openmcl/trunk/darwinx86/ccl
         </programlisting>
            <para>
	  To get a trunk Clozure CL for another platform, replace
	  &quot;darwinx86&quot; with one of the following names (all versions
	  include both 32- and 64-bit binaries):
	</para>
            <blockquote>
              <itemizedlist>
                <listitem><para>darwinx86</para></listitem>
                <listitem><para>linuxx86</para></listitem>
                <listitem><para>freebsdx86</para></listitem>
                <listitem><para>solarisx86</para></listitem>
                <listitem><para>windows</para></listitem>
                <listitem><para>linuxppc</para></listitem>
                <listitem><para>darwinppc</para></listitem>
              </itemizedlist>
            </blockquote>
          </section>
          <section id="downloading-a-release-version">
            <title>Downloading a Release Version</title>
            <para>Release versions of Clozure CL are intended to be stable.  While
	bugs will be fixed in the release branches, enhancements
	and new features will go into the trunk.
        If you wish to run the stable release,
        the following command will fetch a copy of the release version 1.7
	for Mac OS X (Darwin) with x86 processors (both 32- and 64-bit versions):
        </para>
            <programlisting>svn co http://svn.clozure.com/publicsvn/openmcl/release/1.7/darwinx86/ccl
          </programlisting>
            <para>To get the release version of Clozure CL  for another platform,
	replace &quot;darwinx86&quot; with one of the following names:
        </para>
            <blockquote>
              <itemizedlist>
                <listitem><para>darwinx86</para></listitem>
                <listitem><para>linuxx86</para></listitem>
                <listitem><para>freebsdx86</para></listitem>
                <listitem><para>solarisx86</para></listitem>
                <listitem><para>windows</para></listitem>
                <listitem><para>linuxppc</para></listitem>
                <listitem><para>darwinppc</para></listitem>
              </itemizedlist>
            </blockquote>
            <para>These distributions contain complete sources and
        binaries. They use Subversion's &quot;externals&quot; features to share
        common sources; the majority of source code is the same across
        all versions.</para>
          </section>
        </section>
      </section>
      <section id="rebuilding-clozure-cl-from-sources">
        <title>Rebuilding Clozure CL From Sources</title>
        <para>This section explains how to peform a &quot;full rebuild&quot; of Clozure CL from a source distribution.</para>
        <para>    After downloading Clozure CL sources, you should rebuild Clozure CL as described here.
    At the start of a full rebuild, object files in the <literal>ccl</literal> directory are deleted,
    which causes the build script to recompile the runtime kernel (C code) and high-level sources (Lisp),
    then save a new heap image.
    Doing a full rebuild helps to ensure that your local installation will run properly for your host OS environment.
    </para>
        <para><para>In an interactive shell, a command sequence like the following will rebuild Clozure CL in place:</para><para>    </para><programlisting>
joe&gt; cd <replaceable>/path/to/installed/ccl</replaceable>
joe:ccl&gt; ./<replaceable>kernel-filename</replaceable> --no-init
Welcome to Clozure Common Lisp Version [...]
? (rebuild-ccl :full t)
&lt;...lots of compilation output...&gt;
? (quit)
joe:ccl&gt;
    </programlisting></para>
        <para>Replace <replaceable>/path/to/installed/ccl</replaceable> with the path of the <literal>ccl</literal> directory
    that you downloaded.</para>
        <para>    Replace <replaceable>kernel-filename</replaceable> with the filename of the Lisp kernel program.
    To find the filename of a Lisp kernel image for your particular platform, see <xref linkend="platform-specific-filename-conventions"/>.</para>
        <para>    Specifying the <literal>--no-init</literal> option ensures that personal initializations do not interfere
    with rebuilding Clozure CL.
    </para>
        <para>The rest of this section covers the following topics in brief:
    <blockquote><itemizedlist><listitem><para><link linkend="software-requirements-for-building-clozure-cl">Software prerequisites</link></para></listitem><listitem><para><link linkend="when-to-rebuild-clozure-cl-from-sources">When to run the build process</link></para></listitem><listitem><para><link linkend="rebuilding-clozure-cl-using-rebuild-ccl">Using <literal>ccl-rebuild</literal></link></para></listitem><listitem><para><link linkend="summary-of-the-build-process-steps">What happens during the full rebuild process</link></para></listitem></itemizedlist></blockquote></para>
        <blockquote>
          <title>Note</title>
          <para>This section does <emphasis>not</emphasis> provide comprehensive documentation on the build process.
    Please refer to <xref linkend="building-clozure-cl-from-its-source-code"/> for more information.
    Those more detailed instructions are used mainly by developers who maintain, customize, and/or port Clozure CL.
    If you are customizing Clozure CL, or if you run into some exceptional situation,
    you may need to perform the individual build steps.
    </para>
        </blockquote>
        <section id="software-requirements-for-building-clozure-cl">
          <title>Software Requirements for Building Clozure CL</title>
          <para>In order to build Clozure CL you must have a working system and development environment.
    There are different requirements and setup procedures for each platform, but the main requirement is to have
    a C compiler and a few other utilities:
    GNU <literal>gcc</literal> or <literal>cc</literal> with <literal>ld</literal> and <literal>as</literal>;
    <literal>make</literal>; and <literal>m4</literal>.
    Please refer to <xref linkend="building-clozure-cl-from-its-source-code"/> for details.
    </para>
          <blockquote>
            <title>Note</title>
            <para>If you don't have the prerequisite C compiler toolchain installed, <literal>rebuild-ccl</literal> will not work.
    See <xref linkend="kernel-build-prerequisites"/> for additional details.
    </para>
          </blockquote>
          <para>Most distributions of Linux have all or most of the required development tools either pre-installed
    or readily available.
    On Debian-based Linux you can download and install the essential build tools using the package manager.
    For example: <programlisting>apt-get install build-essential</programlisting>
    (You may need to install C header files separately.)
    </para>
          <para>For Mac OS X, Xcode 4 is available from the App Store.</para>
          <para>    For Windows, install Cygwin and the MinGW toolchain for the 32- or 64-bit OS.
    More information about installing Clozure CL on Windows is available in the Clozure CL Wiki
    at URL: <ulink url="http://trac.clozure.com/ccl/wiki/WindowsNotes">http://trac.clozure.com/ccl/wiki/WindowsNotes</ulink></para>
        </section>
        <section id="when-to-rebuild-clozure-cl-from-sources">
          <title>When to Rebuild Clozure CL From Sources</title>
          <para>The most common scenario that requires a full rebuild is the standard installation after downloading the source tree.
    Users and application developers (who otherwise have no special build requirements)
    will generally need to run the full rebuild process just once
    for any given installation on a particular host system.</para>
          <para>    Another common scenario is installing a patch update:
    You can use Subversion (<literal>svn update</literal>) to download a more recent set of source files.
    (Be sure to download sources from the same path and branch in the source repository.)
    Then run a full rebuild to create new kernel and heap images.
    If you are running Clozure CL from the trunk, you may need to update sources and run the full rebuild more often.</para>
          <para>    Another reason to do a full rebuild is to ensure that Clozure CL will run properly in the host OS environment.
    This may be necessary, for example, when the target OS version
    is not identical to the one where the pre-built kernel was generated.
    The Lisp kernel uses some functionality defined in standard platform-provided libraries.
    On some platforms, applications (such as the Lisp kernel) are built in
    such a way as to depend on the specific versions of these libraries that were
    present at build time, and may not run on systems that have older or newer versions
    of these libraries.
    If you're affected by this, the simplest workaround is to build the Lisp kernel
    on the machine(s) that you intend to run it on and use that locally-built kernel instead of one distributed via Subversion.
    </para>
        </section>
        <section id="rebuilding-clozure-cl-using-rebuild-ccl">
          <title>Rebuilding Clozure CL Using REBUILD-CCL</title>
          <para>Once the checkout is complete, and provided that you have a working development setup,
    you can build Clozure CL by running the Lisp kernel (an OS-native executable program)
    and running <indexterm><primary><literal>REBUILD-CCL</literal></primary></indexterm><literal>REBUILD-CCL</literal> in Lisp.
    </para>
          <para><para>For example, to build a 64-bit Clozure CL on Mac OS X: </para><para>    </para><programlisting><para>
joe:ccl&gt; ./dx86cl64 --no-init
Welcome to Clozure Common Lisp Version 1.7  (DarwinX8664)!
? (rebuild-ccl :full t)
Rebuilding Clozure Common Lisp using Version 1.7  (DarwinX8664)
;Building lisp-kernel ...
;Kernel built successfully.
;Compiling &lt;...&gt;
;Loading &lt;...&gt;</para><para>&lt;...lots of compilation output...&gt;</para><para>;Wrote bootstrapping image: #P&quot;/Users/joe/ccl/x86-boot64.image&quot;
;Wrote heap image: #P&quot;/Users/joe/ccl/dx86cl64.image&quot;
NIL
? (quit)
joe:ccl&gt;</para></programlisting></para>
          <para><para>If the build fails for any reason, the kernel and/or heap image files may be missing or corrupted.
    To recover, delete the image files and update the source directory from Subversion.
    For example:</para><para>    </para><programlisting>
joe:ccl&gt; rm dx86cl*
joe:ccl&gt; svn update
&lt;... lots of Subversion output...&gt;
joe:ccl&gt; ./dx86cl64 --no-init
Welcome to Clozure Common Lisp Version 1.7  (DarwinX8664)!
? (rebuild-ccl :full t)
&lt;... lots of compilation output...&gt;
? (quit)
joe:ccl&gt; 
</programlisting></para>
          <para>Once the full rebuild is completed, you can run the new Lisp kernel from the command shell.
    However, running the OS- and processor-specific executable directly is not recommended
    for day-to-day use.
    Clozure CL includes the <literal>ccl</literal> and <literal>ccl64</literal> command shell scripts.
    For details on configuring a shell script for your environment, see <xref linkend="the-ccl-shell-script"/>.
    </para>
        </section>
        <section id="summary-of-the-build-process-steps">
          <title>Summary of the Build Process Steps</title>
          <para>Should the build fail, your first concern should be to confirm that all requirements are in place:
    the C compiler, utilities, and OS header files;
    source files for the trunk or release branch you want to build;
    and the Lisp kernel and heap image files.
    For assistance with trouble-shooting, here is an outline of the full build process,
    with links to the more detailed instructions in <xref linkend="building-clozure-cl-from-its-source-code"/>.
    <blockquote><itemizedlist><listitem><para>Build the Lisp kernel (<xref linkend="building-the-kernel"/>)</para></listitem><listitem><para>Build the heap image (<xref linkend="building-the-heap-image"/>)</para><blockquote><itemizedlist><listitem><para>Create a bootstrapping heap image (<xref linkend="generating-a-bootstrapping-image"/>)</para></listitem><listitem><para>Compile Lisp code to generate fasl files (<xref linkend="generating-fasl-files"/>)</para></listitem><listitem><para>Build a full image from bootstrapping image
        (<xref linkend="building-a-full-image-from-a-bootstrapping-image"/>)</para><blockquote><itemizedlist><listitem><para>Run new kernel with new bootstrapping image</para></listitem><listitem><para>Load Lisp code</para></listitem><listitem><para>Save a new full heap image</para></listitem></itemizedlist></blockquote></listitem></itemizedlist></blockquote></listitem></itemizedlist></blockquote></para>
        </section>
      </section>
    </section>
    <section id="command-line-set-up">
      <title>Command Line Set Up</title>
      <para>Sometimes it's convenient to use Clozure CL from a Unix
      shell command line.  This is especially true when using Clozure CL
      as a way to run Common Lisp utilities.</para>
      <section id="the-ccl-shell-script">
        <title>The ccl Shell Script</title>
        <para>Clozure CL needs to be able to find the
        <literal>ccl</literal> directory in order to support features
        such as <literal>require</literal> and
        <literal>provide</literal>, access to foreign interface
        information (see <xref linkend="the-interface-database"/>) and the Lisp build process (see
        <link linkend="building-clozure-cl-from-its-source-code">Building Clozure CL from its Source
        Code</link>). Specifically, it needs to set up logical
        pathname translations for the <literal>&quot;ccl:&quot;</literal>
        logical host.  If this logical host isn't defined (or isn't
        defined correctly), some things might work, some things might
        not, and it'll generally be hard to invoke and use Clozure CL
        productively.</para>
        <para>Clozure CL uses the value of the environment variable
        <literal>CCL_DEFAULT_DIRECTORY</literal> to determine the
        filesystem location of the <literal>ccl</literal> directory;
        the ccl shell script is intended to provide a way to
        invoke Clozure CL with that environment variable set
        correctly.</para>
        <para>        There are two versions of the shell script:
        <literal>&quot;ccl/scripts/ccl&quot;</literal> is used to invoke
        32-bit implementations of Clozure CL and
        <literal>&quot;ccl/scripts/ccl64&quot;</literal> is used to invoke
        64-bit implementations.
        Install one script or the other or both as needed.</para>
        <para>To use the script:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>Copy the script to a directory that is on your
	  <code>PATH</code>.  This is often
	  <literal>/usr/local/bin</literal> or
	  <literal>~/bin</literal>.  It is better to do this than to
	  add <literal>ccl/scripts</literal> to your
	  <code>PATH</code>, because the script needs to be edited,
	  and editing it in-place means that Subversion sees the script as
	  modified..</para></listitem>
            <listitem><para>Edit the definition of
            <literal>CCL_DEFAULT_DIRECTORY</literal> near the
            beginning of the shell script so that it refers to
            your <literal>ccl</literal> directory.  Alternately, set
            the value of the <literal>CCL_DEFAULT_DIRECTORY</literal>
            environment variable
            wherever you usually set per-user environment variables, in your
            <literal>.cshrc</literal>, <literal>.tcshrc</literal>,
            <literal>.bashrc</literal>, <literal>.bash_profile</literal>,
            or <literal>.MacOSX/environment.plist</literal> script,
            or system-wide in <literal>/etc/profile</literal> or <literal>/etc/bashrc</literal>.
            When the ccl script runs, if the process environment contains
            a definition of <literal>CCL_DEFAULT_DIRECTORY</literal>, the ccl
            script will not override it.
	  </para></listitem>
            <listitem><para>Ensure that the shell script is executable, for
            example:</para><para>            <literal>$ chmod +x
            ~/ccl/ccl/scripts/ccl64</literal></para><para>This command grants execute permission to the named
            script. If you are using a 32-bit platform, substitute
            &quot;ccl&quot; in place of &quot;ccl64&quot;.
            <blockquote><title>Warning</title><para>The above command won't work if you are not the
	            owner of the installed copy of Clozure CL. In that case,
	            you can use the &quot;sudo&quot; command like this:</para><para>                  <literal>$ sudo chmod +x
                  ~/ccl/ccl/scripts/ccl64</literal></para><para>Give your password when prompted.</para><para>                If the &quot;sudo&quot; command doesn't work, then you are
                not an administrator on the system you're using, and you
                don't have the appropriate &quot;sudo&quot; permissions. In that
                case you'll need to get help from the system's
                administrator.</para></blockquote></para></listitem>
          </orderedlist>
        </blockquote>
        <para>Note that most people won't need both
      <literal>ccl</literal> and <literal>ccl64</literal> scripts.
      You only need both if you sometimes run 32-bit Clozure CL and
      sometimes run 64-bit Clozure CL.  You can rename the script that
      you use to whatever you want.  For example, if you are on a
      64-bit system, and you only use Clozure CL in 64-bit mode, then
      you can rename  <literal>ccl64</literal> to
      <literal>ccl</literal> so that you only need to type
      &quot;<literal>ccl</literal>&quot; to run it.</para>
        <para><para>Once this is done, it should be possible to invoke Clozure CL
        by typing <literal>ccl</literal>
        or <literal>ccl64</literal> at a shell prompt:</para><para>      </para><programlisting>
shell&gt; ccl
Welcome to Clozure Common Lisp Version 1.7  (DarwinX8632)!
?</programlisting></para>
        <para>The ccl shell script passes all of its arguments to the
      Clozure CL kernel.  See <xref linkend="invocation"/> for more
      information about command-line arguments.</para>
        <para>      Assuming the shell script is configured and invoked properly, Clozure CL
      should be able to initialize the <literal>&quot;ccl:&quot;</literal>
      logical host so that its translations refer to the
      <literal>&quot;ccl&quot;</literal> directory. To test this, you can call
      <literal>probe-file</literal> in Clozure CL's read-eval-print
      loop:</para>
        <programlisting>
? (probe-file &quot;ccl:level-1;level-1.lisp&quot;)  ;returns the physical pathname of the file
#P&quot;/Users/joe/my_lisp_stuff/ccl/level-1/level-1.lisp&quot;
      </programlisting>
      </section>
      <section id="invocation">
        <title>Invocation</title>
        <para>Assuming that the shell script is properly installed, it can be used to invoke Clozure CL from a shell prompt:
	    <programlisting>shell&gt; <replaceable>ccl</replaceable><replaceable>[args ...]</replaceable></programlisting>
            By convention
	    <literal>ccl</literal> runs a 32-bit session;
	    <literal>ccl64</literal> runs a 64-bit session.
            However, the name of the installed script(s) and the implementation that is invoked are customizable,
            as described in <xref linkend="the-ccl-shell-script"/>.
	  </para>
        <para>For details about command-line options see
          <xref linkend="command-line-options"/>.
          </para>
      </section>
    </section>
    <section id="personal-customization-with-the-init-file">
      <title>Personal Customization with the Init File</title>
      <para>By default Clozure CL tries to load the file
      <literal>&quot;home:ccl-init.lisp&quot;</literal> or the compiled
      <literal>&quot;home:ccl-init.fasl&quot;</literal> upon starting up.
      Clozure CL does this by executing <literal>(load
      &quot;home:ccl-init&quot;)</literal>.  If it's unable to load the file
      (for example because the file doesn't exist), Clozure CL doesn't
      signal an error or warning, it just completes its startup
      normally.</para>
      <para>      On Unix systems, if <literal>&quot;ccl-init.lisp&quot;</literal> is not
      present, Clozure CL will look for <literal>&quot;.ccl-init.lisp&quot;</literal>
      (post 1.2 versions only).</para>
      <para>      The <literal>&quot;home:&quot;</literal> prefix to the filename is a
      Common Lisp logical host, which Clozure CL initializes to refer to
      your home directory. Clozure CL therefore looks for either of the
      files
      <literal>~/ccl-init.lisp</literal> or
      <literal>~/ccl-init.fasl</literal>.</para>
      <para>      Because the init file is loaded the same way as normal Lisp
      code is, you can put anything you want in it.  For example, you
      can change the working directory, and load packages that you use
      frequently.</para>
      <para>      To suppress the loading of this init-file, invoke Clozure CL with the
      <literal>--no-init</literal> option.</para>
    </section>
    <section id="command-line-options">
      <title>Command Line Options</title>
      <para>When using Clozure CL from the command line, the following
      options may be used to modify its behavior.  The exact set of
      Clozure CL command-line arguments may vary per platform and
      slowly changes over time.  The current set of command line
      options may be retrieved by using the
      <literal>--help</literal> option.</para>
      <blockquote>
        <itemizedlist>
          <listitem><para><literal>-h</literal> (or
	      <literal>--help</literal>).  Provides a definitive (if
	      somewhat terse) summary of the command line options
	      accepted by the Clozure CL implementation and then
	      exits.</para></listitem>
          <listitem><para><literal>-V</literal> (or
	      <literal>--version</literal>).  Prints the version of
	      Clozure CL then exits.  The version string is the same value
	      that is returned by
	      <indexterm><primary><literal>LISP-IMPLEMENTATION-VERSION</literal></primary></indexterm><literal>LISP-IMPLEMENTATION-VERSION</literal>.</para></listitem>
          <listitem><para><literal>-K</literal><parameter>character-encoding-name</parameter> (or
	      <literal>--terminal-encoding</literal><parameter>character-encoding-name</parameter>).
	      Specifies the character encoding to use for
	      <indexterm><primary><literal>*TERMINAL-IO*</literal></primary></indexterm><literal>*TERMINAL-IO*</literal> (see <xref linkend="character-encodings"/>).  Specifically, the
	      <parameter>character-encoding-name</parameter> string
	      is uppercased and interned in the KEYWORD package. If an
	      encoding named by that keyword exists,
	      <indexterm><primary><literal>*TERMINAL-CHARACTER-ENCODING-NAME*</literal></primary></indexterm><literal>*TERMINAL-CHARACTER-ENCODING-NAME*</literal> is set to the name
	      of that encoding.   <indexterm><primary><literal>*TERMINAL-CHARACTER-ENCODING-NAME*</literal></primary></indexterm><literal>*TERMINAL-CHARACTER-ENCODING-NAME*</literal> defaults to <literal>NIL</literal>, which
	      is a synonym for <literal>:ISO-8859-1</literal>.</para><para>For example:
	      <programlisting>
shell&gt; ccl -K utf-8</programlisting>
	      has the effect of making the standard CL streams use
	      <literal>:UTF-8</literal> as their character
	      encoding.</para></listitem>
          <listitem><para><literal>-n</literal> (or
	      <literal>--no-init</literal>). If this option is given, the
	      init file is not loaded.  This is useful if Clozure CL is being
	      invoked by a shell script that should not be affected by
	      whatever customizations a user might have in place.</para></listitem>
          <listitem><para><literal>-e</literal><parameter>form</parameter>
	      (or <literal>--eval</literal>). An expression is read (via
	      <indexterm><primary><literal>READ-FROM-STRING</literal></primary></indexterm><literal>READ-FROM-STRING</literal>) from the string
	      <parameter>form</parameter> and evaluated. If
	      <parameter>form</parameter> contains shell metacharacters,
	      it may be necessary to escape or quote them to prevent the
	      shell from interpreting them.</para></listitem>
          <listitem><para><literal>-l</literal><parameter>path</parameter>
	      (or <literal>--load</literal><parameter>path</parameter>). Loads file specified by
	      <parameter>path</parameter>.</para></listitem>
          <listitem><para><literal>-T</literal><parameter>n</parameter> (or
	      <literal>--set-lisp-heap-gc-threshold</literal><parameter>n</parameter>).  Sets the Lisp gc threshold to
	      <parameter>n</parameter>. (see <xref linkend="gc-page-reclamation-policy"/></para></listitem>
          <listitem><para><literal>-Q</literal> (or
	      <literal>--quiet</literal>). Suppresses printing of
	      heralds and prompts when the <literal>--batch</literal>
	      command line option is specified.</para></listitem>
          <listitem><para><literal>-R</literal><parameter>n</parameter> (or
	      <literal>--heap-reserve</literal>). Reserves
	      <parameter>n</parameter> bytes for heap expansion.  The
	      default is <literal>549755813888</literal>.  (see <xref linkend="heap-space-allocation"/>)</para></listitem>
          <listitem><para><literal>-S</literal><parameter>n</parameter> (or
	      <literal>--stack-size</literal><parameter>n</parameter>). Sets the size of the
	      initial control stack to <parameter>n</parameter>. (see <xref linkend="thread-stack-sizes"/>)</para></listitem>
          <listitem><para><literal>-Z</literal><parameter>n</parameter> (or
	      <literal>--thread-stack-size</literal><parameter>n</parameter>). Sets the size of the first
	      thread's stack to <parameter>n</parameter>. (see <xref linkend="thread-stack-sizes"/>)</para></listitem>
          <listitem><para><literal>-b</literal> (or <literal>--batch</literal>). Execute in &quot;batch mode&quot;. End-of-file
	      from <indexterm><primary><literal>*STANDARD-INPUT*</literal></primary></indexterm><literal>*STANDARD-INPUT*</literal> causes Clozure CL to exit, as do attempts to
	      enter a break loop.</para></listitem>
          <listitem><para><literal>--no-sigtrap</literal> An obscure option for running under GDB.</para></listitem>
          <listitem><para><literal>-I</literal><parameter>image-name</parameter> (or
	      <literal>--image-name</literal><parameter>image-name</parameter>). Specifies the image
	      name for the kernel to load.  Defaults to the kernel name
	      with &quot;.image&quot; appended.</para></listitem>
        </itemizedlist>
      </blockquote>
      <para>The <literal>--load</literal> and
      <literal>--eval</literal> options can each be provided
      multiple times.  They're executed in the order specified on
      the command line, after the init file (if there is one) is
      loaded and before the toplevel read-eval-print loop is
      entered.</para>
      <para>	Finally, any arguments following the pseudo-argument
	<literal>--</literal> are not processed, and are made
	available to Lisp as the value of
	<literal>ccl:*unprocessed-command-line-arguments*</literal>.
      </para>
    </section>
    <section id="using-clozure-cl-with-gnu-emacs-and-slime">
      <title>Using Clozure CL with GNU Emacs and SLIME</title>
      <para>
      SLIME (see  <ulink url="http://common-lisp.net/project/slime/">the SLIME web page</ulink>) is an Emacs mode for interacting with
      Common Lisp systems.  Clozure CL is well-supported by SLIME.</para>
      <para>      See the <ulink url="http://trac.clozure.com/ccl/wiki/InstallingSlime">InstallingSlime</ulink> topic on the Clozure CL wiki for some tips
      on how to get SLIME running with Clozure CL.
    </para>
    </section>
    <section id="example-programs">
      <title>Example Programs</title>
      <para>A number (ok, a <emphasis>small</emphasis> number), of
    example programs are distributed in the &quot;ccl:examples;&quot; directory
    of the source distribution. See the README-OPENMCL-EXAMPLES text
    file in that directory for information about prerequisites and
    usage.</para>
      <para>      Some of the example programs are derived from C examples
      in textbooks, etc.; in those cases, the original author and work
      are cited in the source code.</para>
      <para>      Unless the original author or contributor claims other
      rights, you're free to incorporate any of this example code or
      derivative thereof in any of your own works without
      restriction. In doing so, you agree that the code was provided
      &quot;as is&quot;, and that no other party is legally or otherwise
      responsible for any consequences of your decision to use
      it.</para>
      <para>      If you've developed Clozure CL examples that you'd like to see
      added to the distribution, please send mail to the Clozure CL mailing
      lists. Any such contributions would be welcome and appreciated
      (as would bug fixes and improvements to the existing
      examples.)</para>
    </section>
  </chapter>
  <chapter id="building-clozure-cl-from-its-source-code">
    <title>Building Clozure CL from its Source Code</title>
    <para>Clozure CL, like many other Lisp implementations, consists of a
    kernel and a heap image.  The kernel is an ordinary C program, and
    is built with a C compiler.  It provides very basic and
    fundamental facilities, such as memory management, garbage
    collection, and bootstrapping.  All the higher-level features are
    written in Lisp, and compiled into the heap image.  Both parts are
    needed to have a working Lisp implementation; neither the kernel
    nor the heap image can stand alone.</para>
    <para>    You may already know that, when you have a C compiler which
    is written in C, you need a working C compiler to build the
    compiler. Similarly, the Clozure CL heap image includes a Lisp
    compiler, which is written in Lisp. You therefore need a working
    Lisp compiler in order to build the Lisp heap image.</para>
    <para>    Where will you get a working Lisp compiler?  No worries; you
    can use a precompiled copy of a (slightly older and compatible)
    version of Clozure CL. This section explains how to do all this.</para>
    <para>    In principle it should be possible to use another
    implementation of Common Lisp as the host compiler, rather than an
    older Clozure CL; this would be a challenging and experimental way to
    build, and is not described here.</para>
    <section id="building-definitions">
      <title>Building Definitions</title>
      <para>The following terms are used in subsequent sections; it
      may be helpful to refer to these definitions.</para>
      <para><indexterm><primary>fasl files</primary></indexterm><glossterm linkend="fasl_file">fasl files</glossterm> are the object files produced
      by <literal>compile-file</literal>.  fasl files store the
      machine code associated with function definitions and the
      external representation of other lisp objects in a compact,
      machine-readable form. fasl is short for
      &quot;<literal>FAS</literal>t
      <literal>L</literal>oading&quot;. Clozure CL uses different pathname
      types (extensions) to name fasl files on different platforms;
      see
      <xref linkend="tab_platform-specific-filename-conventions"/></para>
      <para>The <indexterm><primary>Lisp kernel</primary></indexterm><glossterm linkend="kernel">Lisp kernel</glossterm> is a C program with a fair amount of
      platform-specific assembly language code. Its basic job is to
      map a lisp heap image into memory, transfer control to some
      compiled lisp code that the image contains, handle any
      exceptions that occur during the execution of that lisp code,
      and provide various other forms of runtime support for that
      code. Clozure CL uses different filenames to name the lisp kernel
      files on different platforms; see
      <xref linkend="tab_platform-specific-filename-conventions"/>.</para>
      <para>A <indexterm><primary>heap image</primary></indexterm><glossterm linkend="image">heap image</glossterm> is a file that can be quickly mapped into a
      process's address space. Conceptually, it's not too different
      from an executable file or shared library in the OS's native
      format (ELF or Mach-O/dyld format); for historical reasons,
      Clozure CL's own heap images are in their own (fairly simple)
      format. The term <literal>full heap image</literal> refers to a
      heap image file that contains all of the code and data that
      comprise Clozure CL. Clozure CL uses different filenames to name the
      standard full heap image files on different platforms; see
      <xref linkend="tab_platform-specific-filename-conventions"/>.</para>
      <para>A bootstrapping image (<xref linkend="generating-a-bootstrapping-image"/>)
      is a minimal
      heap image used in the process of building Clozure CL itself.  The
      bootstrapping image contains just enough code to load the rest
      of Clozure CL from fasl files.  It may help to think of the
      bootstrapping image as the egg and the full heap image as the
      chicken. Clozure CL uses different filenames to name the standard
      bootstrapping image files on different platforms; see
      <xref linkend="tab_platform-specific-filename-conventions"/>
      .</para>
      <para>Each supported platform (and possibly a few
      as-yet-unsupported ones) has a uniquely named subdirectory of
      <literal>ccl/lisp-kernel/</literal>; each such
      kernel build directory
      contains a Makefile and may contain some auxiliary files (linker
      scripts, etc.) that are used to build the lisp kernel on a
      particular platform.The platform-specific name of the kernel
      build directory is described in
      <xref linkend="tab_platform-specific-filename-conventions"/>.</para>
      <section id="platform-specific-filename-conventions">
        <title>Platform-specific filename conventions</title>
        <table id="tab_platform-specific-filename-conventions">
          <title>Platform-specific filename conventions</title>
          <tgroup cols="6">
            <thead><row><entry>Platform</entry><entry>kernel</entry><entry>full-image</entry><entry>boot-image</entry><entry>fasl extension</entry><entry>kernel-build directory</entry></row></thead>
            <tbody>
              <row>
                <entry>DarwinPPC32</entry>
                <entry>dppccl</entry>
                <entry>dppccl.image</entry>
                <entry>ppc-boot.image</entry>
                <entry>.dfsl</entry>
                <entry>darwinppc</entry>
              </row>
              <row>
                <entry>LinuxPPC32</entry>
                <entry>ppccl</entry>
                <entry>ppccl.image</entry>
                <entry>ppc-boot</entry>
                <entry>.pfsl</entry>
                <entry>linuxppc</entry>
              </row>
              <row>
                <entry>DarwinPPC64</entry>
                <entry>dppccl64</entry>
                <entry>dppccl64.image</entry>
                <entry>ppc-boot64.image</entry>
                <entry>.d64fsl</entry>
                <entry>darwinppc64</entry>
              </row>
              <row>
                <entry>LinuxPPC64</entry>
                <entry>ppccl64</entry>
                <entry>ppccl64.image</entry>
                <entry>ppc-boot64</entry>
                <entry>.p64fsl</entry>
                <entry>linuxppc64</entry>
              </row>
              <row>
                <entry>LinuxX8664</entry>
                <entry>lx86cl64</entry>
                <entry>lx86cl64.image</entry>
                <entry>x86-boot64</entry>
                <entry>.lx64fsl</entry>
                <entry>linuxx8664</entry>
              </row>
              <row>
                <entry>LinuxX8632</entry>
                <entry>lx86cl</entry>
                <entry>lx86cl.image</entry>
                <entry>x86-boot32</entry>
                <entry>.lx32fsl</entry>
                <entry>linuxx8632</entry>
              </row>
              <row>
                <entry>DarwinX8664</entry>
                <entry>dx86cl64</entry>
                <entry>dx86cl64.image</entry>
                <entry>x86-boot64.image</entry>
                <entry>.dx64fsl</entry>
                <entry>darwinx8664</entry>
              </row>
              <row>
                <entry>DarwinX8632</entry>
                <entry>dx86cl</entry>
                <entry>dx86cl.image</entry>
                <entry>x86-boot32.image</entry>
                <entry>.dx32fsl</entry>
                <entry>darwinx8632</entry>
              </row>
              <row>
                <entry>FreeBSDX8664</entry>
                <entry>fx86cl64</entry>
                <entry>fx86cl64.image</entry>
                <entry>fx86-boot64</entry>
                <entry>.fx64fsl</entry>
                <entry>freebsdx8664</entry>
              </row>
              <row>
                <entry>FreeBSDX8632</entry>
                <entry>fx86cl</entry>
                <entry>fx86cl.image</entry>
                <entry>fx86-boot32</entry>
                <entry>.fx32fsl</entry>
                <entry>freebsdx8632</entry>
              </row>
              <row>
                <entry>SolarisX64</entry>
                <entry>sx86cl64</entry>
                <entry>sx86cl64.image</entry>
                <entry>sx86-boot64</entry>
                <entry>.sx64fsl</entry>
                <entry>solarisx64</entry>
              </row>
              <row>
                <entry>SolarisX86</entry>
                <entry>sx86cl</entry>
                <entry>sx86cl.image</entry>
                <entry>sx86-boot32</entry>
                <entry>.sx32fsl</entry>
                <entry>solarisx86</entry>
              </row>
              <row>
                <entry>Win64</entry>
                <entry>wx86cl64.exe</entry>
                <entry>sx86cl64.image</entry>
                <entry>wx86-boot64.image</entry>
                <entry>.wx64fsl</entry>
                <entry>win64</entry>
              </row>
              <row>
                <entry>Win32</entry>
                <entry>wx86cl.exe</entry>
                <entry>wx86cl.image</entry>
                <entry>wx86-boot32.image</entry>
                <entry>.wx32fsl</entry>
                <entry>win32</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section id="setting-up-to-build">
      <title>Setting Up to Build</title>
      <para>At a given time, there are generally two versions of Clozure CL that
    you might want to use (and therefore might want to build from
      source):</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>The released version</para></listitem>
          <listitem><para>The development version, called the &quot;trunk&quot;, which
      may contain both interesting new features and interesting new bugs
      </para></listitem>
        </itemizedlist>
      </blockquote>
      <para>All versions are available for download from svn.clozure.com via
    the Subversion source control system.</para>
      <para>
      For example, to get a released version (1.7 in this example),
      use a command like:
      <programlisting>svn co http://svn.clozure.com/publicsvn/openmcl/release/1.7/<replaceable>xxx</replaceable>/ccl</programlisting></para>
      <para>
      To get the trunk version, use:
      <programlisting>svn co http://svn.clozure.com/publicsvn/openmcl/trunk/<replaceable>xxx</replaceable>/ccl</programlisting></para>
      <para>
      Change the <emphasis><literal>xxx</literal></emphasis> to one of the following names:
      <literal>darwinx86</literal>,
      <literal>linuxx86</literal>,
      <literal>freebsdx86</literal>,
      <literal>solarisx86</literal>,
      <literal>windows</literal>,
      <literal>linuxppc</literal>,
      or 
      <literal>darwinppc</literal>.</para>
      <para>      Tarball distributions of released versions are also available for download via ftp from:
      <ulink url="ftp://clozure.com/pub/release/">ftp://clozure.com/pub/release/</ulink>.
      For additional information about availability of source and distributions see the
      <ulink url="http://trac.clozure.com/ccl/">Clozure CL Trac</ulink>.</para>
      <para>      Subversion client programs are pre-installed on Mac OS X 10.5 and
      later and are typically either pre-installed or readily available
      on Linux and FreeBSD platforms.  The <ulink url="http://subversion.tigris.org">Subversion web page</ulink> contains links to Subversion client programs
      for many platforms.
      Users of Mac OS X 10.4 or later can also
      install Subversion clients via Fink or MacPorts.
      On Debian Linux (and on related Linux distros such as Ubuntu) run
      <literal>apt-get install subversion</literal> or equivalent in the command-line or interactive package manager.
    </para>
    </section>
    <section id="kernel-build-prerequisites">
      <title>Kernel Build Prerequisites</title>
      <para>The Clozure CL kernel can be built with the following widely
          available tools:</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>cc or gcc - the GNU C compiler</para></listitem>
          <listitem><para>ld - the GNU linker</para></listitem>
          <listitem><para>m4 or gm4 - the GNU m4 macro processor</para></listitem>
          <listitem><para>as - the GNU assembler (version 2.10.1 or later)</para></listitem>
          <listitem><para>make - either GNU make or, on FreeBSD, the default BSD make program</para></listitem>
        </itemizedlist>
      </blockquote>
      <para> In general, the more recent the versions of those
          tools, the better; some versions of gcc 3.x on Linux have
          difficulty compiling some of the kernel source code correctly
          (so gcc 4.0 should be used, if possible.)  On Mac OS X, the
          versions of the tools distributed with Xcode should work fine;
          on Linux, the versions of the tools installed with the OS (or
          available through its package management system) should work
          fine if they're &quot;recent enough&quot;.  On FreeBSD, the installed
          version of the <literal>m4</literal> program doesn't support
          some features that the kernel build process depends on; the
          GNU version of the m4 macroprocessor (called
          <literal>gm4</literal> on FreeBSD) should be installed.
        </para>
      <blockquote>
        <title>Note</title>
        <para>In order to build the lisp kernel on Mac OS X
        10.6 Snow Leopard, you must install the optional 10.4
        support when installing Xcode.</para>
      </blockquote>
    </section>
    <section id="building-everything">
      <title>Building Everything</title>
      <para>You now have everything you need.  Start up
      Clozure CL with the <literal>-n</literal> or <literal>--no-init</literal>
      option to avoid potential interference from code in your init file,
      and evaluate the following form to bring your Lisp system
      up to date.</para>
      <programlisting>
? (ccl:rebuild-ccl :full t)
    </programlisting>
      <para>That call to the function <literal>rebuild-ccl</literal>
      performs the following steps:</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>Deletes all fasl files and other object files in the
	      <literal>ccl</literal> directory tree</para></listitem>
          <listitem><para>Runs an external process that does a
	      <literal>make</literal> in the current platform's kernel
	      build directory to create a new kernel.  
             This step can only work if the C compiler and related
             tools are installed; see <xref linkend="kernel-build-prerequisites"/>. 
           </para></listitem>
          <listitem><para>Does <literal>(compile-ccl t)</literal> in the running
	      lisp, to produce a set of fasl files from the &quot;higher
	      level&quot; lisp sources.</para></listitem>
          <listitem><para>Does <literal>(xload-level-0 :force)</literal> in the
	      running lisp, to compile the lisp sources in the
	      &quot;ccl:level-0;&quot; directory into fasl files and
	      then create a bootstrapping image from those fasl
	      files.</para></listitem>
          <listitem><para>Runs another external process, which causes the newly
	      compiled lisp kernel to load the new bootstrapping image.
	      The bootstrapping image then loads the &quot;higher
	      level&quot; fasl files and a new copy of the platform's
	      full heap image is then saved.</para></listitem>
        </itemizedlist>
      </blockquote>
      <para>If all goes well, it'll all happen without user
      intervention and with some simple progress messages.  If
      anything goes wrong during execution of either of the external
      processes, the process output is displayed as part of a lisp
      error message.</para>
      <para>      <literal>rebuild-ccl</literal> is essentially just a short
      cut for running all the individual steps involved in rebuilding
      the system.  You can also execute these steps individually, as
      described below.</para>
    </section>
    <section id="building-the-kernel">
      <title>Building the Kernel</title>
      <para>The Lisp kernel is the executable that you run to use
      Lisp.  It doesn't actually contain the entire Lisp
      implementation; rather, it loads a heap image which contains the
      specifics-the &quot;library&quot;, as it might be called if this was a C
      program.  The kernel also provides runtime support to the heap
      image, such as garbage collection, memory allocation, exception
      handling, and the OS interface.</para>
      <para>The Lisp kernel file has different names on different
      platforms. See
      <xref linkend="tab_platform-specific-filename-conventions"/>. On all
      platforms the lisp kernel sources reside
      in <literal>ccl/lisp-kernel</literal>.</para>
      <para>This section gives directions on how to rebuild the Lisp
      kernel from its source code.  Most Clozure CL users will rarely
      have to do this.  You probably will only need to do it if you are
      attempting to port Clozure CL to a new architecture or extend or enhance
      its kernel in some way.  As mentioned above, this step happens
      automatically when you do
      <programlisting>
? (rebuild-ccl :full t)
      </programlisting></para>
      <section id="using-make-to-build-the-lisp-kernel">
        <title>Using &quot;make&quot; to build the lisp kernel</title>
        <para>With those tools in place, do:
        <programlisting>
shell&gt; cd ccl/lisp-kernel/<replaceable>PLATFORM</replaceable>
shell&gt; make
	    </programlisting></para>
        <para>That'll assemble several assembly language source files,
        compile several C source files, and link
        ../../<replaceable>the kernel</replaceable>.
	  </para>
      </section>
    </section>
    <section id="building-the-heap-image">
      <title>Building the Heap Image</title>
      <para>The initial heap image is loaded by the Lisp kernel, and
      provides most of the language implementation The heap image
      captures the entire state of a running Lisp (except for external
      resources, such as open files and TCP sockets).  After it is
      loaded, the contents of the new Lisp process's memory are
      exactly the same as those of the old Lisp process when the image
      was created.</para>
      <para>      The heap image is how we get around the fact that we can't
      run Lisp code until we have a working Lisp implementation, and
      we can't make our Lisp implementation work until we can run Lisp
      code.  Since the heap image already contains a fully-working
      implementation, all we need to do is load it into memory and
      start using it.</para>
      <para>      If you're building a new version of Clozure CL, you need to
      build a new heap image.</para>
      <para>      (You might also wish to build a heap image if you have a
      large program that is very complicated or time-consuming to
      load, so that you will be able to load it once, save an image,
      and thenceforth never have to load it again. At any time, a heap
      image capturing the entire memory state of a running Lisp can be
      created by calling the function
      <literal>ccl:save-application</literal>.)</para>
      <section id="development-cycle">
        <title>Development cycle</title>
        <para>Creating a new Clozure CL full heap image consists of the
        following steps:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>Using your existing Clozure CL, create a
            bootstrapping image</para></listitem>
            <listitem><para>Using your existing Clozure CL, recompile your
            updated Clozure CL sources</para></listitem>
            <listitem><para>Invoke Clozure CL with the bootstrapping image
            you just created (rather than with the existing full heap
            image).</para></listitem>
          </orderedlist>
        </blockquote>
        <para>When you invoke Clozure CL with the bootstrapping image, it
	    starts up, loads all of the Clozure CL fasl files, and saves out a
	    new full heap image.  Voila.  You've created a new heap
	    image.</para>
        <para>A few points worth noting:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>There's a circular dependency between the full heap
	        image and the bootstrapping image, in that each is used to
	        build the other.</para></listitem>
            <listitem><para>There are some minor implementation
	        differences, but the environment in effect after the
	        bootstrapping image has loaded its fasl files is essentially
	        equivalent to the environment provided by the full heap
	        image; the latter loads a lot faster and is easier to
	        distribute, of course.</para></listitem>
            <listitem><para>If the full heap image doesn't work (because
	        of an OS compatibilty problem or other bug), it's very likely
	        that the bootstrapping image will suffer the same
	        problems.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>Given a bootstrapping image and a set of up-to-date fasl
        files, the development cycle usually involves editing lisp
        sources (or updating those sources via <literal>svn update</literal>),
        recompiling modified files, and using the bootstrapping image
        to produce a new heap image.</para>
      </section>
      <section id="generating-a-bootstrapping-image">
        <title>Generating a bootstrapping image</title>
        <para>The bootstrapping image isn't provided in Clozure CL
        distributions. It can be built from the source code provided
        in distributions (using a lisp image and kernel provided in
        those distributions) using the procedure described
        below.</para>
        <para>        The bootstrapping image is built by invoking a special
        utility inside a running Clozure CL heap image to load files
        contained in the <literal>ccl/level-0</literal> directory. The
        bootstrapping image loads several dozen fasl files.  After
        it's done so, it saves a heap image via
        <literal>save-application</literal>. This process is called
        &quot;cross-dumping&quot;.</para>
        <para>        Given a source distribution, a lisp kernel, and a heap
        image, one can produce a bootstrapping image by first invoking
        Clozure CL from the shell:</para>
        <programlisting>
shell&gt; ccl
Welcome to Clozure CL .... !
?
	  </programlisting>
        <para>then calling <literal>ccl:xload-level-0</literal> at the
	    lisp prompt:</para>
        <programlisting>
? (ccl:xload-level-0)
	  </programlisting>
        <para>This function compiles the lisp sources in the <literal>ccl/level-0</literal>
        directory if they're newer than the corresponding fasl files
        and then loads the resulting fasl files into a simulated lisp
        heap contained in data structures inside the running
        lisp. That simulated heap image is then written to
        disk.</para>
        <para>        <literal>xload-level-0</literal> should be called
        whenever your existing boot image is out-of-date with respect
        to the source files in <literal>ccl:level-0;</literal>
        - For example:</para>
        <programlisting>
? (ccl:xload-level-0 :force)
      </programlisting>
        <para>forces recompilation of the level-0 sources.</para>
      </section>
      <section id="generating-fasl-files">
        <title>Generating fasl files</title>
        <para> Calling:</para>
        <programlisting>
? (ccl:compile-ccl)
	  </programlisting>
        <para>at the lisp prompt compiles any fasl files that are
	    out-of-date with respect to the corresponding lisp sources;
	    <literal>(ccl:compile-ccl t)</literal> forces
	    recompilation. <literal>ccl:compile-ccl</literal> reloads
	    newly-compiled versions of some files;
	    <literal>ccl:xcompile-ccl</literal> is analogous, but skips
	    this reloading step.</para>
        <para>        Unless there are bootstrapping considerations involved, it
        usually doesn't matter whether these files are reloaded after
        they're recompiled.</para>
        <para>        Calling <literal>compile-ccl</literal> or
        <literal>xcompile-ccl</literal> in an environment where fasl
        files don't yet exist may produce warnings to that effect
        whenever files are <literal>require</literal>d during
        compilation; those warnings can be safely ignored. Depending
        on the maturity of the Clozure CL release, calling
        <literal>compile-ccl</literal> or
        <literal>xcompile-ccl</literal> may also produce several
        warnings about undefined functions, etc. They should be
        cleaned up at some point.</para>
      </section>
      <section id="building-a-full-image-from-a-bootstrapping-image">
        <title>Building a full image from a bootstrapping image</title>
        <para>To build a full image from a bootstrapping image, just
	    invoke the kernel with the bootstrapping image as an
	    argument</para>
        <programlisting>
$ cd ccl                        # wherever your ccl directory is
$ ./<replaceable>KERNEL</replaceable> --image-name <replaceable>BOOT_IMAGE</replaceable> --no-init
	  </programlisting>
        <para>Where <replaceable>KERNEL</replaceable> and
        <replaceable>BOOT_IMAGE</replaceable> are the names of
        the kernel and boot image appropriate to the platform you are
        running on.  See <xref linkend="tab_platform-specific-filename-conventions"/></para>
        <para>That should load a few dozen fasl files (printing a
        message as each file is loaded.) If all of these files
        successfully load, the lisp will print a prompt. You should be
        able to do essentially everything in that environment that you
        can in the environment provided by a &quot;real&quot; heap image. If
        you're confident that things loaded OK, you can save that
        image:</para>
        <programlisting>
? (ccl:save-application &quot;<replaceable>image_name</replaceable>&quot;) ; Overwriting the existing heap image
	  </programlisting>
        <para>Where <replaceable>image_name</replaceable> is the name of
        the full heap image for your platform. See
        <xref linkend="tab_platform-specific-filename-conventions"/>.</para>
        <para>If things go wrong in the early stages of the loading
        sequence, errors are often difficult to debug; until a fair
        amount of code (CLOS, the CL condition system, streams, the
        reader, the read-eval-print loop) is loaded, it's generally
        not possible for the lisp to report an error.  Errors that
        occur during these early stages (&quot;the cold load&quot;) sometimes
        cause the lisp kernel debugger (see ) to be invoked; it's
        primitive, but can sometimes help one to get oriented.</para>
      </section>
    </section>
  </chapter>
  <chapter id="using-clozure-cl">
    <title>Using Clozure CL</title>
    <section id="introduction_in_using-clozure-cl">
      <title>Introduction</title>
      <para>The Common Lisp standard allows considerable latitude in the
      details of an implementation, and each particular Common Lisp
      system has some idiosyncrasies. This chapter describes ordinary
      user-level features of Clozure CL, including features that may be
      part of the Common Lisp standard, but which may have quirks or
      details in the Clozure CL implementation that are not described by
      the standard. It also describes extensions to the standard; that
      is, features of Clozure CL that are not part of the Common Lisp
      standard at all.</para>
    </section>
    <section id="trace">
      <title>Trace</title>
      <para>
      Clozure CL's tracing facility is invoked by an extended version of the Common Lisp
      <literal>trace</literal> macro.  Extensions allow tracing of methods, as well as finer control
      over tracing actions.
    </para>
      <refentry id="m_trace">
        <indexterm zone="m_trace"><primary><literal>TRACE</literal></primary></indexterm>
        <refnamediv>
          <refname>TRACE</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>TRACE { keyword global-value }* { spec | ( spec { keyword local-value }*)}*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_m_trace">
          <title>Description</title>
          <para>
      The <literal>trace</literal> macro encapsulates the functions named by
      <replaceable>spec</replaceable>s, causing trace actions to take place on entry and
      exit from each function.  The default actions print a message on function entry and
      exit. <replaceable>Keyword</replaceable>/<replaceable>value</replaceable> options
      can be used to specify changes in the default behavior.</para>
          <para>      Invoking <literal>(trace)</literal> without arguments returns a list of functions being traced.</para>
          <para>      A <replaceable>spec</replaceable> is either a symbol that is the name of a function, or an
      expression of the form <literal>(setf <replaceable>symbol</replaceable>)</literal>, or a
      specific method of a generic function in the form <literal>(:method
        <replaceable>gf-name</replaceable> {<replaceable>qualifier</replaceable>}*
        ({<replaceable>specializer</replaceable>}*))</literal>, where a
      <replaceable>specializer</replaceable> can be the name of a class or an <literal>EQL</literal>
      specializer.</para>
          <para>      A <replaceable>spec</replaceable> can also be a string naming a package, or equivalently a
      list <literal>(:package <replaceable>package-name</replaceable>)</literal>, in order to
      request that all functions in the package to be traced.</para>
          <para>      By default, whenever a traced function is entered or exited, a short message is
      printed on <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal> showing the arguments on entry and
      values on exit.  Options specified as key/value pairs can be used to modify this
      behavior.  Options preceding the function <replaceable>spec</replaceable>s apply to
      all the functions being traced.  Options specified along with a
      <replaceable>spec</replaceable> apply to that spec only and override any
      global options. The following options are supported:
    </para>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><literal>:methods {T | nil}</literal></term>
                <listitem><para> If true, and if applied to a <replaceable>spec</replaceable> naming a generic
	        function, arranges to trace all the methods of the generic function in addition to the
	        generic function itself.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:inside <replaceable>outside-spec</replaceable>
	        | ({<replaceable>outside-spec</replaceable>}*)</literal></term>
                <listitem><para>Inhibits all trace actions unless the current
	        invocation of the function being traced is inside one of the
	        <replaceable>outside-spec</replaceable>'s, i.e. unless a function named by one of the
	        <replaceable>outside-spec</replaceable>'s is currently on the stack.
	        <replaceable>outside-spec</replaceable> can name a function, a
	        method, or a package, as above.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:if <replaceable>form</replaceable></literal>, <literal>:condition <replaceable>form</replaceable></literal></term>
                <listitem><para> Evaluates <replaceable>form</replaceable> whenever the function being traced is
	        about to be entered, and inhibits all trace actions if <replaceable>form</replaceable>
	        returns nil. The form may reference the lexical variable <literal>ccl::args</literal>,
	        which is a list of the arguments in this call. <literal>:condition</literal> is just a
	        synonym for <literal>:if</literal>, though if both are specified, both must return non-nil.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:before-if <replaceable>form</replaceable></literal></term>
                <listitem><para> Evaluates <replaceable>form</replaceable> whenever the function being traced is
	        about to be entered, and inhibits the entry trace actions if
	        <replaceable>form</replaceable> returns nil.  The form may reference the lexical variable
	        <literal>ccl::args</literal>, which is a list of the arguments in this call. If both
	        <literal>:if</literal> and <literal>:before-if</literal> are specified, both must return
	        non-nil in order for the before entry actions to happen.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:after-if <replaceable>form</replaceable></literal></term>
                <listitem><para> Evaluates <replaceable>form</replaceable> whenever the function being traced has
	        just exited, and inhibits the exit trace actions if <replaceable>form</replaceable>
	        returns nil.  The form may reference the lexical variable <literal>ccl::vals</literal>,
	        which is a list of values returned by this call. If both <literal>:if</literal> and
	        <literal>:after-if</literal> are specified, both must return non-nil in order for the
	        after exit actions to happen.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:print-before <replaceable>form</replaceable></literal></term>
                <listitem><para> Evaluates <replaceable>form</replaceable> whenever the function being traced is
	        about to be entered, and prints the result before printing the standard entry message.
	        The form may reference the lexical variable <literal>ccl::args</literal>, which is a list
	        of the arguments in this call.  To see multiple forms, use <literal>values</literal>:
	        <literal>:print-before (values (one-thing) (another-thing))</literal>.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:print-after <replaceable>form</replaceable></literal></term>
                <listitem><para> Evaluates <replaceable>form</replaceable> whenever the function being traced has
	        just exited, and prints the result after printing the standard exit message.  The form may
	        reference the lexical variable <literal>ccl::vals</literal>, which is a list of values
	        returned by this call. To see multiple forms, use <literal>values</literal>:
	        <literal>:print-after (values (one-thing) (another-thing))</literal>.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:print <replaceable>form</replaceable></literal></term>
                <listitem><para>Equivalent to <literal>:print-before <replaceable>form</replaceable> :print-after <replaceable>form</replaceable></literal>.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:eval-before <replaceable>form</replaceable></literal></term>
                <listitem><para>Evaluates <replaceable>form</replaceable> whenever the function being traced is
	        about to be entered.  The form may reference the lexical variable
	        <literal>ccl::args</literal>, which is a list of the arguments in this call.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:eval-after <replaceable>form</replaceable></literal></term>
                <listitem><para>Evaluates <replaceable>form</replaceable> whenever the function being has just
	        exited.  The form may reference the lexical variable <literal>ccl::vals</literal>, which
	        is a list of values returned by this call.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:eval <replaceable>form</replaceable></literal></term>
                <listitem><para>Equivalent to <literal>:eval-before <replaceable>form</replaceable>
	          :eval-after <replaceable>form</replaceable></literal>.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:break-before <replaceable>form</replaceable></literal></term>
                <listitem><para>Evaluates <replaceable>form</replaceable> whenever the function being traced is
	        about to be entered, and if the result is non-nil, enters a debugger break loop.  The form
	        may reference the lexical variable <literal>ccl::args</literal>, which is a list of the
	        arguments in this call.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:break-after <replaceable>form</replaceable></literal></term>
                <listitem><para>Evaluates <replaceable>form</replaceable> whenever the function being traced has
	        just exited, and if the result is non-nil, enters a debugger break loop. The form may
	        reference the lexical variable <literal>ccl::vals</literal>, which is a list of values
	        returned by this call.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:break <replaceable>form</replaceable></literal></term>
                <listitem><para>Equivalent to <literal>:break-before <replaceable>form</replaceable> :break-after <replaceable>form</replaceable></literal>.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:backtrace-before <replaceable>form</replaceable></literal>, <literal>:backtrace <replaceable>form</replaceable></literal></term>
                <listitem><para>Evaluates <replaceable>form</replaceable> whenever the function being traced is
	        about to be entered.  The form may reference the lexical variable
	        <literal>ccl::args</literal>, which is a list of the arguments in this call. The value
	        returned by <replaceable>form</replaceable> is intepreted as follows:
	      </para><blockquote><variablelist><varlistentry><term><literal>nil</literal></term><listitem><para>does nothing</para></listitem></varlistentry><varlistentry><term><literal>:detailed</literal></term><listitem><para>prints a detailed backtrace to
	              <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.</para></listitem></varlistentry><varlistentry><term><literal>(:detailed <replaceable>integer</replaceable>)</literal></term><listitem><para>prints the top <replaceable>integer</replaceable> frames of detailed
	              backtrace to <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.
	          </para></listitem></varlistentry><varlistentry><term><replaceable>integer</replaceable></term><listitem><para>prints top <replaceable>integer</replaceable> frames of a terse
	              backtrace to <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.
	          </para></listitem></varlistentry><varlistentry><term>anything else</term><listitem><para>prints a terse backtrace to <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.
	          </para></listitem></varlistentry></variablelist></blockquote><para>
	        Note that unlike with the other options, <literal>:backtrace</literal> is equivalent to
	        <literal>:backtrace-before</literal> only, not both before and after, since it's usually
	        not helpful to print the same backtrace both before and after the function call.
	      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:backtrace-after <replaceable>form</replaceable></literal></term>
                <listitem><para>Evaluates <replaceable>form</replaceable> whenever the function being traced has
	        just exited.  The form may reference the lexical variable <literal>ccl::vals</literal>,
	        which is a list of values returned by this call. The value returned by
	        <replaceable>form</replaceable> is intepreted as follows:
	      </para><blockquote><variablelist><varlistentry><term><literal>nil</literal></term><listitem><para>does nothing</para></listitem></varlistentry><varlistentry><term><literal>:detailed</literal></term><listitem><para>prints a detailed backtrace to
	              <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.</para></listitem></varlistentry><varlistentry><term><literal>(:detailed <replaceable>integer</replaceable>)</literal></term><listitem><para>prints the top <replaceable>integer</replaceable> frames of detailed
	              backtrace to <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.
	          </para></listitem></varlistentry><varlistentry><term><replaceable>integer</replaceable></term><listitem><para>prints top <replaceable>integer</replaceable> frames of a terse
	              backtrace to <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.
	          </para></listitem></varlistentry><varlistentry><term>anything else</term><listitem><para>prints a terse backtrace to <indexterm><primary><literal>*TRACE-OUTPUT*</literal></primary></indexterm><literal>*TRACE-OUTPUT*</literal>.
	          </para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:before</literal><replaceable>action</replaceable></term>
                <listitem><para>specifies the action to be taken just before the traced function is entered.  <replaceable>action</replaceable> is one of:</para><blockquote><variablelist><varlistentry><term><literal>:print</literal></term><listitem><para>The default, prints a short indented message showing the function name and the invocation arguments</para></listitem></varlistentry><varlistentry><term><literal>:break</literal></term><listitem><para>Equivalent to <literal>:before :print :break-before t</literal></para></listitem></varlistentry><varlistentry><term><literal>:backtrace</literal></term><listitem><para>Equivalent to <literal>:before :print :backtrace-before t</literal></para></listitem></varlistentry><varlistentry><term><replaceable>function</replaceable></term><listitem><para>
                  Any other value is interpreted as a function to call on entry instead of
                  printing the standard entry message.  It is called with its first
                  argument being the name of the function being traced, the remaining
                  arguments being all the arguments to the function being traced, and
                  <indexterm><primary><literal>*TRACE-LEVEL*</literal></primary></indexterm><link linkend="v_trace-level"><literal>*TRACE-LEVEL*</literal></link> bound to the current nesting level
                  of trace actions. </para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:after</literal><replaceable>action</replaceable></term>
                <listitem><para>specifies the action to be taken just after the traced function exits.  <replaceable>action</replaceable> is one of:</para><blockquote><variablelist><varlistentry><term><literal>:print</literal></term><listitem><para>The default, prints a short indented message showing the function name and the
	              returned values </para></listitem></varlistentry><varlistentry><term><literal>:break</literal></term><listitem><para>Equivalent to <literal>:after :print :break-after t</literal></para></listitem></varlistentry><varlistentry><term><literal>:backtrace</literal></term><listitem><para>Equivalent to <literal>:after :print :backtrace-after t</literal></para></listitem></varlistentry><varlistentry><term><replaceable>function</replaceable></term><listitem><para>Any other value is interpreted as a function to
	              call on exit instead of printing the standard exit
	              message.  It is called with its first argument being
	              the name of the function being traced, the
	              remaining arguments being all the values returned by the function
	              being traced, and ccl:*trace-level* bound to the current
	              nesting level of trace actions.
	            </para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
      </refentry>
      <refentry id="v_trace-level">
        <indexterm zone="v_trace-level"><primary><literal>*TRACE-LEVEL*</literal></primary></indexterm>
        <refnamediv>
          <refname>*TRACE-LEVEL*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:*TRACE-LEVEL*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_trace-level">
          <title>Description</title>
          <para>Variable bound to the current nesting level during execution of before and after trace actions.  The default printing actions use it to determine the amount of indentation.</para>
        </refsect1>
      </refentry>
      <refentry id="v_trace-max-indent">
        <indexterm zone="v_trace-max-indent"><primary><literal>*TRACE-MAX-INDENT*</literal></primary></indexterm>
        <refnamediv>
          <refname>*TRACE-MAX-INDENT*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:*TRACE-MAX-INDENT*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_trace-max-indent">
          <title>Description</title>
          <para>The default before and after print actions will not indent by more than the value of <indexterm><primary><literal>*TRACE-MAX-INDENT*</literal></primary></indexterm><link linkend="v_trace-max-indent"><literal>*TRACE-MAX-INDENT*</literal></link> regardless of the current trace level.</para>
        </refsect1>
      </refentry>
      <refentry id="f_trace-function">
        <indexterm zone="f_trace-function"><primary><literal>TRACE-FUNCTION</literal></primary></indexterm>
        <refnamediv>
          <refname>TRACE-FUNCTION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:TRACE-FUNCTION spec <literal>&amp;key</literal> { keyword value }*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_trace-function">
          <title>Description</title>
          <para>
      This is a functional version of the TRACE macro.  <replaceable>spec</replaceable> and
      <replaceable>keyword</replaceable>s are as for TRACE, except that all arguments are evaluated.
    </para>
        </refsect1>
      </refentry>
      <refentry id="v_trace-print-level">
        <indexterm zone="v_trace-print-level"><primary><literal>*TRACE-PRINT-LEVEL*</literal></primary></indexterm>
        <refnamediv>
          <refname>*TRACE-PRINT-LEVEL*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:*TRACE-PRINT-LEVEL*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_trace-print-level">
          <title>Description</title>
          <para>The default print actions bind <indexterm><primary><literal>*PRINT-LEVEL*</literal></primary></indexterm><literal>*PRINT-LEVEL*</literal> to this value while
      printing. Note that this rebinding is only in effect during the default entry and exit messages.
      It does not apply to printing of <literal>:print-before/:print-after</literal> forms or any
      explicit printing done by user code.</para>
        </refsect1>
      </refentry>
      <refentry id="v_trace-print-length">
        <indexterm zone="v_trace-print-length"><primary><literal>*TRACE-PRINT-LENGTH*</literal></primary></indexterm>
        <refnamediv>
          <refname>*TRACE-PRINT-LENGTH*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:*TRACE-PRINT-LENGTH*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_trace-print-length">
          <title>Description</title>
          <para>The default print actions bind <indexterm><primary><literal>*PRINT-LENGTH*</literal></primary></indexterm><literal>*PRINT-LENGTH*</literal> to this value while
      printing. Note that this rebinding is only in effect during the default entry and exit messages.
      It does not apply to printing of <literal>:print-before/:print-after</literal> forms or any
      explicit printing done by user code.</para>
        </refsect1>
      </refentry>
      <refentry id="v_trace-bar-frequency">
        <indexterm zone="v_trace-bar-frequency"><primary><literal>*TRACE-BAR-FREQUENCY*</literal></primary></indexterm>
        <refnamediv>
          <refname>*TRACE-BAR-FREQUENCY*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:*TRACE-BAR-FREQUENCY*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_trace-bar-frequency">
          <title>Description</title>
          <para>By default, this is nil. If non-nil it should be a integer,
    and the default entry and exit messages will print a | instead of
    space every this many levels of indentation.</para>
        </refsect1>
      </refentry>
    </section>
    <section id="advising">
      <title>Advising</title>
      <para>
    The <literal>advise</literal> macro can be thought of as a more
    general version of <literal>trace</literal>. It allows code that
    you specify to run before, after, or around a given function, for
    the purpose of changing the behavior of the function. Each piece
    of added code is called a piece of advice. Each piece of advice
    has a unique name, so that you can have multiple pieces of advice
    on the same function, including multiple
    <literal>:before</literal>, <literal>:after</literal>, and
    <literal>:around</literal> pieces of advice.</para>
      <para>    The <literal>:name</literal> and <literal>:when</literal>
    keywords serve to identify the piece of advice.  A later call to
    <literal>advise</literal> with the same values of
    <literal>:name</literal> and <literal>:when</literal> will replace
    the existing piece of advice; a call with different values will not.
  </para>
      <refentry id="m_advise">
        <indexterm zone="m_advise"><primary><literal>ADVISE</literal></primary></indexterm>
        <refnamediv>
          <refname>ADVISE</refname>
          <refpurpose>
	Add a piece of advice to the function or method specified by
	<parameter>spec</parameter> according to
	<parameter>form</parameter>.
      </refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>advise spec form <literal>&amp;key</literal> when name</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_advise">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>spec</parameter></term>
                <listitem><para>
	      A specification of the function on which to put the
	      advice.  This is either a symbol that is the name of a
	      function or generic function, or an expression of the
	      form (setf <replaceable>symbol</replaceable>), or a
	      specific method of a generic function in the form
	      (:method symbol {qualifiers} (specializer {specializer})).
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>form</parameter></term>
                <listitem><para>
	      A form to execute before, after, or around the advised
	      function. The form can refer to the variable arglist
	      that is bound to the arguments with which the advised
	      function was called. You can exit from form with
	      (return).
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>
	      A name that identifies the piece of advice.
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>when</parameter></term>
                <listitem><para>
	      An argument that specifies when the piece of advice is
	      run. There are three allowable values. The default is
	      <literal>:before</literal>, which specifies that form is
	      executed before the advised function is called. Other
	      possible values are <literal>:after</literal>, which
	      specifies that form is executed after the advised
	      function is called, and <literal>:around</literal>,
	      which specifies that form is executed around the call to
	      the advised function. Use <literal>(:do-it)</literal>
	      within form to indicate invocation of the original
	      definition.
	    </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="examples_in_m_advise">
          <title>Examples</title>
          <para>
	The function <literal>foo</literal>, already defined, does
	something with a list of numbers. The following code uses a
	piece of advice to make foo return zero if any of its
	arguments is not a number. Using :around advice, you can do
	the following:
	<programlisting>
(advise foo (if (some #'(lambda (n) (not (numberp n))) arglist)
	      0
	      (:do-it))
	:when :around :name :zero-if-not-nums)
	</programlisting></para>
          <para>
	To do the same thing using a :before piece of advice:
	<programlisting>
(advise foo (if (some #'(lambda (n) (not (numberp n))) arglist)
	      (return 0))
	:when :before :name :zero-if-not-nums)
	</programlisting></para>
        </refsect1>
      </refentry>
      <refentry id="m_unadvise">
        <indexterm zone="m_unadvise"><primary><literal>UNADVISE</literal></primary></indexterm>
        <refnamediv>
          <refname>UNADVISE</refname>
          <refpurpose>
	Remove the piece or pieces of advice matching <parameter>spec</parameter>,
	<parameter>when</parameter>, and <parameter>name</parameter>.
      </refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>unadvise spec <literal>&amp;key</literal> when name</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_m_unadvise">
          <title>Description</title>
          <para>
	The unadvise macro removes the piece or pieces of advice
	matching <literal>spec</literal>, <literal>when</literal>,
	and <literal>name</literal>. When the value of
	<literal>spec</literal> is t and the values of <literal>when</literal>
	and <literal>name</literal> are nil, unadvise
	removes every piece of advice; when <literal>spec</literal> is
	t, the argument <literal>when</literal> is nil, and
	<literal>name</literal> is non-nil, unadvise removes all
	pieces of advice with the given name.
      </para>
        </refsect1>
        <refsect1 id="arguments-and-values_in_m_unadvise">
          <title>Arguments and Values</title>
          <para>
	The arguments have the same meaning as in
	<indexterm><primary><literal>ADVISE</literal></primary></indexterm><link linkend="m_advise"><literal>ADVISE</literal></link>.
      </para>
        </refsect1>
      </refentry>
      <refentry id="m_advisedp">
        <indexterm zone="m_advisedp"><primary><literal>ADVISEDP</literal></primary></indexterm>
        <refnamediv>
          <refname>ADVISEDP</refname>
          <refpurpose>
	Return a list of the pieces of advice matching <parameter>spec</parameter>,
	<parameter>when</parameter>, and <parameter>name</parameter>.
      </refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>advisedp spec <literal>&amp;key</literal> when name</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_m_advisedp">
          <title>Description</title>
          <para>
	The advisedp macro returns a list of existing pieces of advice
	that match <literal>spec</literal>, <literal>when</literal>,
	and <literal>name</literal>. When the value of
	<literal>spec</literal> is t and the values of
	<literal>when</literal> and <literal>name</literal> are nil,
	advisedp returns all existing pieces of advice.
      </para>
        </refsect1>
        <refsect1 id="arguments-and-values_in_m_advisedp">
          <title>Arguments and Values</title>
          <para>
	The arguments have the same meaning as in
	<indexterm><primary><literal>ADVISE</literal></primary></indexterm><link linkend="m_advise"><literal>ADVISE</literal></link>.
      </para>
        </refsect1>
      </refentry>
    </section>
    <section id="directory">
      <title>Directory</title>
      <para>Clozure CL's <indexterm><primary><literal>DIRECTORY</literal></primary></indexterm><literal>DIRECTORY</literal> function accepts the following
implementation-dependent keyword arguments:</para>
      <blockquote>
        <variablelist>
          <varlistentry>
            <term><literal>:files</literal><replaceable>boolean</replaceable></term>
            <listitem><para> If true, includes regular (non-directory) files in DIRECTORY's output.  Defaults to T.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>:directories</literal><replaceable>boolean</replaceable></term>
            <listitem><para> If true, includes directories in DIRECTORY's output.  Defaults to NIL.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>:all</literal><replaceable>boolean</replaceable></term>
            <listitem><para> If true, includes files and directories whose names start with a dot character in DIRECTORY's output.  (Entries whose name is &quot;.&quot; or &quot;..&quot; are never included.) Defaults to T.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>:follow-links</literal><replaceable>boolean</replaceable></term>
            <listitem><para> If true, includes the TRUENAMEs of symbolic or hard links in DIRECTORY's output; if false, includes the link filenames without attempting to resolve them. Defaults to T.</para><para>Note that legacy HFS alias files are treated as plain files.</para></listitem>
          </varlistentry>
        </variablelist>
      </blockquote>
    </section>
    <section id="unicode">
      <title>Unicode</title>
      <para>All characters and strings in Clozure CL fully support Unicode by
    using UTF-32. There is only one <literal>CHARACTER</literal> type
    and one <literal>STRING</literal> type in Clozure CL.  There has been a
    lot of discussion about this decision which can be found by
    searching the openmcl-devel archives at <ulink url="http://clozure.com/pipermail/openmcl-devel/">http://clozure.com/pipermail/openmcl-devel/</ulink>.  Suffice it
    to say that we decided that the simplicity and speed advantages of
    only supporting UTF-32 outweigh the space disadvantage.</para>
      <section id="characters">
        <title>Characters</title>
        <para>There is one <literal>CHARACTER</literal> type in Clozure CL.
    All <literal>CHARACTER</literal>s are
    <literal>BASE-CHAR</literal>s.  <indexterm><primary><literal>CHAR-CODE-LIMIT</literal></primary></indexterm><literal>CHAR-CODE-LIMIT</literal>
    is now <literal>#x110000</literal>, which means that all Unicode
    characters can be directly represented.  As of Unicode 5.0, only
    about 100,000 of 1,114,112 possible <literal>CHAR-CODE</literal>s
    are actually defined. The function <indexterm><primary><literal>CODE-CHAR</literal></primary></indexterm><literal>CODE-CHAR</literal>
    knows that certain ranges of code values (notably
    <literal>#xd800</literal>-<literal>#xddff</literal>) will never be
    valid character codes and will return <literal>NIL</literal> for
    arguments in that range, but may return a
    non-<literal>NIL</literal> value (an undefined/non-standard
    <literal>CHARACTER</literal> object) for other unassigned code
    values.</para>
        <para>    Clozure CL supports character names of the form
    <literal>u+xxxx</literal>-where <literal>x</literal> is a
    sequence of one or more hex digits.  The value of the hex digits
    denotes the code of the character.  The <literal>+</literal>
    character is optional, so <literal>#\u+0020</literal>,
    <literal>#\U0020</literal>, and <literal>#\U+20</literal> all
    refer to the <literal>#\Space</literal> character.</para>
        <para>    Characters with codes in the range
    <literal>#xa0</literal>-<literal>#x7ff</literal> also have
    symbolic names These are the names from the Unicode standard with
    spaces replaced by underscores.  So
    <literal>#\Greek_Capital_Letter_Epsilon</literal> can be used to
    refer to the character whose <indexterm><primary><literal>CHAR-CODE</literal></primary></indexterm><literal>CHAR-CODE</literal> is
    <literal>#x395</literal>.  To see the complete list of supported
    character names, look just below the definition for
    <indexterm><primary><literal>CCL::REGISTER-CHARACTER-NAME</literal></primary></indexterm><literal>CCL::REGISTER-CHARACTER-NAME</literal> in
    <literal>ccl:level-1;l1-reader.lisp</literal>.</para>
      </section>
      <section id="external-formats">
        <title>External Formats</title>
        <para><indexterm><primary><literal>OPEN</literal></primary></indexterm><literal>OPEN</literal>, <indexterm><primary><literal>LOAD</literal></primary></indexterm><literal>LOAD</literal>, and
    <indexterm><primary><literal>COMPILE-FILE</literal></primary></indexterm><literal>COMPILE-FILE</literal> all take an
    <literal>:EXTERNAL-FORMAT</literal> keyword argument.  The value
    of <literal>:EXTERNAL-FORMAT</literal> can be
    <literal>:DEFAULT</literal> (the default value), a line
    termination keyword (see <xref linkend="line-termination-keywords"/>), a character encoding
    keyword (see <xref linkend="character-encodings"/>), an
    external-format object created using
    <indexterm><primary><literal>MAKE-EXTERNAL-FORMAT</literal></primary></indexterm><link linkend="f_make-external-format"><literal>MAKE-EXTERNAL-FORMAT</literal></link> (see <indexterm><primary><literal>MAKE-EXTERNAL-FORMAT</literal></primary></indexterm><link linkend="f_make-external-format"><literal>MAKE-EXTERNAL-FORMAT</literal></link>), or a plist with keys:
    <literal>:DOMAIN</literal>, <literal>:CHARACTER-ENCODING</literal>
    and <literal>:LINE-TERMINATION</literal>.  If
    <parameter>argument</parameter> is a plist, the result of
    <literal>(APPLY #'MAKE-EXTERNAL-FORMAT
    <parameter>argument</parameter>)</literal> will be used.</para>
        <para>If <literal>:DEFAULT</literal> is specified, then the value
    of <indexterm><primary><literal>*DEFAULT-EXTERNAL-FORMAT*</literal></primary></indexterm><link linkend="v_default-external-format"><literal>*DEFAULT-EXTERNAL-FORMAT*</literal></link> is used.  If
    no line-termination is specified, then the value of
    <indexterm><primary><literal>*DEFAULT-LINE-TERMINATION*</literal></primary></indexterm><link linkend="v_default-line-termination"><literal>*DEFAULT-LINE-TERMINATION*</literal></link> is used, which
    defaults to <literal>:UNIX</literal>.  If no character encoding is
    specified, then
    <indexterm><primary><literal>*DEFAULT-FILE-CHARACTER-ENCODING*</literal></primary></indexterm><literal>*DEFAULT-FILE-CHARACTER-ENCODING*</literal> is used
    for file streams and
    <indexterm><primary><literal>*DEFAULT-SOCKET-CHARACTER-ENCODING*</literal></primary></indexterm><literal>*DEFAULT-SOCKET-CHARACTER-ENCODING*</literal> is used
    for socket streams.  The default, default character encoding is
    <literal>NIL</literal> which is a synonym for
    <literal>:ISO-8859-1</literal>.</para>
        <para>    Note that the set of keywords used to denote
    CHARACTER-ENCODINGs and the set of keywords used to denote
    line-termination conventions is disjoint: a keyword denotes at
    most a character encoding or a line termination convention, but
    never both.</para>
        <para>    EXTERNAL-FORMATs are objects (structures) with two
    read-only fields that can be accessed via the functions:
    <indexterm><primary><literal>EXTERNAL-FORMAT-LINE-TERMINATION</literal></primary></indexterm><literal>EXTERNAL-FORMAT-LINE-TERMINATION</literal> and
    <indexterm><primary><literal>EXTERNAL-FORMAT-CHARACTER-ENCODING</literal></primary></indexterm><literal>EXTERNAL-FORMAT-CHARACTER-ENCODING</literal>.</para>
        <refentry id="v_default-external-format">
          <indexterm zone="v_default-external-format"><primary><literal>*DEFAULT-EXTERNAL-FORMAT*</literal></primary></indexterm>
          <refnamediv>
            <refname>*DEFAULT-EXTERNAL-FORMAT*</refname>
            <refpurpose/>
            <refclass>Variable</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>CCL:*DEFAULT-EXTERNAL-FORMAT*</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_v_default-external-format">
            <title>Description</title>
            <para>The value of this variable is used when :EXTERNAL-FORMAT is
	        unspecified or specified as :DEFAULT. It can
	        meaningfully be given any value that can be used as an
                external-format (except for the value :DEFAULT.)</para>
            <para>	        The initial value of this variable
	        in Clozure CL is <literal>:UNIX</literal>, which is equivalent to
                <literal>(:LINE-TERMINATION :UNIX)</literal>, among other
                things.  </para>
          </refsect1>
        </refentry>
        <refentry id="v_default-line-termination">
          <indexterm zone="v_default-line-termination"><primary><literal>*DEFAULT-LINE-TERMINATION*</literal></primary></indexterm>
          <refnamediv>
            <refname>*DEFAULT-LINE-TERMINATION*</refname>
            <refpurpose/>
            <refclass>Variable</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>CCL:*DEFAULT-LINE-TERMINATION*</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_v_default-line-termination">
            <title>Description</title>
            <para>The value of this variable is used when an external-format
                doesn't specify a line-termination convention (or specifies
                it as :DEFAULT.) It can meaningfully be given any value 
                that can be used as a line termination keyword 
                (see <xref linkend="line-termination-keywords"/>).</para>
            <para>	        The initial value of this variable
	        in Clozure CL is <literal>:UNIX</literal>.
          </para>
          </refsect1>
        </refentry>
        <refentry id="f_make-external-format">
          <indexterm zone="f_make-external-format"><primary><literal>MAKE-EXTERNAL-FORMAT</literal></primary></indexterm>
          <refnamediv>
            <refname>MAKE-EXTERNAL-FORMAT</refname>
            <refpurpose>Either creates a new external format object, or
	return an existing one with the same specified slot
	values.</refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>make-external-format <literal>&amp;key</literal> domain character-encoding line-termination =&gt; external-format</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_make-external-format">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>domain</parameter></term>
                  <listitem><para>This is used to indicate where the external
	      format is to be used.  Its value can be almost
	      anything.  It defaults to <literal>NIL</literal>.
	      There are two domains that have a pre-defined meaning in
	      Clozure CL: <literal>:FILE</literal> indicates
	      encoding for a file in the file system and
	      <literal>:SOCKET</literal> indicates i/o to/from a
	      socket.  The value of <parameter>domain</parameter>
	      affects the default values for
	      <parameter>character-encoding</parameter> and
	      <parameter>line-termination</parameter>.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>character-encoding</parameter></term>
                  <listitem><para>A keyword that specifies the character encoding
	      for the external format. <xref linkend="character-encodings"/>.  Defaults to
	      <literal>:DEFAULT</literal> which means if
	      <parameter>domain</parameter> is
	      <literal>:FILE</literal> use the value of the variable
	      <indexterm><primary><literal>*DEFAULT-FILE-CHARACTER-ENCODING*</literal></primary></indexterm><literal>*DEFAULT-FILE-CHARACTER-ENCODING*</literal>
	      and if <parameter>domain</parameter> is
	      <literal>:SOCKET</literal>, use the value of the
	      variable
	      <indexterm><primary><literal>*DEFAULT-SOCKET-CHARACTER-ENCODING*</literal></primary></indexterm><literal>*DEFAULT-SOCKET-CHARACTER-ENCODING*</literal>.
	      The initial value of both of these variables is
	      <literal>NIL</literal>, which means the
	      <literal>:ISO-8859-1</literal> encoding.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>line-termination</parameter></term>
                  <listitem><para>A keyword that indicates a line termination
	      keyword <xref linkend="line-termination-keywords"/>.
	      Defaults to <literal>:DEFAULT</literal> which means
	      use the value of the variable
	      <indexterm><primary><literal>*DEFAULT-LINE-TERMINATION*</literal></primary></indexterm><link linkend="v_default-line-termination"><literal>*DEFAULT-LINE-TERMINATION*</literal></link>.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>external-format</parameter></term>
                  <listitem><para>An external-format object as described above.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_make-external-format">
            <title>Description</title>
            <para>Despite the function's name, it doesn't necessarily create a
	new, unique EXTERNAL-FORMAT object: two calls to
	MAKE-EXTERNAL-FORMAT with the same arguments made in the same
	dynamic environment return the same (eq) object.
	</para>
          </refsect1>
        </refentry>
      </section>
      <section id="line-termination-keywords">
        <title>Line Termination Keywords</title>
        <para>Line termination keywords indicate which characters are used
  to indicate the end of a line.  On input, the external line
  termination characters are replaced by <literal>#\Newline</literal>
  and on output, <literal>#\Newline</literal>s are converted to the
  external line termination characters.</para>
        <table id="tab_line-termination-keywords">
          <title>Line Termination Keywords</title>
          <tgroup cols="2">
            <thead><row><entry>keyword</entry><entry>character(s)</entry></row></thead>
            <tbody>
              <row>
                <entry><literal>:UNIX</literal></entry>
                <entry><literal>#\Linefeed</literal></entry>
              </row>
              <row>
                <entry><literal>:MACOS</literal></entry>
                <entry><literal>#\Return</literal></entry>
              </row>
              <row>
                <entry><literal>:CR</literal></entry>
                <entry><literal>#\Return</literal></entry>
              </row>
              <row>
                <entry><literal>:CRLF</literal></entry>
                <entry><literal>#\Return #\Linefeed</literal></entry>
              </row>
              <row>
                <entry><literal>:CP/M</literal></entry>
                <entry><literal>#\Return #\Linefeed</literal></entry>
              </row>
              <row>
                <entry><literal>:MSDOS</literal></entry>
                <entry><literal>#\Return #\Linefeed</literal></entry>
              </row>
              <row>
                <entry><literal>:DOS</literal></entry>
                <entry><literal>#\Return #\Linefeed</literal></entry>
              </row>
              <row>
                <entry><literal>:WINDOWS</literal></entry>
                <entry><literal>#\Return #\Linefeed</literal></entry>
              </row>
              <row>
                <entry><literal>:INFERRED</literal></entry>
                <entry>see below</entry>
              </row>
              <row>
                <entry><literal>:UNICODE</literal></entry>
                <entry><literal>#\Line_Separator</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para><literal>:INFERRED</literal> means that a stream's
  line-termination convention is determined by looking at the contents
  of a file.  It is only useful for <literal>FILE-STREAM</literal>s
  that're open for <literal>:INPUT</literal> or
  <literal>:IO</literal>.  The first buffer full of data is examined,
  and if a <literal>#\Return</literal> character occurs before any
  <literal>#\Linefeed</literal> character, then the line termination
  type is set to <literal>:WINDOWS</literal> if that
  <literal>#\Return</literal> character is immediately followed by a
  <literal>#\Linefeed</literal> character and to <literal>:MACOS</literal>
  otherwise.  If a <literal>#\Return</literal> character isn't found in
  the buffer or if <literal>#\Return</literal> is preceded by
  <literal>#\Linefeed</literal>, the file's line terminationt type
  is set to <literal>:UNIX</literal>.</para>
      </section>
      <section id="character-encodings">
        <title>Character Encodings</title>
        <para>Internally, all characters and strings in Clozure CL are in
    UTF-32.  Externally, files or socket streams may encode characters
    in a wide variety of ways.  The International Organization for
    Standardization, widely known as ISO, defines many of these
    character encodings.  Clozure CL implements some of these encodings as
    detailed below.  These encodings are part of the specification of
    external formats <xref linkend="external-formats"/>.  When reading
    from a stream, characters are converted from the specified
    external character encoding to UTF-32.  When writing to a stream,
    characters are converted from UTF-32 to the specified character
    encoding.</para>
        <para>    Internally, CHARACTER-ENCODINGs are objects (structures)
    that are named by character encoding keywords (:ISO-8859-1,
    :UTF-8, etc.).  The structures contain attributes of the encoding
    and functions used to encode/decode external data, but unless
    you're trying to define or debug an encoding there's little reason
    to know much about the CHARACTER-ENCODING objects and it's usually
    preferable to refer to a character encoding by its name.</para>
        <para>    </para>
        <section id="encoding-problems">
          <title>Encoding Problems</title>
          <para>On output to streams with character encodings that can
      encode the full range of Unicode-and on input from any
      stream-&quot;unencodable characters&quot; are represented using the
      Unicode #\Replacement_Character (= #\U+fffd); the presence of
      such a character usually indicates that something got lost in
      translation.  Either data wasn't encoded properly or there was a
      bug in the decoding process.</para>
        </section>
        <section id="byte-order-marks">
          <title>Byte Order Marks</title>
          <para>The endianness of a character encoding is sometimes
      explicit, and sometimes not.  For example,
      <literal>:UTF-16BE</literal> indicates big-endian, but
      <literal>:UTF-16</literal> does not specify endianness.  A byte
      order mark is a special character that may appear at the
      beginning of a stream of encoded characters to specify the
      endianness of a multi-byte character encoding.  (It may also be
      used with UTF-8 character encodings, where it is simply used to
      indicate that the encoding is UTF-8.)</para>
          <para>      Clozure CL writes a byte order mark as the first character
      of a file or socket stream when the endianness of the character
      encoding is not explicit.  Clozure CL also expects a byte order
      mark on input from streams where the endianness is not
      explicit. If a byte order mark is missing from input data, that
      data is assumed to be in big-endian order.</para>
          <para>      A byte order mark from a UTF-8 encoded input stream is not
      treated specially and just appears as a normal character from
      the input stream.  It is probably a good idea to skip over this
      character.</para>
        </section>
        <section id="describe-character-encodings">
          <title>DESCRIBE-CHARACTER-ENCODINGS</title>
          <para>The set of character encodings supported by Clozure CL can be
    retrieved by calling
    <indexterm><primary><literal>DESCRIBE-CHARACTER-ENCODINGS</literal></primary></indexterm><link linkend="f_describe-character-encodings"><literal>DESCRIBE-CHARACTER-ENCODINGS</literal></link>.</para>
          <refentry id="f_describe-character-encodings">
            <indexterm zone="f_describe-character-encodings"><primary><literal>DESCRIBE-CHARACTER-ENCODINGS</literal></primary></indexterm>
            <refnamediv>
              <refname>DESCRIBE-CHARACTER-ENCODINGS</refname>
              <refpurpose>Writes descriptions of defined character
	  encodings to <indexterm><primary><literal>*TERMINAL-IO*</literal></primary></indexterm><literal>*TERMINAL-IO*</literal>.</refpurpose>
              <refclass>Function</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>describe-character-encodings</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_f_describe-character-encodings">
              <title>Description</title>
              <para>Writes descriptions of all defined character encodings
	  to <indexterm><primary><literal>*TERMINAL-IO*</literal></primary></indexterm><literal>*TERMINAL-IO*</literal>.  These descriptions
	  include the names of the encoding's aliases and a doc string
	  which briefly describes each encoding's properties and
	  intended use.</para>
            </refsect1>
            <refsect1 id="see-also_in_f_describe-character-encodings">
              <title>See Also</title>
              <para><xref linkend="character-encodings"/>, <xref linkend="external-formats"/>, <xref linkend="supported-character-encodings"/></para>
            </refsect1>
          </refentry>
        </section>
        <section id="supported-character-encodings">
          <title>Supported Character Encodings</title>
          <para>The list of supported encodings is reproduced here.  Most
     encodings have aliases, e.g. the encoding named
     <literal>:ISO-8859-1</literal> can also be referred to by the
     names <literal>:LATIN1</literal> and <literal>:IBM819</literal>,
     among others.  Where possible, the keywordized name of an
     encoding is equivalent to the preferred MIME charset name (and
     the aliases are all registered IANA charset names.)</para>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><literal>:ISO-8859-1</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which all character codes map to their Unicode
       equivalents. Intended to support most characters used in most
       Western European languages.</para><para>       Clozure CL uses ISO-8859-1 encoding for
       <indexterm><primary><literal>*TERMINAL-IO*</literal></primary></indexterm><literal>*TERMINAL-IO*</literal> and for all streams whose
       EXTERNAL-FORMAT isn't explicitly specified.  The default for
       <indexterm><primary><literal>*TERMINAL-IO*</literal></primary></indexterm><literal>*TERMINAL-IO*</literal> can be set via the
       <literal>-K</literal> command-line argument (see <xref linkend="command-line-options"/>).</para><para>       ISO-8859-1 just covers the first 256 Unicode code
       points, where the first 128 code points are equivalent to
       US-ASCII.  That should be pretty much equivalent to what
       earliers versions of Clozure CL did that only supported 8-bit characters,
       but it may not be optimal for users working in a particular
       locale.</para><para>       Aliases: <literal>:ISO_8859-1, :LATIN1, :L1,
       :IBM819, :CP819, :CSISOLATIN1</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-2</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in most languages used in
       Central/Eastern Europe.</para><para>       Aliases: <literal>:ISO_8859-2, :LATIN2, :L2,
       :CSISOLATIN2</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-3</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in most languages used in
       Southern Europe.</para><para>       Aliases: <literal>:ISO_8859-3, :LATIN3 :L3,
       :CSISOLATIN3</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-4</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in most languages used in
       Northern Europe.</para><para>Aliases: <literal>:ISO_8859-4, :LATIN4, :L4, :CSISOLATIN4</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-5</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in the Cyrillic
       alphabet.</para><para>       Aliases: <literal>:ISO_8859-5, :CYRILLIC, :CSISOLATINCYRILLIC,
       :ISO-IR-144</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-6</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in the Arabic
       alphabet.</para><para>       Aliases: <literal>:ISO_8859-6, :ARABIC, :CSISOLATINARABIC,
       :ISO-IR-127</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-7</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in the Greek
       alphabet.</para><para>       Aliases: <literal>:ISO_8859-7, :GREEK, :GREEK8, :CSISOLATINGREEK,
       :ISO-IR-126, :ELOT_928, :ECMA-118</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-8</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in the Hebrew
       alphabet.</para><para>       Aliases: <literal>:ISO_8859-8, :HEBREW, :CSISOLATINHEBREW,
       :ISO-IR-138</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-9</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#xcf map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in the Turkish
       alphabet.</para><para>       Aliases: <literal>:ISO_8859-9, :LATIN5, :CSISOLATIN5,
       :ISO-IR-148</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-10</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in Nordic
       alphabets.</para><para>       Aliases: <literal>:ISO_8859-10, :LATIN6, :CSISOLATIN6,
       :ISO-IR-157</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-11</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found the Thai
       alphabet.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-13</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in Baltic
       alphabets.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-14</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in Celtic
       languages.</para><para>       Aliases: <literal>:ISO_8859-14, :ISO-IR-199, :LATIN8, :L8,
       :ISO-CELTIC</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-15</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in Western European languages
       (including the Euro sign and some other characters missing from
       ISO-8859-1.</para><para>Aliases: <literal>:ISO_8859-15, :LATIN9</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ISO-8859-16</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x9f map to their Unicode equivalents and
       other codes map to other Unicode character values.  Intended to
       provide most characters found in Southeast European
       languages.</para><para>       Aliases: <literal>:ISO_8859-16, :ISO-IR-199, :LATIN8, :L8,
       :ISO-CELTIC</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:MACINTOSH</literal></term>
                <listitem><para>An 8-bit, fixed-width character encoding in
       which codes #x00-#x7f map to their Unicode equivalents and
       other codes map to other Unicode character values.
       Traditionally used on Classic MacOS to encode characters used
       in western languages.</para><para>       Aliases: <literal>:MACOS-ROMAN, :MACOSROMAN, :MAC-ROMAN,
       :MACROMAN</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UCS-2</literal></term>
                <listitem><para>A 16-bit, fixed-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit word.  The endianness of the encoded data is
       indicated by the endianness of a byte-order-mark character
       (#u+feff) prepended to the data; in the absence of such a
       character on input, the data is assumed to be in big-endian
       order.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UCS-2BE</literal></term>
                <listitem><para>A 16-bit, fixed-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit big-endian word. The encoded data is implicitly
       big-endian; byte-order-mark characters are not interpreted on
       input or prepended to output.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UCS-2LE</literal></term>
                <listitem><para>A 16-bit, fixed-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit little-endian word. The encoded data is
       implicitly little-endian; byte-order-mark characters are not
       interpreted on input or prepended to output.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:US-ASCII</literal></term>
                <listitem><para>An 7-bit, fixed-width character encoding in
       which all character codes map to their Unicode
       equivalents. </para><para>       Aliases: <literal>:CSASCII, :CP637, :IBM637, :US,
       :ISO646-US, :ASCII, :ISO-IR-6</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-16</literal></term>
                <listitem><para>A 16-bit, variable-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit word and characters with larger codes can be
       encoded in a pair of 16-bit words.  The endianness of the
       encoded data is indicated by the endianness of a
       byte-order-mark character (#u+feff) prepended to the data; in
       the absence of such a character on input, the data is assumed
       to be in big-endian order. Output is written in native
       byte-order with a leading byte-order mark.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-16BE</literal></term>
                <listitem><para>A 16-bit, variable-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit big-endian word and characters with larger
       codes can be encoded in a pair of 16-bit big-endian words.  The
       endianness of the encoded data is implicit in the encoding;
       byte-order-mark characters are not interpreted on input or
       prepended to output.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-16LE</literal></term>
                <listitem><para>A 16-bit, variable-length encoding in which
       characters with CHAR-CODEs less than #x10000 can be encoded in
       a single 16-bit little-endian word and characters with larger
       codes can be encoded in a pair of 16-bit little-endian words.
       The endianness of the encoded data is implicit in the encoding;
       byte-order-mark characters are not interpreted on input or
       prepended to output.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-32</literal></term>
                <listitem><para>A 32-bit, fixed-length encoding in which all
       Unicode characters can be encoded in a single 32-bit word.  The
       endianness of the encoded data is indicated by the endianness
       of a byte-order-mark character (#u+feff) prepended to the data;
       in the absence of such a character on input, input data is
       assumed to be in big-endian order.  Output is written in native
       byte order with a leading byte-order mark.</para><para>Alias: <literal>:UTF-4</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-32BE</literal></term>
                <listitem><para>A 32-bit, fixed-length encoding in which all
       Unicode characters encoded in a single 32-bit word. The encoded
       data is implicitly big-endian; byte-order-mark characters are
       not interpreted on input or prepended to
       output.</para><para>Alias: <literal>:UCS-4BE</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-8</literal></term>
                <listitem><para>An 8-bit, variable-length character encoding in
       which characters with CHAR-CODEs in the range #x00-#x7f can be
       encoded in a single octet; characters with larger code values
       can be encoded in 2 to 4 bytes.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UTF-32LE</literal></term>
                <listitem><para>A 32-bit, fixed-length encoding in which all
       Unicode characters can encoded in a single 32-bit word. The
       encoded data is implicitly little-endian; byte-order-mark
       characters are not interpreted on input or prepended to
       output.</para><para>Alias: <literal>:UCS-4LE</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:Windows-31j</literal></term>
                <listitem><para>An 8-bit, variable-length character encoding in
     which character code points in the range #x00-#x7f can be encoded
     in a single octet; characters with larger code values can be
     encoded in 2 bytes.</para><para>Aliases: <literal>:CP932, :CSWINDOWS31J</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:EUC-JP</literal></term>
                <listitem><para>An 8-bit, variable-length character encoding in
     which character code points in the range #x00-#x7f can be encoded
     in a single octet; characters with larger code values can be
     encoded in 2 bytes.</para><para>Alias: <literal>:EUCJP</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:GB2312</literal></term>
                <listitem><para>An 8-bit, variable-length character encoding in which
     character code points in the range #x00-#x80 can be encoded in a
     single octet; characters with larger code values can be encoded
     in 2 bytes.</para><para>Alias: <literal>:GB2312-80 :GB2312-1980 :EUC-CN :EUCCN</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:CP936</literal></term>
                <listitem><para>An 8-bit, variable-length character encoding in which
     character code points in the range #x00-#x80 can be encoded in a
     single octet; characters with larger code values can be encoded
     in 2 bytes.</para><para>Alias: <literal>:GBK :MS936 :WINDOWS-936</literal></para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="encoding-and-decoding-strings">
          <title>Encoding and Decoding Strings</title>
          <para>Clozure CL provides functions to encode and decode strings
to and from vectors of type (simple-array (unsigned-byte 8)).</para>
          <refentry id="f_count-characters-in-octet-vector">
            <indexterm zone="f_count-characters-in-octet-vector"><primary><literal>COUNT-CHARACTERS-IN-OCTET-VECTOR</literal></primary></indexterm>
            <refnamediv>
              <refname>COUNT-CHARACTERS-IN-OCTET-VECTOR</refname>
              <refpurpose/>
              <refclass>Function</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>count-characters-in-octet-vector vector <literal>&amp;key</literal> start end external-format</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_f_count-characters-in-octet-vector">
              <title>Description</title>
              <para>
    Returns the number of characters that would be produced by
    decoding <parameter>vector</parameter> (or the subsequence thereof
    delimited by <parameter>start</parameter> and <parameter>end</parameter>)
    according to <parameter>external-format</parameter>.
  </para>
            </refsect1>
          </refentry>
          <refentry id="f_decode-string-from-octets">
            <indexterm zone="f_decode-string-from-octets"><primary><literal>DECODE-STRING-FROM-OCTETS</literal></primary></indexterm>
            <refnamediv>
              <refname>DECODE-STRING-FROM-OCTETS</refname>
              <refpurpose/>
              <refclass>Function</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>decode-string-from-octets vector <literal>&amp;key</literal> start end external-format string</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_f_decode-string-from-octets">
              <title>Description</title>
              <para>
    Decodes the octets in <parameter>vector</parameter> (or the subsequence
    of it delimited by <parameter>start</parameter> and
    <parameter>end</parameter>) into a string according
    to <parameter>external-format</parameter>.</para>
              <para>    If <parameter>string</parameter> is supplied, output will be written into it.
    It must be large enough to hold the decoded characters.  If <parameter>string</parameter> is not supplied, a new string will be allocated to
    hold the decoded characters.</para>
              <para>    Returns, as multiple values, the decoded string and the position in
    <parameter>vector</parameter> where the decoding ended.</para>
              <para>    Sequences of octets in <parameter>vector</parameter> that cannot be
    decoded into characters according to
    <parameter>external-format</parameter> will be decoded as
    #\Replacement_Character.
  </para>
            </refsect1>
          </refentry>
          <refentry id="f_encode-string-to-octets">
            <indexterm zone="f_encode-string-to-octets"><primary><literal>ENCODE-STRING-TO-OCTETS</literal></primary></indexterm>
            <refnamediv>
              <refname>ENCODE-STRING-TO-OCTETS</refname>
              <refpurpose/>
              <refclass>Function</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>encode-string-to-octets string <literal>&amp;key</literal> start end external-format use-byte-order-mark vector vector-offset</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_f_encode-string-to-octets">
              <title>Description</title>
              <para>
    Encodes <parameter>string</parameter> (or the substring delimited by
    <parameter>start</parameter> and <parameter>end</parameter>)
    into <parameter>external-format</parameter> and returns, as multiple
    values, a vector of octets containing the encoded data and an integer
    that specifies the offset into the vector where the encoded data ends.</para>
              <para>    When <parameter>use-byte-order-mark</parameter> is true, a byte-order mark
    will be included in the encoded data.</para>
              <para>    If <parameter>vector</parameter> is supplied, output will be written
    to it.  It must be of type (simple-array (unsigned-byte 8)) and be
    large enough to hold the encoded data.  If it is not supplied, the function
    will allocate a new vector.</para>
              <para>    If <parameter>vector-offset</parameter> is supplied, data will be written
    into the output vector starting at that offset.</para>
              <para>    Characters in <parameter>string</parameter> that cannot be encoded
    into <parameter>external-format</parameter> will be replaced with an
    encoding-dependent replacement character
    (#\Replacement_Character or #\Sub) before being encoded and written
    into the output vector.
  </para>
            </refsect1>
          </refentry>
          <refentry id="f_string-size-in-octets">
            <indexterm zone="f_string-size-in-octets"><primary><literal>STRING-SIZE-IN-OCTETS</literal></primary></indexterm>
            <refnamediv>
              <refname>STRING-SIZE-IN-OCTETS</refname>
              <refpurpose/>
              <refclass>Function</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>string-size-in-octets string <literal>&amp;key</literal> start end external-format use-byte-order-mark</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_f_string-size-in-octets">
              <title>Description</title>
              <para>
    Returns the number of octets required to encode
    <parameter>string</parameter> (or the substring delimited by
    <parameter>start</parameter> and <parameter>end</parameter>) into
    <parameter>external-format</parameter>.</para>
              <para>    When <parameter>use-byte-order-mark</parameter> is true, the returned
    size will include space for a byte-order marker.
  </para>
            </refsect1>
          </refentry>
        </section>
      </section>
    </section>
    <section id="pathnames">
      <title>Pathnames</title>
      <section id="pathname-expansion">
        <title>Pathname Expansion</title>
        <para>Leading tilde (~) characters in physical pathname namestrings
        are expanded in the way that most shells do:</para>
        <para>        <literal>&quot;~user/...&quot;</literal> can be used to refer to an absolute pathname rooted
        at the home directory of the user named &quot;user&quot;.</para>
        <para>        <literal>&quot;~/...&quot;</literal> can be used to refer to an absolute pathname rooted at
        the home directory of the current user.</para>
      </section>
      <section id="predefined-logical-hosts">
        <title>Predefined Logical Hosts</title>
        <para>Clozure CL sets up logical pathname translations for logical hosts:  <literal>ccl</literal> and <literal>home</literal></para>
        <para>        The <code>CCL</code> logical host should point to the
        <code>ccl</code> directory.  It is used for a variety of
        purposes by Clozure CL including: locating Clozure CL source code,
        <literal>require</literal> and <literal>provide</literal>, accessing
        foreign function information, and the Clozure CL build process. It
        is set to the value of the environment variable
        <code>CCL_DEFAULT_DIRECTORY</code>, which is set by the
        openmcl shell script <xref linkend="the-ccl-shell-script"/>.  If
        <code>CCL_DEFAULT_DIRECTORY</code> is not set, then it is set
        to the directory containing the current heap image.</para>
      </section>
      <section id="pathname-namestrings">
        <title>Pathname Namestrings</title>
        <para>
	The syntax of namestrings is implementation-defined in Common Lisp.
	Portable programs cannot assume much of anything about them.  (See
	section 19.1.1 of the Common Lisp standard for more information.)</para>
        <para>	When translating a namestring into a pathname object, most
	implementations seem to follow the convention that a dot
	character in the namestring separates the
	<literal>pathname-name</literal> and
	the <literal>pathname-type</literal>.  When there is more
	than one dot in involved, or when dots appear at the beginning
	or end of the namestrings, what to do is less clear: does
	&quot;.emacs&quot; describe a pathname whose name is
	<literal>nil</literal> and whose type is <literal>emacs</literal>
	or something else?  Similarly, given &quot;a.b.c&quot;, the question
	is which parts are parsed as the pathname name, and which are
	parsed as the pathname type?</para>
        <para>	When generating a namestring from a pathname object (as happens,
	for example, when printing a pathname), Clozure CL
	tries to avoid some potential ambiguity by escaping characters
	that might otherwise be used to separate pathname components.
	The character used to quote or escape the separators is a
	backlash on Unix systems, and a #\&gt; character on Windows.
	So, for example, &quot;a\\.b.c&quot;
	has name &quot;a.b&quot; and type &quot;c&quot;, whereas &quot;a.b\\.c&quot; has name
	&quot;a&quot; and type &quot;b.c&quot;.</para>
        <para>	To get a native namestring suitable for passing to an
	operating system command, use the function
	<literal>ccl:native-translated-namestring</literal>.
      </para>
        <section id="working-with-native-namestrings">
          <title>Working with native namestrings</title>
          <refentry id="f_native-translated-namestring">
            <indexterm zone="f_native-translated-namestring"><primary><literal>NATIVE-TRANSLATED-NAMESTRING</literal></primary></indexterm>
            <refnamediv>
              <refname>NATIVE-TRANSLATED-NAMESTRING</refname>
              <refpurpose>
	    Return a namestring that uses the conventions of the
	    native operating system.
	  </refpurpose>
              <refclass>Function</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>native-translated-namestring pathname-designator</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_f_native-translated-namestring">
              <title>Description</title>
              <para>
	  This function returns a namestring that represents a pathname
	  using the native conventions of the operating system.
	  Any quoting or escaping of special characters will be removed.</para>
              <para>	  For example, suppose that <parameter>p</parameter> is a pathname made
	  by <literal>(make-pathname :name &quot;a.b&quot; :type &quot;c&quot;)</literal>.
	  Then, <literal>(native-translated-namestring p)</literal> evaluates
	  to &quot;a.b.c&quot;.  By contrast, <literal>(namestring p)</literal> evaluates
	  to &quot;a\\.b.c&quot;.
	</para>
            </refsect1>
          </refentry>
          <refentry id="m_with-filename-cstrs">
            <indexterm zone="m_with-filename-cstrs"><primary><literal>WITH-FILENAME-CSTRS</literal></primary></indexterm>
            <refnamediv>
              <refname>WITH-FILENAME-CSTRS</refname>
              <refpurpose>
	    Suitably encode strings to be used as filenames for foreign code.
	  </refpurpose>
              <refclass>Macro</refclass>
            </refnamediv>
            <refsynopsisdiv><synopsis>with-filename-cstrs ( {(var value)}* ) {form}*</synopsis></refsynopsisdiv>
            <refsect1 id="description_in_m_with-filename-cstrs">
              <title>Description</title>
              <para>
	  Executes <parameter>forms</parameter> in an environemt in which each
	  <parameter>var</parameter> is bound to a stack-allocated foreign
	  pointer which refers to a C-style string suitable for passing
	  to foreign code which expects a filename argument.
	</para>
              <para>
	  For example, one might use this macro in the following way:
  <programlisting>
(with-filename-cstrs ((s (native-translated-namestring pathname)))
  (#_unlink s))
  </programlisting></para>
              <para>
	  Various operating systems have different conventions for how
	  they expect native pathname strings to be encoded.  Darwin
	  expects then to be decomposed UTF-8.  The Unicode variants
	  to Windows file-handling functions expect UTF-16.  Other
	  systems just treat them as opaque byte sequences.  This macro
	  ensures that the correct encoding is used, whatever
	  the host operating system.
	</para>
            </refsect1>
          </refentry>
        </section>
      </section>
      <section id="os-x-darwin">
        <title>OS X (Darwin)</title>
        <para>Clozure CL assumes that pathname strings are decomposed UTF-8.</para>
      </section>
      <section id="linux">
        <title>Linux</title>
        <para>Pathname strings are treated as null-terminated strings
        coded in the encoding named by the value returned by the function
      <indexterm><primary><literal>PATHNAME-ENCODING-NAME</literal></primary></indexterm><literal>PATHNAME-ENCODING-NAME</literal>.  This value may be changed
      with <indexterm><primary><literal>SETF</literal></primary></indexterm><literal>SETF</literal>.</para>
      </section>
      <section id="freebsd">
        <title>FreeBSD</title>
        <para>Pathname strings are treated as null-terminated strings
        encoded according to the current locale; a future release may
        change this convention to use UTF-8.</para>
      </section>
    </section>
    <section id="memory-mapped-files">
      <title>Memory-mapped Files</title>
      <para>In release 1.2 and later, Clozure CL
      supports <indexterm><primary>memory-mapped files</primary></indexterm><glossterm linkend="memory-mapped_file">memory-mapped files</glossterm>. On operating systems that support memory-mapped
      files (including Mac OS X, Linux, and FreeBSD), the operating
      system can arrange for a range of virtual memory addresses to
      refer to the contents of an open file. As long as the file remains
      open, programs can read values from the file by reading addresses
      in the mapped range.</para>
      <para>Using memory-mapped files may in some cases be more
      efficient than reading the contents of a file into a data
      structure in memory.</para>
      <para>      Clozure CL provides the
      functions <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link>
      and <indexterm><primary><literal>MAP-FILE-TO-OCTET-VECTOR</literal></primary></indexterm><link linkend="f_map-file-to-octet-vector"><literal>MAP-FILE-TO-OCTET-VECTOR</literal></link> to support
      memory-mapping. These functions return vectors whose contents are
      the contents of memory-mapped files. Reading an element of such a
      vector returns data from the corresponding position in the
      file.</para>
      <para>      Without memory-mapped files, a common idiom for reading the
      contents of files might be something like this:</para>
      <programlisting>
(let* ((stream (open pathname :direction :input :element-type '(unsigned-byte 8)))
       (vector (make-array (file-size-to-vector-size stream)
                           :element-type '(unsigned-byte 8))))
  (read-sequence vector stream))
    </programlisting>
      <para>Using a memory-mapped files has a result that is the same in
      that, like the above example, it returns a vector whose contents are
      the same as the contents of the file. It differs in that the above
      example creates a new vector in memory and copies the file's
      contents into it; using a memory-mapped file instead arranges for
      the vector's elements to point to the file's contents on disk
      directly, without copying them into memory first.</para>
      <para>      The vectors returned by <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link>
      and <indexterm><primary><literal>MAP-FILE-TO-OCTET-VECTOR</literal></primary></indexterm><link linkend="f_map-file-to-octet-vector"><literal>MAP-FILE-TO-OCTET-VECTOR</literal></link> are read-only; any
      attempt to change an element of a vector returned by these
      functions results in a memory-access error. Clozure CL does not
      currently support writing data to memory-mapped files.</para>
      <para>      Vectors created by <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link>
      and <indexterm><primary><literal>MAP-FILE-TO-OCTET-VECTOR</literal></primary></indexterm><link linkend="f_map-file-to-octet-vector"><literal>MAP-FILE-TO-OCTET-VECTOR</literal></link> are required to
      respect Clozure CL's limit on the total size of an array. That means
      that you cannot use these functions to create a vector longer
      than <indexterm><primary><literal>ARRAY-TOTAL-SIZE-LIMIT</literal></primary></indexterm><literal>ARRAY-TOTAL-SIZE-LIMIT</literal>, even if the filesystem
      supports file sizes that are larger. The value
      of <indexterm><primary><literal>ARRAY-TOTAL-SIZE-LIMIT</literal></primary></indexterm><literal>ARRAY-TOTAL-SIZE-LIMIT</literal> is <literal>(EXPT 2 24)</literal>
      on 32-but platforms; and <literal>(EXPT 2 56)</literal> on 64-bit
      platforms.</para>
      <refentry id="f_map-file-to-ivector">
        <indexterm zone="f_map-file-to-ivector"><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm>
        <refnamediv>
          <refname>MAP-FILE-TO-IVECTOR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:MAP-FILE-TO-IVECTOR pathname element-type</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_map-file-to-ivector">
          <title>Description</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>pathname</parameter></term>
                <listitem><para>The pathname of the file to be memory-mapped.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>element-type</parameter></term>
                <listitem><para>The element-type of the vector to be
            created. Specified as
            a <indexterm><primary>type-specifier</primary></indexterm><glossterm linkend="type-specifier">type-specifier</glossterm>
            that names a subtype of either <literal>SIGNED-BYTE</literal>
            or <literal>UNSIGNED-BYTE</literal>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <para>
      The <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link> function tries to
      open the file at <parameter>pathname</parameter> for reading. If
      successful, the function maps the file's contents to a range of
      virtual addresses. If successful, it returns a read-only vector
      whose element-type is given
      by <parameter>element-type</parameter>, and whose contents are
      the contents of the memory-mapped file.
    </para>
          <para>The returned vector is
      a <indexterm><primary>displaced-array</primary></indexterm><glossterm linkend="displaced_array">displaced-array</glossterm>
      whose element-type is <literal>(UPGRADED-ARRAY-ELEMENT-TYPE
        element-type)</literal>. The target of the displaced array is a
      vector of type <literal>(SIMPLE-ARRAY element-type (*))</literal> whose
      elements are the contents of the memory-mapped file.</para>
          <para>Because of alignment issues, the mapped file's contents
      start a few bytes (4 bytes on 32-bit platforms, 8 bytes on
      64-bit platforms) into the vector. The displaced array returned
      by <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link> hides this overhead, but
      it's usually more efficient to operate on the underlying simple
      1-dimensional array.  Given a displaced array (like the value
      returned by <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link>), the function
      <indexterm><primary><literal>ARRAY-DISPLACEMENT</literal></primary></indexterm><literal>ARRAY-DISPLACEMENT</literal> returns the underlying array and
      the displacement index in elements.</para>
          <para>      Currently, Clozure CL supports only read operations on
      memory-mapped files. If you try to change the contents of an array
      returned by <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link>, Clozure CL signals
      a memory error.</para>
        </refsect1>
      </refentry>
      <refentry id="f_unmap-ivector">
        <indexterm zone="f_unmap-ivector"><primary><literal>UNMAP-IVECTOR</literal></primary></indexterm>
        <refnamediv>
          <refname>UNMAP-IVECTOR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:UNMAP-IVECTOR displaced-array</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_unmap-ivector">
          <title>Description</title>
          <para>If the argument is a displaced-array returned
      by <indexterm><primary><literal>MAP-FILE-TO-IVECTOR</literal></primary></indexterm><link linkend="f_map-file-to-ivector"><literal>MAP-FILE-TO-IVECTOR</literal></link>, and if it has not yet
      been unmapped by this function,
      then <indexterm><primary><literal>UNMAP-IVECTOR</literal></primary></indexterm><link linkend="f_unmap-ivector"><literal>UNMAP-IVECTOR</literal></link> undoes the memory mapping,
      closes the mapped file, and changes the displaced-array so that its
      target is an empty vector (of length zero).</para>
        </refsect1>
      </refentry>
      <refentry id="f_map-file-to-octet-vector">
        <indexterm zone="f_map-file-to-octet-vector"><primary><literal>MAP-FILE-TO-OCTET-VECTOR</literal></primary></indexterm>
        <refnamediv>
          <refname>MAP-FILE-TO-OCTET-VECTOR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:MAP-FILE-TO-OCTET-VECTOR displaced-array</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_map-file-to-octet-vector">
          <title>Description</title>
          <para>This function is a synonym for <literal>(CCL:MAP-FILE-TO-IVECTOR
        pathname '(UNSIGNED-BYTE 8))</literal> It is provided as a convenience
      for the common case of memory-mapping a file as a vector of
      bytes.</para>
        </refsect1>
      </refentry>
      <refentry id="f_unmap-octet-vector">
        <indexterm zone="f_unmap-octet-vector"><primary><literal>UNMAP-OCTET-VECTOR</literal></primary></indexterm>
        <refnamediv>
          <refname>UNMAP-OCTET-VECTOR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:UNMAP-OCTET-VECTOR displaced-array</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_unmap-octet-vector">
          <title>Description</title>
          <para>This function is a synonym
      for <indexterm><primary><literal>UNMAP-IVECTOR</literal></primary></indexterm><link linkend="f_unmap-ivector"><literal>UNMAP-IVECTOR</literal></link></para>
        </refsect1>
      </refentry>
    </section>
    <section id="static-variables">
      <title>Static Variables</title>
      <para>Clozure CL supports the definition
      of <indexterm><primary>static variables</primary></indexterm><glossterm linkend="static_variable">static variables</glossterm>, whose values are the same across threads,
      and which may not be dynamically bound. The value of a static
      variable is thus the same across all threads; changing the value
      in one thread changes it for all threads.</para>
      <para>Attempting to dynamically rebind a static variable (for
      instance, by using <literal>LET</literal>, or using the variable name as
      a parameter in a <literal>LAMBDA</literal> form) signals an
      error. Static variables are shared global resources; a dynamic
      binding is private to a single thread.</para>
      <para>      Static variables therefore provide a simple way to share
      mutable state across threads. They also provide a simple way to
      introduce race conditions and obscure bugs into your code, since
      every thread reads and writes the same instance of a given static
      variable. You must take care, therefore, in how you change the
      values of static variables, and use normal multithreaded
      programming techniques, such as locks or semaphores, to protect
      against race conditions.</para>
      <para>      In Clozure CL, access to a static variable is usually faster than
      access to a special variable that has not been declared
      static.</para>
      <refentry id="m_defstatic">
        <indexterm zone="m_defstatic"><primary><literal>DEFSTATIC</literal></primary></indexterm>
        <refnamediv>
          <refname>DEFSTATIC</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>DEFSTATIC var value <literal>&amp;key</literal> doc-string</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_m_defstatic">
          <title>Description</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>var</parameter></term>
                <listitem><para>The name of the new static variable.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>value</parameter></term>
                <listitem><para>The initial value of the new static variable.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>doc-string</parameter></term>
                <listitem><para>A documentation string that is assigned to the new
            variable.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <para>Proclaims the
      variable <indexterm><primary>special</primary></indexterm><glossterm linkend="special_variable">special</glossterm>,
      assigns the variable the supplied value, and assigns
      the <parameter>doc-string</parameter> to the
      variable's <literal>VARIABLE</literal> documentation. Marks the
      variable static, preventing any attempt to dynamically rebind
      it. Any attempt to dynamically rebind <parameter>var</parameter>
      signals an error.</para>
        </refsect1>
      </refentry>
    </section>
    <section id="saving-applications">
      <title>Saving Applications</title>
      <para>Clozure CL provides the
      function <literal>CCL:SAVE-APPLICATION</literal>, which creates a file
      containing an archived Lisp memory image.</para>
      <para>Clozure CL consists of a small executable called the
      Lisp <indexterm><primary>kernel</primary></indexterm><glossterm linkend="image">kernel</glossterm>, which
      implements the very lowest level features of the Lisp system, and
      an <indexterm><primary>image</primary></indexterm><glossterm linkend="image">image</glossterm>, which
      contains the in-memory representation of most of the Lisp system,
      including functions, data structures, variables, and so on. When
      you start Clozure CL, you are launching the kernel, which then locates
      and reads an image file, restoring the archived image in
      memory. Once the image is fully restored, the Lisp system is
      running.</para>
      <para>Using <literal>CCL:SAVE-APPLICATION</literal>, you can create a
      file that contains a modified image, one that includes any changes
      you've made to the running Lisp system. If you later pass your
      image file to the Clozure CL kernel as a command-line parameter, it
      then loads your image file instead of its default one, and Clozure CL
      starts up with your modifications.</para>
      <para>      If this scenario seems to you like a convenient way to
      create an application, that's just as intended. You can create an
      application by modifying the running Lisp until it does what you
      want, then use <literal>CCL:SAVE-APPLICATION</literal> to preserve your
      changes and later load them for use.</para>
      <para>In fact, you can go further than that. You can replace
      Clozure CL's <indexterm><primary>toplevel function</primary></indexterm><glossterm linkend="toplevel_function">toplevel function</glossterm> with your own, and then, when the image is
      loaded, the Lisp system immediately performs your tasks rather
      than the default tasks that make it a Lisp development system. If
      you save an image in which you have done this, the resulting Lisp
      system is your tool rather than a Lisp development system.</para>
      <para>You can go a step further still. You can
      tell <literal>CCL:SAVE-APPLICATION</literal> to prepend the Lisp kernel
      to the image file. Doing this makes the resulting image into a
      self-contained executable binary. When you run the resulting file,
      the Lisp kernel immediately loads the attached image file and runs
      your saved system. The Lisp system that starts up can have any
      behavior you choose. It can be a Lisp development system, but with
      your customizations; or it can immediately perform some task of
      your design, making it a specialized tool rather than a general
      development system.</para>
      <para>      In other words, you can develop any application you like by
      interactively modifying Clozure CL until it does what you want, then
      using <literal>CCL:SAVE-APPLICATION</literal> to preserve your changes
      in an executable image.</para>
      <para>On Mac OS X,
      the <link linkend="the-application-builder">application builder</link>
      uses <literal>CCL:SAVE-APPLICATION</literal> to create the executable
      portion of the <indexterm><primary>application bundle</primary></indexterm><glossterm linkend="application_bundle">application bundle</glossterm>. Double-clicking the application bundle runs
      the executable image created
      by <literal>CCL:SAVE-APPLICATION</literal>.</para>
      <para>Also on Mac OS X, Clozure CL supports an object type
      called <literal>MACPTR</literal>, which is the type of pointers into the
      foreign (Mac OS) heap. Examples of
      commonly-user <literal>MACPTR</literal> objects are Cocoa windows and
      other dynamically-allocated Mac OS system objects.</para>
      <para>      Because a <literal>MACPTR</literal> object is a pointer into a
      foreign heap that exists for the lifetime of the running Lisp
      process, and because a saved image is used by loading it into a
      brand new Lisp process, saved <literal>MACPTR</literal> objects cannot
      be relied on to point to the same things when reconstituted from a
      saved image. In fact, a restored <literal>MACPTR</literal> object might
      point to anything at all-for example an arbitrary location
      in the middle of a block of code, or a completely nonexistent
      virtual address.</para>
      <para>      For that reason, <literal>CCL:SAVE-APPLICATION</literal> converts
      all <literal>MACPTR</literal> objects to <literal>DEAD-MACPTR</literal>
      objects when writing them to an image
      file. A <literal>DEAD-MACPTR</literal> is functionally identical to
      a <literal>MACPTR</literal>, except that code that operates
      on <literal>MACPTR</literal> objects distinguishes them
      from <literal>DEAD-MACPTR</literal> objects and can handle them
      appropriately-signaling errors, for example.</para>
      <para>      As of Clozure CL 1.2, there is one exception to the conversion
      of <literal>MACPTR</literal> to <literal>DEAD-MACPTR</literal> objects:
      a <literal>MACPTR</literal> object that points to the address 0 is not
      converted, because address 0 can always be relied upon to refer to
      the same thing.</para>
      <para>As of Clozure CL 1.2, the constant <literal>CCL:+NULL-PTR+</literal>
      refers to a <literal>MACPTR</literal> object that points to address 0.</para>
      <para>      On all supported platforms, you can
      use <literal>CCL:SAVE-APPLICATION</literal> to create a command-line
      tool that runs the same way any command-line program
      does. Alternatively, if you choose not to prepend the kernel, you
      can save an image and then later run it by passing it as a
      command-line parameter to the <literal>ccl</literal>
      or <literal>ccl64</literal> script.</para>
      <refentry id="f_save-application">
        <indexterm zone="f_save-application"><primary><literal>SAVE-APPLICATION</literal></primary></indexterm>
        <refnamediv>
          <refname>SAVE-APPLICATION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>SAVE-APPLICATION filename <literal>&amp;key</literal> toplevel-function init-file error-handler application-class clear-clos-caches (purify t) impurify (mode #o644) prepend-kernel native</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_save-application">
          <title>Description</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>filename</parameter></term>
                <listitem><para>The pathname of the file to be created when Clozure CL
            saves the application.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>toplevel-function</parameter></term>
                <listitem><para>The function to be executed after startup is
            complete. The toplevel is a function of no arguments that
            performs whatever actions the lisp system should perform
            when launched with this image.</para><para>If this parameter is not supplied, Clozure CL uses its
            default toplevel. The default toplevel runs
            the <indexterm><primary>read-eval-print loop</primary></indexterm><glossterm linkend="repl">read-eval-print loop</glossterm>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>init-file</parameter></term>
                <listitem><para>The pathname of a Lisp file to be loaded when the
            image starts up. You can place initialization expressions in
            this file, and use it to customize the behavior of the Lisp
            system when it starts up.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>error-handler</parameter></term>
                <listitem><para>The error-handling mode for the saved image. The
            supplied value determines what happens when an error is not
            handled by the saved image. Valid values
            are <literal>:quit</literal> (Lisp exits with an error
            message); <literal>:quit-quietly</literal> (Lisp exits without an
            error message); or <literal>:listener</literal> (Lisp enters a
            break loop, enabling you to debug the problem by interacting
            in a listener). If you don't supply this parameter, the
            saved image uses the default error handler
            (<literal>:listener</literal>).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>application-class</parameter></term>
                <listitem><para>The CLOS class that represents the saved Lisp
            application. Normally you don't need to supply this
            parameter; <literal>CCL:SAVE-APPLICATION</literal> uses the
            class <literal>CCL:LISP-DEVELOPMENT-SYSTEM</literal>. In some
            cases you may choose to create a custom application class;
            in that case, pass the name of the class as the value for
            this parameter.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>clear-clos-caches</parameter></term>
                <listitem><para>If true, ensures that CLOS caches are emptied before
            saving the image. Normally you don't need to supply this
            parameter, but if for some reason you want to ensure the
            CLOS caches are clear when the image starts up, you can pass
            any true value.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>purify</parameter></term>
                <listitem><para>
	    When true, calls (in effect) <literal>purify</literal> before
	    saving the heap image.  This moves certain objects that
	    are unlikely to become garbage to a special memory area
	    that is not scanned by the GC (since it is expected that
	    the GC wouldn't find anything to collect).
         </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>impurify</parameter></term>
                <listitem><para>
	    If true, calls (in effect) <literal>impurify</literal> before
	    saving the heap image.  (If both <literal>:impurify</literal>
	    and <literal>:purify</literal> are true, first
	    <literal>impurify</literal> is done, and then <literal>purify</literal>.)</para><para>	   <literal>impurify</literal> moves objects in certain special memory
	   areas into the regular dynamic heap, where they will be scanned
	   by the GC.
	 </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>mode</parameter></term>
                <listitem><para>
	    A number specifying the mode (permission bits) of the output file.
	  </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>prepend-kernel</parameter></term>
                <listitem><para>Specifies the file to prepend to the saved heap
	  image.  A value of <literal>t</literal> means to prepend
	  the lisp kernel binary that the lisp started with.
	  Otherwise, the value of <literal>:prepend-kernel</literal>
	  should be a pathname designator for the file to be
	  prepended.</para><para>	   If the prepended file is execuatable, its execute
	   mode bits will be copied to the output file.</para><para>	   This argument can be used to prepend any kind of file to
	   the saved heap image.  This can be useful in some special
	   cases.
	 </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>native</parameter></term>
                <listitem><para>If true, saves the image as a native (ELF, Mach-O, PE)
          shared library.  (On platforms where this isn't yet supported,
          a warning is issued and the option is ignored.)
         </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
      </refentry>
      <para/>
    </section>
    <section id="concatenating-fasl-files">
      <title>Concatenating FASL Files</title>
      <para>
      Multiple fasl files can be concatenated into a single file.
    </para>
      <refentry id="f_fasl-concatenate">
        <indexterm zone="f_fasl-concatenate"><primary><literal>FASL-CONCATENATE</literal></primary></indexterm>
        <refnamediv>
          <refname>FASL-CONCATENATE</refname>
          <refpurpose>
	Concatenate several fasl files, producing a single output file.
      </refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>fasl-concatenate out-file fasl-files <literal>&amp;key</literal> (:if-exists :error)</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_fasl-concatenate">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>out-file</parameter></term>
                <listitem><para>
	      Name of the file in which to store the concatenation.
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>fasl-files</parameter></term>
                <listitem><para>
	      List of names of fasl files to concatenate.
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>if-exists</parameter></term>
                <listitem><para>
	      As for <indexterm><primary><literal>OPEN</literal></primary></indexterm><literal>OPEN</literal>, defaults to <literal>:error</literal></para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_fasl-concatenate">
          <title>Description</title>
          <para>
	Creates a fasl file which, when loaded, will have the same
	effect as loading the individual input fasl files in the
	specified order.  The single file might be easier to
	distribute or install, and loading it may be at least a little
	faster than loading the individual files (since it avoids the
	overhead of opening and closing each file in succession.)</para>
          <para>	The PATHNAME-TYPE of the output file and of each input file
	defaults to the current platform's fasl file type (.dx64fsl or
	whatever.)  If any of the input files has a different
	type/extension an error will be signaled, but it doesn't
	otherwise try too hard to verify that the input files are real
	fasl files for the current platform.
      </para>
        </refsect1>
      </refentry>
    </section>
    <section id="floating-point-numbers">
      <title>Floating Point Numbers</title>
      <para>
      In Clozure CL, the Common Lisp types short-float and single-float are
      implemented as IEEE single precision values; double-float and
      long-float are IEEE double precision values.  On 64-bit
      platforms, single-floats are immediate values (like fixnums and
      characters).</para>
      <para>    Floating-point exceptions are generally enabled and detected.  By
    default, threads start up with overflow, division-by-zero, and
    invalid enabled, and the rounding mode is set to nearest. The
    functions <indexterm><primary><literal>SET-FPU-MODE</literal></primary></indexterm><link linkend="f_set-fpu-mode"><literal>SET-FPU-MODE</literal></link> and
    <indexterm><primary><literal>GET-FPU-MODE</literal></primary></indexterm><link linkend="f_get-fpu-mode"><literal>GET-FPU-MODE</literal></link> provide user control over
    floating-point behavior.
  </para>
      <refentry id="f_get-fpu-mode">
        <indexterm zone="f_get-fpu-mode"><primary><literal>GET-FPU-MODE</literal></primary></indexterm>
        <refnamediv>
          <refname>GET-FPU-MODE</refname>
          <refpurpose>
	Return the state of exception-enable and rounding-mode control
	flags for the current thread.
      </refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>get-fpu-mode <literal>&amp;optional</literal> mode</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_get-fpu-mode">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>mode</parameter></term>
                <listitem><para>
	      One of the keywords :rounding-mode, :overflow,
	      :underflow, :division-by-zero, :invalid, :inexact.
	    </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_get-fpu-mode">
          <title>Description</title>
          <para>
	If <parameter>mode</parameter> is supplied, returns the value of
	the corresponding control flag for the current thread.</para>
          <para>	Otherwise, returns a list of keyword/value pairs which
	describe the floating-point exception-enable and rounding-mode
	control flags for the current thread.
      </para>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>rounding-mode</term>
                <listitem><para>
	      One of :nearest, :zero, :positive, :negative
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>overflow, underflow, division-by-zero, invalid, inexact
	  </term>
                <listitem><para>
	      If true, the floating-point exception is signaled.
	      If NIL, it is masked.
	    </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
      </refentry>
      <refentry id="f_set-fpu-mode">
        <indexterm zone="f_set-fpu-mode"><primary><literal>SET-FPU-MODE</literal></primary></indexterm>
        <refnamediv>
          <refname>SET-FPU-MODE</refname>
          <refpurpose>
	Set the state of exception-enable and rounding-mode control
	flags for the current thread.
      </refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>set-fpu-mode <literal>&amp;key</literal> rounding-mode overflow underflow division-by-zero invalid inexact</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_set-fpu-mode">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>rounding-mode</parameter></term>
                <listitem><para>
	      If supplied, must be one of :nearest, :zero, :positive, or
	      :negative.
	    </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>overflow</parameter>, <parameter>underflow</parameter>, <parameter>division-by-zero</parameter>, <parameter>invalid</parameter>, <parameter>inexact</parameter></term>
                <listitem><para>NIL to mask the exception, T to signal it.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_set-fpu-mode">
          <title>Description</title>
          <para>
	Sets the current thread's exception-enable and rounding-mode
	control flags to the indicated values for arguments that are
	supplied, and preserves the values assoicated with those
	that aren't supplied.
      </para>
        </refsect1>
      </refentry>
    </section>
    <section id="watched-objects">
      <title>Watched Objects</title>
      <para>
    As of release 1.4, Clozure CL provides a way for lisp objects to
    be watched so that a condition will be signaled when a thread
    attempts to write to the watched object. For a certain class of
    bugs (someone is changing this value, but I don't know who), this
    can be extremely helpful.
  </para>
      <section id="watch">
        <title>WATCH</title>
        <refentry id="f_watch">
          <indexterm zone="f_watch"><primary><literal>WATCH</literal></primary></indexterm>
          <refnamediv>
            <refname>WATCH</refname>
            <refpurpose>
	Monitor a lisp object for writes.
      </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>watch <literal>&amp;optional</literal> object</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_watch">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>object</parameter></term>
                  <listitem><para>
	      Any memory-allocated lisp object.
	    </para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_watch">
            <title>Description</title>
            <para>
	The WATCH function arranges for the specified object to be
	monitored for writes. This is accomplished by copying the
	object to its own set of virtual memory pages, which are then
	write-protected. This protection is enforced by the computer's
	memory-management hardware; the write-protection does not slow
	down reads at all.</para>
            <para>	When any write to the object is attempted, a
	WRITE-TO-WATCHED-OBJECT condition will be signaled.</para>
            <para>	When called with no arguments, WATCH returns a freshly-consed
	list of the objects currently being watched.</para>
            <para>	WATCH returns NIL if the object cannot be watched (typically
	because the object is in a static or pure memory area).
      </para>
          </refsect1>
          <refsect1 id="dwim">
            <title>DWIM</title>
            <para>
      WATCH operates at a fairly low level; it is not possible to
      avoid the details of the internal representation of objects.
      Nevertheless, as a convenience, WATCHing a standard-instance,
      a hash-table, or a multi-dimensional or non-simple CL array
      will watch the underlying slot-vector, hash-table-vector, or
      data-vector, respectively.
      </para>
          </refsect1>
          <refsect1 id="discussion_in_f_watch">
            <title>Discussion</title>
            <para>
      WATCH can monitor any memory-allocated lisp object.</para>
            <para>      In Clozure CL, a memory-allocated object is either a cons cell
      or a uvector.</para>
            <para>      WATCH operates on cons cells, not lists. In order to watch a
      chain of cons cells, each cons cell must be watched
      individually. Because each watched cons cell takes up its own
      own virtual memory page (4 Kbytes), it's only feasible to watch
      relatively short lists.</para>
            <para>      If a memory-allocated object isn't a cons cell, then it is a
      vector-like object called a uvector. A uvector is a
      memory-allocated lisp object whose first word is a header that
      describes the object's type and the number of elements that it
      contains.</para>
            <para>      So, a hash table is a uvector, as is a string, a standard
      instance, a double-float, a CL array or vector, and so forth.</para>
            <para>      Some CL objects, like strings and other simple vectors, map in a
      straightforward way onto the uvector representation. It is easy
      to understand what happens in such cases. The uvector index
      corresponds directly to the vector index:
    </para>
            <programlisting>
? (defvar *s* &quot;xxxxx&quot;)
*S*
? (watch *s*)
&quot;xxxxx&quot;
? (setf (char *s* 3) #\o)
&gt; Error: Write to watched uvector &quot;xxxxx&quot; at index 3
&gt;        Faulting instruction: (movl (% eax) (@ -5 (% r15) (% rcx)))
&gt; While executing: SET-CHAR, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
</programlisting>
            <para>
      In the case of more complicated objects (e.g., a hash-table, a
      standard-instance, a package, etc.), the elements of the uvector
      are like slots in a structure. It's necessary to know which one
      of those &quot;slots&quot; contains the data that will be changed when the
      object is written to.</para>
            <para>      As mentioned above, watch knows about arrays, hash-tables, and
      standard-instances, and will automatically watch the appropriate
      data-containing element.</para>
            <para>      An example might make this clearer.
    </para>
            <programlisting>
? (defclass foo ()
    (slot-a slot-b slot-c))
#&lt;STANDARD-CLASS FOO&gt;
? (defvar *a-foo* (make-instance 'foo))
*A-FOO*
? (watch *a-foo*)
#&lt;SLOT-VECTOR #xDB00D&gt;
;;; Note that WATCH has watched the internal slot-vector object
? (setf (slot-value *a-foo* 'slot-a) 'foo)
&gt; Error: Write to watched uvector #&lt;SLOT-VECTOR #xDB00D&gt; at index 1
&gt;        Faulting instruction: (movq (% rsi) (@ -5 (% r8) (% rdi)))
&gt; While executing: %MAYBE-STD-SETF-SLOT-VALUE-USING-CLASS, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
</programlisting>
            <para>
      Looking at a backtrace would presumably show what object and
      slot name were written.</para>
            <para>      Note that even though the write was to slot-a, the uvector index
      was 1 (not 0). This is because the first element of a
      slot-vector is a pointer to the instance that owns the slots. We
      can retrieve that to look at the object that was modified:
    </para>
            <programlisting>
1 &gt; (uvref (write-to-watched-object-object *break-condition*) 0)
#&lt;FOO #x30004113502D&gt;
1 &gt; (describe *)
#&lt;FOO #x30004113502D&gt;
Class: #&lt;STANDARD-CLASS FOO&gt;
Wrapper: #&lt;CLASS-WRAPPER FOO #x300041135EBD&gt;
Instance slots
SLOT-A: #&lt;Unbound&gt;
SLOT-B: #&lt;Unbound&gt;
SLOT-C: #&lt;Unbound&gt;
1 &gt;
</programlisting>
          </refsect1>
        </refentry>
      </section>
      <section id="unwatch">
        <title>UNWATCH</title>
        <refentry id="f_unwatch">
          <indexterm zone="f_unwatch"><primary><literal>UNWATCH</literal></primary></indexterm>
          <refnamediv>
            <refname>UNWATCH</refname>
            <refpurpose>
	Stop monitoring a lisp object for writes.
      </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>unwatch object</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_unwatch">
            <title>Description</title>
            <para>
    The UNWATCH function ensures that the specified object is in
    normal, non-monitored memory. If the object is not currently
    being watched, UNWATCH does nothing and returns NIL. Otherwise,
    the newly unwatched object is returned.
  </para>
          </refsect1>
        </refentry>
      </section>
      <section id="write-to-watched-object">
        <title>WRITE-TO-WATCHED-OBJECT</title>
        <refentry id="c_write-to-watched-object">
          <indexterm zone="c_write-to-watched-object"><primary><literal>CCL::WRITE-TO-WATCHED-OBJECT</literal></primary></indexterm>
          <refnamediv>
            <refname>CCL::WRITE-TO-WATCHED-OBJECT</refname>
            <refpurpose>
	Condition signaled when a write to a watched object is attempted.
      </refpurpose>
            <refclass>Condition</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>WRITE-TO-WATCHED-OBJECT</synopsis></refsynopsisdiv>
          <refsect1 id="discussion_in_c_write-to-watched-object">
            <title>Discussion</title>
            <para>
      This condition is signaled when a watched object is written
      to. There are three slots of interest:
    </para>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term>object</term>
                  <listitem><para>
	    The actual object that was the destination of the write.
	  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>offset</term>
                  <listitem><para>
	    The byte offset from the tagged object pointer to the
	    address of the write.
	  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>instruction</term>
                  <listitem><para>
	    The disassembled machine instruction that attempted the write.
	  </para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="restarts">
            <title>Restarts</title>
            <para>
      A few restarts are provided: one will skip over the faulting
      write instruction and proceed; another offers to unwatch the
      object and continue.</para>
            <para>      There is also an emulate restart. In some common cases, the
      faulting write instruction can be emulated, enabling the write
      to be performed without having to unwatch the object (and
      therefore let other threads potentially write to it). If the
      faulting instruction isn't recognized, the emulate restart will
      not be offered.
    </para>
          </refsect1>
        </refentry>
      </section>
      <section id="notes_in_watched-objects">
        <title>Notes</title>
        <para>
  Although some care has been taken to minimize potential problems
  arising from watching and unwatching objects from multiple
  threads, there may well be subtle race conditions present that
  could cause bad behavior.</para>
        <para>  For example, suppose that a thread attempts to write to a watched
  object. This causes the operating system to generate an
  exception. The lisp kernel figures out what the exception is, and
  calls back into lisp to signal the write-to-watched-object
  condition and perhaps handle the error.</para>
        <para>  Now, as soon lisp code starts running again (for the callback),
  it's possible that some other thread could unwatch the very
  watched object that caused the exception, perhaps before we even
  have a chance to signal the condition, much less respond to it.</para>
        <para>  Having the object unwatched out from underneath a handler may at
  least confuse it, if not cause deeper trouble. Use caution with
  unwatch.
</para>
      </section>
      <section id="examples_in_watched-objects">
        <title>Examples</title>
        <para>
  Here are a couple more examples in addition to the above examples
  of watching a string and a standard-instance.
</para>
        <section id="fancy-arrays">
          <title>Fancy arrays</title>
          <programlisting>
?  (defvar *f* (make-array '(2 3) :element-type 'double-float))
*F*
? (watch *f*)
#(0.0D0 0.0D0 0.0D0 0.0D0 0.0D0 0.0D0)
;;; Note that the above vector is the underlying data-vector for the array
? (setf (aref *f* 1 2) pi)
&gt; Error: Write to watched uvector #&lt;VECTOR 6 type DOUBLE-FLOAT, simple&gt; at index 5
&gt;        Faulting instruction: (movq (% rax) (@ -5 (% r8) (% rdi)))
&gt; While executing: ASET, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
1 &gt; 
  </programlisting>
          <para>
    In this case, uvector index in the report is the row-major index
    of the element that was written to.
  </para>
        </section>
        <section id="hash-tables">
          <title>Hash tables</title>
          <para>
    Hash tables are surprisingly complicated. The representation of a
    hash table includes an element called a hash-table-vector. The
    keys and values of the elements are stored pairwise in this
    vector.</para>
          <para>    One problem with trying to monitor hash tables for writes is that
    the underlying hash-table-vector is replaced with an entirely new
    one when the hash table is rehashed. A previously-watched
    hash-table-vector will not be the used by the hash table after
    rehashing, and writes to the new vector will not be caught.
  </para>
          <programlisting>
? (defvar *h* (make-hash-table))
*H*
? (setf (gethash 'noise *h*) 'feep)
FEEP
? (watch *h*)
#&lt;HASH-TABLE-VECTOR #xDD00D&gt;
;;; underlying hash-table-vector
? (setf (gethash 'noise *h*) 'ding)
&gt; Error: Write to watched uvector #&lt;HASH-TABLE-VECTOR #xDD00D&gt; at index 35
&gt;        Faulting instruction: (lock)
&gt;          (cmpxchgq (% rsi) (@ (% r8) (% rdx)))
&gt; While executing: %STORE-NODE-CONDITIONAL, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
;;; see what value is being replaced...
1 &gt; (uvref (write-to-watched-object-object *break-condition*) 35)
FEEP
;;; backtrace shows useful context
1 &gt; :b
*(1A109F8) : 0 (%STORE-NODE-CONDITIONAL ???) NIL
 (1A10A50) : 1 (LOCK-FREE-PUTHASH NOISE #&lt;HASH-TABLE :TEST EQL size 1/60 #x30004117D47D&gt; DING) 653
 (1A10AC8) : 2 (CALL-CHECK-REGS PUTHASH NOISE #&lt;HASH-TABLE :TEST EQL size 1/60 #x30004117D47D&gt; DING) 229
 (1A10B00) : 3 (TOPLEVEL-EVAL (SETF (GETHASH # *H*) 'DING) NIL) 709
 ...
  </programlisting>
        </section>
        <section id="lists">
          <title>Lists</title>
          <para>
    As previously mentioned, WATCH only watches individual cons cells.
  </para>
          <programlisting>
? (defun watch-list (list)
    (maplist #'watch list))
WATCH-LIST
? (defvar *l* (list 1 2 3))
*L*
? (watch-list *l*)
((1 2 3) (2 3) (3))
? (setf (nth 2 *l*) 'foo)
&gt; Error: Write to the CAR of watched cons cell (3)
&gt;        Faulting instruction: (movq (% rsi) (@ 5 (% rdi)))
&gt; While executing: %SETNTH, in process listener(1).
&gt; Type :POP to abort, :R for a list of available restarts.
&gt; Type :? for other options.
  </programlisting>
        </section>
      </section>
    </section>
    <section id="code-coverage">
      <title>Code Coverage</title>
      <section id="overview_in_code-coverage">
        <title>Overview</title>
        <para>
  In Clozure CL 1.4 and later, code coverage provides information
  about which paths through generated code have been executed and
  which haven't. For each source form, it can report one of three
  possible outcomes:
</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>
      Not covered: this form was never entered.
    </para></listitem>
            <listitem><para>
      Partly covered: This form was entered, and some parts were
      executed and some weren't.
    </para></listitem>
            <listitem><para>
      Fully covered: Every bit of code generated from this form was
      executed.
    </para></listitem>
          </itemizedlist>
        </blockquote>
      </section>
      <section id="limitations">
        <title>Limitations</title>
        <para>
  While the information gathered for coverage of generated code is
  complete and precise, the mapping back to source forms is of
  necessity heuristic, and depends a great deal on the behavior of
  macros and the path of the source forms through compiler
  transforms. Source information is not recorded for variables, which
  further limits the source mapping. In practice, there is often
  enough information scattered about a partially covered function to
  figure out which logical path through the code was taken and which
  wasn't. If that doesn't work, you can try disassembling to see which
  parts of the compiled code were not executed: in the disassembled
  code there will be references to #&lt;CODE-NOTE [xxx] ...&gt; where xxx
  is NIL if the code that follows was never executed and non-NIL if it
  was.</para>
        <para>  Sometimes the situation can be improved by modifying macros to try
  to preserve more of the input forms, rather than destructuring and
  rebuilding them.
</para>
        <para>
  Because the code coverage information is associated with compiled
  functions, code coverage information is not available for load-time toplevel
  expressions.  You can work around this by creating a function and calling
  it. I.e. instead of
  <programlisting>
(progn
  (do-this)
  (setq that ...) ...))</programlisting>
  do:
  <programlisting>
(defun init-this-and-that ()
  (do-this)
  (setq that ...)  ...)
(init-this-and-that)</programlisting><para/><para>Then you can see the coverage information in the definition of
<literal>init-this-and-that</literal>.
</para></para>
      </section>
      <section id="usage">
        <title>Usage</title>
        <para>
  In order to gather code coverage information, you first have to
  recompile all your code to include code coverage
  instrumentation. Compiling files will generate code coverage
  instrumentation if <literal>CCL:*COMPILE-CODE-COVERAGE*</literal>
  is true:
  <programlisting>
(setq ccl:*compile-code-coverage* t) 
(recompile-all-your-files)</programlisting></para>
        <para>
  The compilation process will be many times slower than normal, and
  the fasl files will be many times bigger.</para>
        <para>  When you execute functions loaded from instrumented fasl files, they
  will record coverage information every time they are executed. 
  You can examine that information by calling <literal>ccl:report-coverage</literal>
  or <literal>ccl:coverage-statistics</literal>.
</para>
        <para>
   While recording coverage, you can collect incremental coverage deltas between any two points
   in time.  You might do this while running a test suite, to record the coverage for
   each test, for example:
  <programlisting>
(ccl:reset-incremental-coverage)
(loop with coverage = (make-hash-table)
      for test in (tests-to-run)
      do (run-test test)
      do (setf (gethash test coverage) (ccl:get-incremental-coverage))
      finally (return coverage))</programlisting>creates a hash table mapping a test to a representation of all coverage recorded while running the
   test.  This hash table can then be passed to <literal>ccl:report-coverage</literal>, <literal>ccl:incremental-coverage-svn-matches</literal>
   or <literal>ccl:incremental-coverage-source-matches</literal>.
</para>
      </section>
      <section id="functions-and-variables">
        <title>Functions and Variables</title>
        <para>
  The following functions can be used to manage the coverage data:
</para>
        <refentry id="f_report-coverage">
          <indexterm zone="f_report-coverage"><primary><literal>REPORT-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>REPORT-COVERAGE</refname>
            <refpurpose>Generate a code coverage report</refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>report-coverage output-file <literal>&amp;key</literal> (tags nil) (external-format :default) (statistics t) (html t)</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_report-coverage">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>output-file</parameter></term>
                  <listitem><para>
          Pathname for the output index file.
	</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>html</parameter></term>
                  <listitem><para>
	  If non-nil (the default), this will generate an HTML report, consisting of
	  an index file in <parameter>output-file</parameter> and, in the same directory,
          one html file for each instrumented source file that has been loaded in the
          current session.
	</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>tags</parameter></term>
                  <listitem><para>
	  If non-nil, this should be a hash table mapping arbitrary keys (tags) to incremental coverage deltas.  The
          HTML report will show a list of tags, and allow selection of an arbitrary subset of them to show the
          coloring and statistics for coverage by that subset.
	</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>external-format</parameter></term>
                  <listitem><para>
	  Controls the external format of the html files.
	</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>statistics</parameter></term>
                  <listitem><para>
	  If non-nil (the default), a comma-separated file is 
	  generated with the summary of statistics. You can specify a
	  filename for the statistics argument, otherwise
	  &quot;statistics.csv&quot; is created in the directory of <parameter>output-file</parameter>.
          See documentation of coverage-statistics below for a
	  description of the values in the statistics file.
	</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="example_in_f_report-coverage">
            <title>Example</title>
            <para>
      If you've loaded <code>foo.lx64fsl</code> and
      <code>bar.lx64fsl</code>, and have run some tests, you could
      do
    <programlisting>
(REPORT-COVERAGE &quot;/my/dir/coverage/report.html&quot;)
    </programlisting>
    and this would generate <code>report.html</code>,
    <code>foo_lisp.html</code> and
    <code>bar_lisp.html</code>, and
    <code>statistics.csv</code> all in
    <code>/my/dir/coverage/</code>.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_reset-coverage">
          <indexterm zone="f_reset-coverage"><primary><literal>RESET-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>RESET-COVERAGE</refname>
            <refpurpose>
      Resets all coverage data back to the &quot;Not Executed&quot; state
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>RESET-COVERAGE</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_reset-coverage">
            <title>Description</title>
            <para>
      Resets all coverage data back to the &quot;Not Executed&quot; state
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_clear-coverage">
          <indexterm zone="f_clear-coverage"><primary><literal>CLEAR-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>CLEAR-COVERAGE</refname>
            <refpurpose>
      Forget about all instrumented files that have been loaded.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>CLEAR-COVERAGE</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_clear-coverage">
            <title>Description</title>
            <para>
      Gets rid of the information about which instrumented files have
      been loaded, so <literal>ccl:report-coverage</literal> will not report any files,
      and <literal>ccl:save-coverage-in-file</literal> will not save any info, until more
      instrumented files are loaded.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_save-coverage-in-file">
          <indexterm zone="f_save-coverage-in-file"><primary><literal>SAVE-COVERAGE-IN-FILE</literal></primary></indexterm>
          <refnamediv>
            <refname>SAVE-COVERAGE-IN-FILE</refname>
            <refpurpose>
      Save all coverage into to a file so you can restore it later.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>save-coverage-in-file pathname</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_save-coverage-in-file">
            <title>Description</title>
            <para>
      Saves all coverage info in a file, so you can restore the
      coverage state later. This allows you to combine multiple runs
      or continue in a later session. Equivalent to
      <literal>(ccl:write-coverage-to-file (ccl:get-coverage) pathname)</literal>.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_restore-coverage-from-file">
          <indexterm zone="f_restore-coverage-from-file"><primary><literal>RESTORE-COVERAGE-FROM-FILE</literal></primary></indexterm>
          <refnamediv>
            <refname>RESTORE-COVERAGE-FROM-FILE</refname>
            <refpurpose>
      Load coverage state from a file.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>restore-coverage-from-file pathname</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_restore-coverage-from-file">
            <title>Description</title>
            <para>
      Restores the coverage data previously saved with
      ccl:save-coverage-in-file, for the set of instrumented fasls
      that were loaded both at save and restore time. I.e. coverage
      info is only restored for files that have been loaded in this
      session. For example if in a previous session you had loaded
      <code>&quot;foo.lx86fsl&quot;</code> and then saved the coverage info, in this session
      you must load the same <code>&quot;foo.lx86fsl&quot;</code> before calling
      <literal>restore-coverage-from-file</literal> in order to retrieve the stored
      coverage info for &quot;foo&quot;.  Equivalent to <literal>(ccl:restore-coverage
      (ccl:read-coverage-from-file pathname))</literal>.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_get-coverage">
          <indexterm zone="f_get-coverage"><primary><literal>GET-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>GET-COVERAGE</refname>
            <refpurpose>
      Returns a snapshot of the current coverage data.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>GET-COVERAGE</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_get-coverage">
            <title>Description</title>
            <para>
      Returns a snapshot of the current coverage data. A snapshot is a
      copy of the current coverage state. It can be saved in a file
      with <literal>ccl:write-coverage-to-file</literal>, reinstated back as the current
      state with <literal>ccl:restore-coverage</literal>, or combined with other
      snapshots with <literal>ccl:combine-coverage</literal>.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_restore-coverage">
          <indexterm zone="f_restore-coverage"><primary><literal>RESTORE-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>RESTORE-COVERAGE</refname>
            <refpurpose>
      Reinstalls a coverage snapshot as the current coverage state.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>restore-coverage snapshot</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_restore-coverage">
            <title>Description</title>
            <para>
      Reinstalls a coverage snapshot as the current coverage state.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_combine-coverage">
          <indexterm zone="f_combine-coverage"><primary><literal>COMBINE-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>COMBINE-COVERAGE</refname>
            <refpurpose>
      Combines multiple coverage snapshots into one.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>combine-coverage snapshots</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_combine-coverage">
            <title>Description</title>
            <para>
      Takes a list of coverage snapshots and returns a new coverage snapshot
      representing a union of all the coverage data.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_write-coverage-to-file">
          <indexterm zone="f_write-coverage-to-file"><primary><literal>WRITE-COVERAGE-TO-FILE</literal></primary></indexterm>
          <refnamediv>
            <refname>WRITE-COVERAGE-TO-FILE</refname>
            <refpurpose>
      Save a coverage snapshot in a file.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>write-coverage-to-file snapshot pathname</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_write-coverage-to-file">
            <title>Description</title>
            <para>
      Saves the coverage snapshot in a file. The snapshot can be
      loaded back with <literal>ccl:read-coverage-from-file</literal> or loaded and
      restored with <literal>ccl:restore-coverage-from-file</literal>. Note that the file
      created is actually a lisp source file and can be compiled for
      faster loading.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_read-coverage-from-file">
          <indexterm zone="f_read-coverage-from-file"><primary><literal>READ-COVERAGE-FROM-FILE</literal></primary></indexterm>
          <refnamediv>
            <refname>READ-COVERAGE-FROM-FILE</refname>
            <refpurpose>
      Return the coverage snapshot saved in a file.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>read-coverage-from-file pathname</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_read-coverage-from-file">
            <title>Description</title>
            <para>
      Returns the snapshot saved in pathname. Doesn't affect the
      current coverage state. pathname can be the file previously
      created with <literal>ccl:write-coverage-to-file</literal> or
      <literal>ccl:save-coverage-in-file</literal>, or it can be the name of the fasl
      created from compiling such a file.
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_coverage-statistics">
          <indexterm zone="f_coverage-statistics"><primary><literal>COVERAGE-STATISTICS</literal></primary></indexterm>
          <refnamediv>
            <refname>COVERAGE-STATISTICS</refname>
            <refpurpose>
      Returns a sequence of <literal>ccl:coverage-statistics</literal> objects, one per source file.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>coverage-statistics</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_coverage-statistics">
            <title>Description</title>
            <para>
      Returns a sequence of <literal>ccl:coverage-statistics</literal> objects, one for each
      source file, containing the same information as that written to
      the statistics file by <indexterm><primary><literal>REPORT-COVERAGE</literal></primary></indexterm><link linkend="f_report-coverage"><literal>REPORT-COVERAGE</literal></link>. The following
      accessors are defined for <literal>ccl:coverage-statistics</literal> objects:
      <blockquote><variablelist><varlistentry><term><indexterm><primary><literal>COVERAGE-SOURCE-FILE</literal></primary></indexterm><literal>COVERAGE-SOURCE-FILE</literal></term><listitem><para>
	    the name of the source file corresponding to this information
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-EXPRESSIONS-TOTAL</literal></primary></indexterm><literal>COVERAGE-EXPRESSIONS-TOTAL</literal></term><listitem><para>
	    the total number of expressions
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-EXPRESSIONS-ENTERED</literal></primary></indexterm><literal>COVERAGE-EXPRESSIONS-ENTERED</literal></term><listitem><para>
	    the number of source expressions that have been entered
	    (i.e. at least partially covered)
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-EXPRESSIONS-COVERED</literal></primary></indexterm><literal>COVERAGE-EXPRESSIONS-COVERED</literal></term><listitem><para>
	    the number of source expressions that were fully covered
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-UNREACHED-BRANCHES</literal></primary></indexterm><literal>COVERAGE-UNREACHED-BRANCHES</literal></term><listitem><para>
	    the number of conditionals with one branch taken and one not taken
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-CODE-FORMS-TOTAL</literal></primary></indexterm><literal>COVERAGE-CODE-FORMS-TOTAL</literal></term><listitem><para>
	    the total number of code forms. A code form is an
	    expression in the final stage of compilation, after all
	    macroexpansion and compiler transforms and simplification
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-CODE-FORMS-COVERED</literal></primary></indexterm><literal>COVERAGE-CODE-FORMS-COVERED</literal></term><listitem><para>
	    the number of code forms that have been entered
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-FUNCTIONS-TOTAL</literal></primary></indexterm><literal>COVERAGE-FUNCTIONS-TOTAL</literal></term><listitem><para>
	    the total number of functions
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-FUNCTIONS-FULLY-COVERED</literal></primary></indexterm><literal>COVERAGE-FUNCTIONS-FULLY-COVERED</literal></term><listitem><para>
	    the number of functions that were fully covered
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-FUNCTIONS-PARTLY-COVERED</literal></primary></indexterm><literal>COVERAGE-FUNCTIONS-PARTLY-COVERED</literal></term><listitem><para>
	    the number of functions that were partly covered
	  </para></listitem></varlistentry><varlistentry><term><indexterm><primary><literal>COVERAGE-FUNCTIONS-NOT-ENTERED</literal></primary></indexterm><literal>COVERAGE-FUNCTIONS-NOT-ENTERED</literal></term><listitem><para>
	    the number of functions never entered
	  </para></listitem></varlistentry></variablelist></blockquote></para>
          </refsect1>
        </refentry>
        <refentry id="f_reset-incremental-coverage">
          <indexterm zone="f_reset-incremental-coverage"><primary><literal>RESET-INCREMENTAL-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>RESET-INCREMENTAL-COVERAGE</refname>
            <refpurpose>
      Reset incremental coverage.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>reset-incremental-coverage</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_reset-incremental-coverage">
            <title>Description</title>
            <para>
      Marks a starting point for recording incremental coverage.
      Note that calling
      this function does not affect regular coverage data (whereas calling
      <literal>ccl:reset-coverage</literal> resets incremental coverage as well).
    </para>
          </refsect1>
        </refentry>
        <refentry id="f_get-incremental-coverage">
          <indexterm zone="f_get-incremental-coverage"><primary><literal>GET-INCREMENTAL-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>GET-INCREMENTAL-COVERAGE</refname>
            <refpurpose>
      Returns the delta of coverage since the last incremental reset.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>get-incremental-coverage <literal>&amp;key</literal> (reset t)</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_get-incremental-coverage">
            <title>Description</title>
            <para>
      Returns the delta of coverage since the last reset of incremental coverage.
     If <literal>reset</literal> is true (the default), it also resets incremental coverage
     now, so that the next call to <literal>get-incremental-coverage</literal> will return
     the delta from this point.</para>
            <para>      Incremental coverage deltas are represented differently than the full coverage snapshots
      returned by functions such as <literal>ccl:get-coverage</literal>.  Incremental
      coverage uses an abbreviated format
      and is missing some of the information in a full snapshot, and therefore cannot be passed to
      functions documented to accept a <parameter>snapshot</parameter>, only to functions
      specifically documented to accept incremental coverage deltas.
     </para>
          </refsect1>
        </refentry>
        <refentry id="f_incremental-coverage-source-matches">
          <indexterm zone="f_incremental-coverage-source-matches"><primary><literal>INCREMENTAL-COVERAGE-SOURCE-MATCHES</literal></primary></indexterm>
          <refnamediv>
            <refname>INCREMENTAL-COVERAGE-SOURCE-MATCHES</refname>
            <refpurpose>
      Find incremental coverage deltas intersecting source regions.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>incremental-coverage-source-matches collection sources</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_incremental-coverage-source-matches">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>collection</parameter></term>
                  <listitem><para>
          A hash table mapping arbitrary keys to incremental coverage deltas, or a sequence of
          incremental coverage deltas.
         </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>sources</parameter></term>
                  <listitem><para>
          A list of pathnames and/or source-notes, the latter representing a range within a file.
         </para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_incremental-coverage-source-matches">
            <title>Description</title>
            <para>
     Given a hash table <literal>collection</literal> whose values are incremental coverage
     deltas, return a list of all keys corresponding to those deltas that intersect any region
     in <literal>sources</literal>.</para>
            <para>     For example if the deltas represent tests, then the returned value is a list of all tests
     that cover some part of the source regions.</para>
            <para>      <literal>collection</literal> can also be a sequence of deltas, in which case a subsequence
      of matching deltas is returned.  In particular you can test whether any particular delta
      intersects the sources by passing it in as a single-element list.
     </para>
          </refsect1>
        </refentry>
        <refentry id="f_incremental-coverage-svn-matches">
          <indexterm zone="f_incremental-coverage-svn-matches"><primary><literal>INCREMENTAL-COVERAGE-SVN-MATCHES</literal></primary></indexterm>
          <refnamediv>
            <refname>INCREMENTAL-COVERAGE-SVN-MATCHES</refname>
            <refpurpose>
      Find incremental coverage deltas matching changes from a particular subversion revision.
    </refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>incremental-coverage-svn-matches collection <literal>&amp;key</literal> (directory (current-directory)) (revision :base)</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_incremental-coverage-svn-matches">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>collection</parameter></term>
                  <listitem><para>
          A hash table mapping arbitrary keys to incremental coverage deltas, or a sequence of
          incremental coverage deltas.
         </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>directory</parameter></term>
                  <listitem><para>
          The pathname of a subversion working directory.
         </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>revision</parameter></term>
                  <listitem><para>
          The revision to compare to the working directory, an integer or another
          value whose printed representation is suitable for passing as the
          <literal>--revision</literal> argument
          to <code>svn</code>.
         </para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_incremental-coverage-svn-matches">
            <title>Description</title>
            <para>
     Given a hash table <literal>collection</literal> whose values are incremental coverage
     deltas, return a list of all keys corresponding to those deltas that intersect any changed
     source in <literal>directory</literal> since revision <literal>revision</literal> in subversion.</para>
            <para>     For example if the deltas represent tests, then the returned value is a list of all tests
     that might be affected by the changes.</para>
            <para>      <literal>collection</literal> can also be a sequence of deltas, in which case a subsequence
      of matching deltas is returned.  In particular you can test whether any particular delta
      is affected by the changes by passing it in as a single-element list.
     </para>
          </refsect1>
        </refentry>
        <refentry id="v_compile-code-coverage">
          <indexterm zone="v_compile-code-coverage"><primary><literal>*COMPILE-CODE-COVERAGE*</literal></primary></indexterm>
          <refnamediv>
            <refname>*COMPILE-CODE-COVERAGE*</refname>
            <refpurpose>
      When true, instrument functions being compiled to collect code coverage information.
    </refpurpose>
            <refclass>Variable</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>*compile-code-coverage*</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_v_compile-code-coverage">
            <title>Description</title>
            <para>
      This variable controls whether functions are instrumented for
      code coverage. Files compiled while this variable is true will
      contain code coverage instrumentation.
    </para>
          </refsect1>
        </refentry>
        <refentry id="m_without-compiling-code-coverage">
          <indexterm zone="m_without-compiling-code-coverage"><primary><literal>WITHOUT-COMPILING-CODE-COVERAGE</literal></primary></indexterm>
          <refnamediv>
            <refname>WITHOUT-COMPILING-CODE-COVERAGE</refname>
            <refpurpose>
      Don't record code coverage for forms within the body.
    </refpurpose>
            <refclass>Macro</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>without-compiling-code-coverage</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_m_without-compiling-code-coverage">
            <title>Description</title>
            <para>
      This macro arranges so that body doesn't record internal details
      of code coverage. It will be considered totally covered if it's
      entered at all. The Common Lisp macros <literal>ASSERT</literal> and <literal>CHECK-TYPE</literal> use
      this macro.
    </para>
          </refsect1>
        </refentry>
      </section>
      <section id="interpreting-code-coloring">
        <title>Interpreting Code Coloring</title>
        <para><para/><para> The output of ccl:report-coverage consists of formatted source code, with coverage indicated by
 coloring.  Four colors are used: dark green for forms that compiled to code in which every single
 instruction was executed, light green for forms that have been entered but weren't totally covered, red
 for forms that were never entered, and the page background color for toplevel forms that weren't
 instrumented.</para></para>
        <para><para>
 The source coloring is applied from outside in.  So for example if you have</para><para>  </para><programlisting>
(outer-form ... (inner-form ...) ...)
  </programlisting><para/><para> first the whole outer form is painted with whatever color expresses the outer form coverage, and then the
 inner form color is replaced with whatever color expresses the inner form coverage.  One consequence of
 this approach is that every part of the outer form that is not specifically inside some executable inner
 form will have the outer form's coverage color. If the syntax of outer form involves some non-executable
 forms, or forms that do not have coverage info of their own for whatever reason, then they will just
 inherit the color of the outer form, because they don't get repainted with a color of their own.
</para></para>
        <para>
 One case in which this approach can be confusing is in the case of symbols.  As noted in the Limitations
 section, coverage information is not recorded for variables; hence the coloring of a variable does not
 convey information about whether the variable was evaluated or not -- that information is not available,
 and the variable just inherits the color of the form that contains it.
</para>
      </section>
    </section>
    <section id="other-extensions">
      <title>Other Extensions</title>
      <refentry id="f_quit">
        <indexterm zone="f_quit"><primary><literal>QUIT</literal></primary></indexterm>
        <refnamediv>
          <refname>QUIT</refname>
          <refpurpose>
      Cleanly exit the lisp.
    </refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>quit <literal>&amp;optional</literal> (exit 0) <literal>&amp;key</literal> error-handler</synopsis></refsynopsisdiv>
        <refsect1 id="summary_in_f_quit">
          <title>Summary</title>
          <para>
      Cleanly exit from lisp.  If the exit argument is a value of type
      (signed-byte 32), that value will be passed to the C library
      function _exit() as the status code.  (A value of nil is treated
      as a zero.)</para>
          <para>      Alternatively, exit may be a function of no arguments;  this function
      will be called instead of _exit() to exit the lisp.</para>
          <para>      The error-handler argument, if supplied, must be a function of one
      argument, the condition, that will be called if an error occurs when
      preparing to quit.  The error-handler function should exit the lisp.
    </para>
        </refsect1>
      </refentry>
      <refentry id="f_wait-for-signal">
        <indexterm zone="f_wait-for-signal"><primary><literal>WAIT-FOR-SIGNAL</literal></primary></indexterm>
        <refnamediv>
          <refname>WAIT-FOR-SIGNAL</refname>
          <refpurpose>
      Wait for a particular signal to be received.
    </refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>wait-for-signal s duration</synopsis></refsynopsisdiv>
        <refsect1 id="summary_in_f_wait-for-signal">
          <title>Summary</title>
          <para>
      Wait for the signal with signal number s to be received, or until
      duration seconds have elapsed.  If duration is nil, wait for an
      indeterminate &quot;very long time&quot; (many years).</para>
          <para>      If signal number s is outside the range of valid signals, or is
      reserved by the lisp for its own use, an error is signaled.
      (An error is always signaled on Windows systems.)
    </para>
        </refsect1>
      </refentry>
      <refentry id="m_unwind-protect">
        <indexterm zone="m_unwind-protect"><primary><literal>UNWIND-PROTECT</literal></primary></indexterm>
        <refnamediv>
          <refname>UNWIND-PROTECT</refname>
          <refpurpose>
      Ensure cleanup-forms are executed.
    </refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>unwind-protect protected-form {cleanup-form}*</synopsis></refsynopsisdiv>
        <refsect1 id="summary_in_m_unwind-protect">
          <title>Summary</title>
          <para>
      In Clozure CL, the cleanup forms are always executed as if they were
      wrapped with <indexterm><primary><literal>WITHOUT-INTERRUPTS</literal></primary></indexterm><link linkend="m_without-interrupts"><literal>WITHOUT-INTERRUPTS</literal></link>.
      To allow interrupts, use
      <indexterm><primary><literal>WITH-INTERRUPTS-ENABLED</literal></primary></indexterm><link linkend="m_with-interrupts-enabled"><literal>WITH-INTERRUPTS-ENABLED</literal></link>.
    </para>
        </refsect1>
      </refentry>
      <refentry id="v_disassemble-verbose">
        <indexterm zone="v_disassemble-verbose"><primary><literal>*DISASSEMBLE-VERBOSE*</literal></primary></indexterm>
        <refnamediv>
          <refname>*DISASSEMBLE-VERBOSE*</refname>
          <refpurpose>
      When true, display verbose disassembly output.
    </refpurpose>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*disassemble-verbose*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_disassemble-verbose">
          <title>Description</title>
          <para>
      When true, the output of <literal>disassemble</literal> may
      include platform-dependent additional information.  For
      instance, on the x86 ports, the output will include the x86
      opcode bytes.</para>
          <para>      The default value is <literal>nil</literal>.
    </para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="the-clozure-cl-ide">
    <title>The Clozure CL IDE</title>
    <section id="introduction_in_the-clozure-cl-ide">
      <title>Introduction</title>
      <para>Clozure CL ships with the complete source code for an integrated
    development environment written using Cocoa on Mac OS X. This
    chapter describes how to build and use that environment,
    referred to hereafter simply as &quot;the IDE&quot;.</para>
      <para>      The IDE provides a programmable text editor, listener
      windows, an inspector for Lisp data structures, and a means of
      easily building a Cocoa application in Lisp. In addition, its
      source code provides an example of a fairly complex Cocoa
      application written in Lisp.</para>
      <para>    The current version of the IDE has seen the addition of numerous
    features and many bugfixes. Although it's by no means a finished product,
    we hope it will prove more useful than previous versions, and we
    plan additional work on the IDE for future releases.</para>
    </section>
    <section id="building-the-ide">
      <title>Building the IDE</title>
      <para>Building the Clozure CL IDE is now a very simple
      process.</para>
      <blockquote>
        <orderedlist>
          <listitem><para>In a shell session, cd to the ccl directory.</para></listitem>
          <listitem><para>Run ccl from the shell. The easiest way to do this is
          generally to execute the ccl or ccl64 command.</para></listitem>
          <listitem><para>Evaluate the form <literal>(require :cocoa-application)</literal></para></listitem>
        </orderedlist>
      </blockquote>
      <para>For example, assuming that the Clozure CL distribution is
      installed in &quot;/usr/local/ccl&quot;, the following sequence of shell
      interactions builds the IDE:</para>
      <programlisting><para>
oshirion:ccl mikel$ ccl64
Welcome to Clozure Common Lisp Version 1.2-r9198M-trunk  (DarwinX8664)!
? (require :cocoa-application)
;Loading #P&quot;ccl:cocoa-ide;fasls;cocoa-utils.dx64fsl.newest&quot;...
;Loading #P&quot;ccl:cocoa-ide;fasls;cocoa-defaults.dx64fsl.newest&quot;...</para><para>[...many lines of &quot;Compiling&quot; and &quot;Loading&quot; omitted...]</para><para>Saving application to /usr/local/ccl/Clozure CL.app/</para><para>oshirion:ccl mikel$ </para><para>    </para></programlisting>
      <para>Clozure CL compiles and loads the various subsystems that
      make up the IDE, then constructs a Cocoa application bundle
      named &quot;Clozure CL.app&quot; and saves the Lisp image into
      it. Normally Clozure CL creates the application bundle in the root
      directory of the Clozure CL distribution.</para>
    </section>
    <section id="running-the-ide">
      <title>Running the IDE</title>
      <para>After it has been built, you can run the &quot;Clozure CL.app&quot;
      application normally, by double-clicking its icon. When
      launched, the IDE initially displays a
      single <indexterm><primary>listener window</primary></indexterm><glossterm linkend="listener_window">listener window</glossterm> that you can use to interact with Lisp. You
      can type Lisp expressions for evaluation at the prompt in the
      listener window. You can also
      use <indexterm><primary>Hemlock</primary></indexterm><glossterm linkend="hemlock">Hemlock</glossterm> editing
      commands to edit the text of expressions in the listener
      window.</para>
    </section>
    <section id="ide-features">
      <title>IDE Features</title>
      <section id="editor-windows">
        <title>Editor Windows</title>
        <para>You can open an editor window either by choosing Open from
        the File menu and then selecting a text file, or by choosing
        New from the File menu. You can also evaluate the
        expression <literal>(ed)</literal> in the listener window; in that
        case Clozure CL creates a new window as if you had chosen New from
        the File menu.</para>
        <para>Editor windows
        implement <indexterm><primary>Hemlock</primary></indexterm><glossterm linkend="hemlock">Hemlock</glossterm>
        editing commands. You can use all the editing and customization
        features of Hemlock within any editor window (including listener
        windows).</para>
      </section>
      <section id="the-lisp-menu">
        <title>The Lisp Menu</title>
        <para>The Lisp menu provides several commands for interacting
        with the running Lisp session, in addition to the ways you can
        interact with it by evaluating expressions. You can evaluate a
        selected range of text in any editing buffer. You can compile
        and load the contents of editor windows (please note that in the
        current version, Clozure CL compiles and loads the contents of the
        file associated with an editor window; that means that if you
        try to load or compile a window that has not been saved to a
        file, the result is an error).</para>
        <para>You can interrupt computations, trigger breaks, and select
        restarts from the Lisp menu. You can also display a backtrace or
        open the <link linkend="the-inspector-window">Inspector window</link>.</para>
        <section id="checking-for-updates">
          <title>Checking for Updates</title>
          <para>At the bottom of the Lisp menu is an item entitled
        &quot;Check for Updates&quot;. If your copy of Clozure CL came from the
        Clozure Subversion server (which is the preferred source), and
        if your internet connection is working, then you can select
        this menu item to check for updates to your copy of
        Clozure CL.</para>
          <para>        When you select &quot;Check for Updates&quot;, Clozure CL uses the svn
        program to query the Clozure Subversion repository and
        determine whether new updates to Clozure CL are available. (This
        means that on Mac OS X versions earlier than 10.5, you must
        ensure that the Subversion client software is installed before
        using the &quot;Check for Updates&quot; feature. See
        the <ulink url="http://www.wikihow.com/Install-Subversion-on-Mac-OS-X">wikiHow
        page</ulink> on installing Subversion for more information.)
        If updates are available, Clozure CL automatically downloads and
        installs them. After a successful download, Clozure CL rebuilds
        itself, and then rebuilds the IDE on the newly-rebuilt
        Lisp. Once this process is finished, you should quit the
        running IDE and start the newly built one (which will be in
        the same place that the old one was).</para>
          <para>        Normally, Clozure CL can install updates and rebuild itself
        without any problems. Occasionally, an unforeseen problem
        (such as a network outage, or a hardware failure) might
        interrupt the self-rebuilding process, and leave your copy of
        Clozure CL unusable. If you are expecting to update your copy of
        Clozure CL frequently, it might be prudent to keep a backup copy of
        your working environment ready in case of such
        situtations. You can also always obtain a full, fresh copy of
        Clozure CL from Clozure's repository..</para>
        </section>
      </section>
      <section id="the-tools-menu">
        <title>The Tools Menu</title>
        <para>The tools menu provides access to the Apropos and
        Processes windows. The Apropos window searches the running Lisp
        image for symbols that match any text you enter. You can use the
        Apropos window to quickly find function names and other useful
        symbols. The Processes window lists all threads running in the
        current Lisp session. If you double-click a process entry, Clozure CL
        opens an <link linkend="the-inspector-window">Inspector window</link> on that process.</para>
      </section>
      <section id="the-inspector-window">
        <title>The Inspector Window</title>
        <para>The Inspector window displays information about a Lisp
        value. The information displayed varies from the very simple, in
        the case of a simple data value such as a character, to the
        complex, in the case of structured data such as lists or CLOS
        objects. The left-hand column of the window's display shows the
        names of the object's attributes; the righthand column shows the
        values associated with those attributes. You can inspect the
        values in the righthand column by double-clicking them.</para>
        <para>        Inspecting a value in the righthand column changes the
        Inspector window to display the double-clicked object. You can
        quickly navigate the fields of structured data this way,
        inspecting objects and the objects that they refer
        to. Navigation buttons at the top left of the window enable you
        to retrace your steps, backing up to return to previously-viewed
        objects, and going forward again to objects you navigated into
        previously.</para>
        <para>        You can change the contents of a structured object by
        evaluating expressions in a listener window. The refresh button
        (marked with a curved arrow) updates the display of the
        Inspector window, enabling you to quickly see the results of
        changing a data structure.</para>
      </section>
    </section>
    <section id="ide-sources">
      <title>IDE Sources</title>
      <para>Clozure CL builds the IDE from sources in the &quot;objc-bridge&quot; and
      &quot;cocoa-ide&quot; directories in the Clozure CL distribution. The IDE as a
      whole is a relatively complicated application, and is probably not
      the best place to look when you are first trying to understand how
      to build Cocoa applications. For that, you might benefit more from
      the examples in the &quot;examples/cocoa/&quot; directory. Once you are
      familiar with those examples, though, and have some experience
      building your own application features using Cocoa and the
      Objective-C bridge, you might browse through the IDE sources to
      see how it implements its features.</para>
      <para>      The search path for Clozure CL's <literal>REQUIRE</literal> feature
      includes the &quot;objc-bridge&quot; and &quot;cocoa-ide&quot; directories. You can
      load features defined in these directories by
      using <literal>REQUIRE</literal>. For example, if you want to use the
      Cocoa features of Clozure CL from a terminal session (or from an Emacs
      session using SLIME or ILISP), you can evaluate <literal>(require
        :cocoa)</literal>.</para>
    </section>
    <section id="the-application-builder">
      <title>The Application Builder</title>
      <para>One important feature of the IDE currently has no Cocoa user
      interface: the application builder. The application builder
      constructs a
      Cocoa <indexterm><primary>application bundle</primary></indexterm><glossterm linkend="application_bundle">application bundle</glossterm> that runs a Lisp image when double-clicked. You
      can use the application builder to create Cocoa applications in
      Lisp. These applications are exactly like Cocoa applications
      created with XCode and Objective-C, except that they are written
      in Lisp.</para>
      <para>To make the application builder available, evaluate the
      expression <literal>(require :build-application)</literal>. Clozure CL loads
      the required subsystems, if necessary.</para>
      <refentry id="f_build-application">
        <indexterm zone="f_build-application"><primary><literal>CCL::BUILD-APPLICATION</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::BUILD-APPLICATION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>BUILD-APPLICATION <literal>&amp;key</literal> ( name &quot;MyApplication&quot; ) ( type-string &quot;APPL&quot; ) ( creator-string &quot;OMCL&quot; ) ( directory (current-directory) ) ( copy-ide-resources t ) ( info-plist NIL ) ( nibfiles NIL ) ( main-nib-name NIL ) ( application-class 'GUI::COCOA-APPLICATION ) ( toplevel-function NIL )</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_build-application">
          <title>Description</title>
          <para>
      The <indexterm><primary><literal>CCL::BUILD-APPLICATION</literal></primary></indexterm><link linkend="f_build-application"><literal>CCL::BUILD-APPLICATION</literal></link> function constructs an
      application bundle, populates it with the files needed to satisfy
      Mac OS X that the bundle is a launchable application, and saves an
      executable Lisp image to the proper subdirectory of the
      bundle. Assuming that the saved Lisp image contains correct code,
      a user can subsequently launch the resulting Cocoa application by
      double-clicking its icon in the Finder, and the saved Lisp
      environment runs.</para>
          <para>      The keyword arguments control various aspects of application
      bundle as <literal>BUILD-APPLICATION</literal> builds it.</para>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>Specifies the application name of the
            bundle. <literal>BUILD-APPLICATION</literal> creates an application
            bundle whose name is given by this parameter, with the
            extension &quot;.app&quot; appended. For example, using the default
            value for this parameter results in a bundle named
            &quot;MyApplication.app&quot;.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>type-string</parameter></term>
                <listitem><para>Specifies type of bundle to create. You should normally
            never need to change the default value, which Mac OS X uses to
            identify application bundles.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>creator-string</parameter></term>
                <listitem><para>Specifies the <indexterm><primary>creator code</primary></indexterm><glossterm linkend="creator_code">creator code</glossterm>, which uniquely identifies the application
            under Mac OS X. The default creator code is that of Clozure CL. For
            more information about reserving and assigning creator codes,
            see
            Apple's <ulink url="http://developer.apple.com/datatype/index.html">developer
              page</ulink> on the topic.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>directory</parameter></term>
                <listitem><para>The directory in which <literal>BUILD-APPLICATION</literal>
            creates the application bundle. By default, it creates the
            bundle in the current working directory. Unless you
            use <literal>CURRENT-DIRECTORY</literal> to set the working
            directory, the bundle may be created in some unexpected place,
            so it's safest to specify a full pathname for this argument. A
            typical value might be <literal>&quot;/Users/foo/Desktop/&quot;</literal>
            (assuming, of course, that your username is &quot;foo&quot;).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>copy-ide-resources</parameter></term>
                <listitem><para>Whether to copy the resource files from the IDE's
            application bundle. By
            default, <literal>BUILD-APPLICATION</literal> copies nibfiles
            and other resources from the IDE to the newly-created
            application bundle. This option is often useful when you
            are developing a new application, because it enables your
            built application to have a fully-functional user
            interface even before you have finished designing one. By
            default, the application uses the application menu and
            other UI elements of the IDE until you specify
            otherwise. Once your application's UI is fully
            implemented, you may choose to pass <literal>NIL</literal>
            for the value of this parameter, in which case the IDE
            resources are not copied into your application
            bundle.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>info-plist</parameter></term>
                <listitem><para>A user-supplied NSDictionary object that defines the
          contents of the Info.plist file to be written to the
          application bundle. The default value
          is <literal>NIL</literal>, which specifies that the
          Info.plist from the IDE is to be used
          if <replaceable>copy-ide-resources</replaceable> is true,
          and a new dictionary created with default values is to be
          used otherwise. You can create a suitable NSDictionary
          object using the
          function <literal>make-info-dict</literal>. For details on
          the parameters to this function, see its definition in
          &quot;ccl/cocoa-ide/builder-utilities.lisp&quot;.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>nibfiles</parameter></term>
                <listitem><para>A list of pathnames, where each pathname identifies
            a <indexterm><primary>nibfile</primary></indexterm><glossterm linkend="nibfile">nibfile</glossterm> created
            with
            Apple's <indexterm><primary>InterfaceBuilder</primary></indexterm><glossterm linkend="interfacebuilder">InterfaceBuilder</glossterm>
            application. <literal>BUILD-APPLICATION</literal> copies each
            nibfile into the appropriate place in the application bundle,
            enabling the application to load user-interface elements from
            them as-needed. It is safest to provide full pathnames to the
            nibfiles in the list. Each nibfile must be in &quot;.nib&quot; format,
            not &quot;.xib&quot; format, in order that the application can load
            it.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>main-nib-name</parameter></term>
                <listitem><para>The name of
            the <indexterm><primary>nibfile</primary></indexterm><glossterm linkend="nibfile">nibfile</glossterm> to load
            initially when launching. The user-interface defined in this
            nibfile becomes the application's main interface. You must
            supply the name of a suitable nibfile for this parameter, or
            the resulting application uses the Clozure CL user
            interface.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>application-class</parameter></term>
                <listitem><para>The name of the application's CLOS class. The default
            value is the class provided by Clozure CL for graphical
            applications. Supply the name of your application class if you
            implement one. If not, Clozure CL uses the default class.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>toplevel-function</parameter></term>
                <listitem><para>The toplevel function that runs when the application
            launches. Normally the default value, which is Clozure CL's
            toplevel, works well, but in some cases you may wish to
            customize the behavior of the application's toplevel. The best
            source of information about writing your own toplevel is the
            Clozure CL source code, especially the implementations
            of <literal>TOPLEVEL-FUNCTION</literal> in
            &quot;ccl/level-1/l1-application.lisp&quot;</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <para><literal>BUILD-APPLICATION</literal> creates a folder named
      &quot;<replaceable>name</replaceable>.app&quot; in the
      directory <replaceable>directory</replaceable>. Inside that
      folder, it creates the &quot;Contents&quot; folder that Mac OS X
      application bundles are expected to contain, and populates it
      with the &quot;MacOS&quot; and &quot;Resources&quot; folders, and the &quot;Info.plist&quot;
      and &quot;PkgInfo&quot; files that must be present in a working
      application bundle. It takes the contents of the &quot;Info.plist&quot;
      and &quot;PkgInfo&quot; files from the parameters
      to <literal>BUILD-APPLICATION</literal>. If <replaceable>copy-ide-resources</replaceable>
      is true then it copies the contents of the &quot;Resources&quot; folder
      from the &quot;Resources&quot; folder of the running IDE.</para>
          <para>    The work needed to produce a running Cocoa application is
    very minimal. In fact, if you
    supply <literal>BUILD-APPLICATION</literal> with a valid nibfile and
    pathnames, it builds a running Cocoa application that displays
    your UI. It doesn't need you to write any code at all to do
    this. Of course, the resulting application doesn't do anything
    apart from displaying the UI defined in the nibfile. If you want
    your UI to accomplish anything, you need to write the code to
    handle its events. But the path to a running application with your
    UI in it is very short indeed.</para>
          <para>    Please note that <literal>BUILD-APPLICATION</literal> is a work in
    progress. It can easily build a working Cocoa application, but it
    still has limitations that may in some cases prove
    inconvenient. For example, in the current version it provides no
    easy way to specify an application delegate different from the
    default. If you find the current limitations
    of <literal>BUILD-APPLICATION</literal> too restrictive, and want to try
    extending it for your use, you can find the source code for it in
    &quot;ccl/cocoa-ide/build-application.lisp&quot;. You can see the default
    values used to populate the &quot;Info.plist&quot; file in
    &quot;ccl/cocoa-ide/builder-utilities.lisp&quot;.</para>
          <para>    For more information on how to
    use <literal>BUILD-APPLICATION</literal>, see the Currency Converter
    example in &quot;ccl/examples/cocoa/currency-converter/&quot;.</para>
        </refsect1>
      </refentry>
      <section id="running-the-application-builder-from-the-command-line">
        <title>Running the Application Builder From the Command
      Line</title>
        <para>It's possible to automate use of the application builder
        by running a call to <literal>CCL:BUILD-APPLICATION</literal>
        from the terminal command line. For example, the following
        command, entered at a shell prompt in Mac OS X's Terminal
        window, builds a working copy of the Clozure CL environment called
        &quot;Foo.app&quot;:</para>
        <programlisting>
ccl -b -e &quot;(require :cocoa)&quot; -e &quot;(require :build-application)&quot; -e &quot;(ccl::build-application :name \&quot;Foo\&quot;)&quot;
      </programlisting>
        <para>You can use the same method to automate building your
      Lisp/Cocoa applications. Clozure CL handles each Lisp expressions
      passed with a <literal>-e</literal> argument in order, so you
      can simply evaluate a sequence of Lisp expressions as in the
      above example to build your application, ending with a call
      to <literal>CCL:BUILD-APPLICATION</literal>. The call
      to <literal>CCL:BUILD-APPLICATION</literal> can process all the
      same arguments as if you evaluated it in a Listener window in
      the Clozure CL IDE.</para>
        <para>      Building a substantial Cocoa application (rather than just
      reproducing the Lisp environment using defaults, as is done in
      the above example) is likely to involve a relatively complicated
      sequence of loading source files and perhaps evaluating Lisp
      forms. You might be best served to place your command line in a
      shell script that you can more easily edit and test.</para>
        <para>        One potentially complicated issue concerns loading all
        your Lisp source files in the right order. You might consider
        using ASDF to define and load a system that includes all the
        parts of your application before
        calling <literal>CCL:BUILD-APPLICATION</literal>. ASDF is a
        &quot;another system-definition facility&quot;, a sort
        of <literal>make</literal> for Lisp, and is included in the
        Clozure CL distribution. You can read more about ASDF at the ASDF
        <ulink url="http://common-lisp.net/project/asdf/">home
        page</ulink>.</para>
        <para>        Alternatively, you could use the standard features of
        Common Lisp to load your application's files in the proper
        order.</para>
      </section>
    </section>
  </chapter>
  <chapter id="programming-with-threads">
    <title>Programming with Threads</title>
    <section id="threads-overview">
      <title>Threads Overview</title>
      <para>Clozure CL provides facilities which enable multiple threads
      of execution (<emphasis>threads</emphasis>, sometimes called
      <emphasis>lightweight processes</emphasis> or just
      <emphasis>processes</emphasis>, though the latter term shouldn't
      be confused with the OS's notion of a process) within a lisp
      session. This document describes those facilities and issues
      related to multithreaded programming in Clozure CL.</para>
      <para>      Wherever possible, I'll try to use the term &quot;thread&quot; to
      denote a lisp thread, even though many of the functions in the
      API have the word &quot;process&quot; in their name. A
      <emphasis>lisp-process</emphasis> is a lisp object (of type
      CCL:PROCESS) which is used to control and communicate with an
      underlying <emphasis>native thread</emphasis>. Sometimes, the
      distinction between these two (quite different) objects can be
      blurred; other times, it's important to maintain.</para>
      <para>      Lisp threads share the same address space, but maintain
      their own execution context (stacks and registers) and their own
      dynamic binding context.</para>
      <para>      Traditionally, Clozure CL's threads have been
      <emphasis>cooperatively scheduled</emphasis>: through a
      combination of compiler and runtime support, the currently
      executing lisp thread arranged to be interrupted at certain
      discrete points in its execution (typically on entry to a
      function and at the beginning of any looping construct). This
      interrupt occurred several dozen times per second; in response,
      a handler function might observe that the current thread had
      used up its time slice and another function (<emphasis>the lisp
        scheduler</emphasis>) would be called to find some other thread
      that was in a runnable state, suspend execution of the current
      thread, and resume execution of the newly executed thread.  The
      process of switching contexts between the outgoing and incoming
      threads happened in some mixture of Lisp and assembly language
      code; as far as the OS was concerned, there was one native
      thread running in the Lisp image and its stack pointer and other
      registers just happened to change from time to time.</para>
      <para>      Under Clozure CL's cooperative scheduling model, it was
      possible (via the use of the CCL:WITHOUT-INTERRUPTS construct)
      to defer handling of the periodic interrupt that invoked the
      lisp scheduler; it was not uncommon to use WITHOUT-INTERRUPTS to
      gain safe, exclusive access to global data structures. In some
      code (including much of Clozure CL itself) this idiom was very
      common: it was (justifiably) believed to be an efficient way of
      inhibiting the execution of other threads for a short period of
      time.</para>
      <para>      The timer interrupt that drove the cooperative scheduler
      was only able to (pseudo-)preempt lisp code: if any thread
      called a blocking OS I/O function, no other thread could be
      scheduled until that thread resumed execution of lisp code. Lisp
      library functions were generally attuned to this constraint, and
      did a complicated mixture of polling and &quot;timed blocking&quot; in an
      attempt to work around it. Needless to say, this code is
      complicated and less efficient than it might be; it meant that
      the lisp was a little busier than it should have been when it
      was &quot;doing nothing&quot; (waiting for I/O to be possible.)</para>
      <para>      For a variety of reasons - better utilization of CPU
      resources on single and multiprocessor systems and better
      integration with the OS in general - threads in Clozure CL 0.14 and
      later are <emphasis>preemptively scheduled. </emphasis>In this
      model, lisp threads are native threads and all scheduling
      decisions involving them are made by the OS kernel. (Those
      decisions might involve scheduling multiple lisp threads
      simultaneously on multiple processors on SMP systems.) This
      change has a number of subtle effects:</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>it is possible for two (or more) lisp threads to be
	      executing simultaneously, possibly trying to access and/or
	      modify the same data structures. Such access really should
	      have been coordinated through the use of synchronization
	      objects regardless of the scheduling modeling effect;
	      preemptively scheduled threads increase the chance of things
	      going wrong at the wrong time and do not offer
	      lightweight alternatives to the use of those synchronization
	      objects.</para></listitem>
          <listitem><para>even on a single-processor system, a context switch
	      can happen on any instruction boundary. Since (in general)
	      other threads might allocate memory, this means that a GC can
	      effectively take place at any instruction boundary. That's
	      mostly an issue for the compiler and runtime system to be
	      aware of, but it means that certain practices(such as trying
	      to pass the address of a lisp object to foreign code)that
	      were always discouraged are now discouraged
	      ... vehemently.</para></listitem>
          <listitem><para>there is no simple and efficient way to &quot;inhibit the
	      scheduler&quot;or otherwise gain exclusive access to the entire
	      CPU.</para></listitem>
          <listitem><para>There are a variety of simple and efficient ways
	      to synchronize access to particular data
	      structures.</para></listitem>
        </itemizedlist>
      </blockquote>
      <para>As a broad generalization: code that's been aggressively
      tuned to the constraints of the cooperative scheduler may need
      to be redesigned to work well with the preemptive scheduler (and
      code written to run under Clozure CL's interface to the native
      scheduler may be less portable to other CL implementations, many
      of which offer a cooperative scheduler and an API similar to
      Clozure CL (&lt; 0.14) 's.) At the same time, there's a large
      overlap in functionality in the two scheduling models, and it'll
      hopefully be possible to write interesting and useful MP code
      that's largely independent of the underlying scheduling
      details.</para>
      <para>      The keyword :OPENMCL-NATIVE-THREADS is on *FEATURES* in
      0.14 and later and can be used for conditionalization where
      required.</para>
    </section>
    <section id="intentionally-missing-functionality">
      <title>(Intentionally) Missing Functionality</title>
      <para>Much of the functionality described above is similar to
      that provided by Clozure CL's cooperative scheduler, some other
      parts of which make no sense in a native threads
      implementation.</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>PROCESS-RUN-REASONS and PROCESS-ARREST-REASONS were
	      SETFable process attributes; each was just a list of
	      arbitrary tokens. A thread was eligible for scheduling
	      (roughly equivalent to being &quot;enabled&quot;) if its arrest-reasons
	      list was empty and its run-reasons list was not. I don't
	      think that it's appropriate to encourage a programming style
	      in which otherwise runnable threads are enabled and disabled
	      on a regular basis (it's preferable for threads to wait for
	      some sort of synchronization event to occur if they can't
	      occupy their time productively.)</para></listitem>
          <listitem><para>There were a number of primitives for maintaining
	      process queues;that's now the OS's job.</para></listitem>
          <listitem><para>Cooperative threads were based on coroutining
	      primitives associated with objects of type
	      STACK-GROUP. STACK-GROUPs no longerexist.</para></listitem>
        </itemizedlist>
      </blockquote>
    </section>
    <section id="implementation-decisions-and-open-questions">
      <title>Implementation Decisions and Open Questions</title>
      <section id="thread-stack-sizes">
        <title>Thread Stack Sizes</title>
        <para>When you use MAKE-PROCESS to create a thread, you can
        specify a stack size. Clozure CL does not impose a limit on the stack
        size you choose, but there is some evidence that choosing a
        stack size larger than the operating system's limit can cause
        excessive paging activity, at least on some operating
        systems.</para>
        <para>        The maximum stack size is operating-system-dependent. You
        can use shell commands to determine what it is on your
        platform. In bash, use &quot;ulimit -s -H&quot; to find the limit; in
        tcsh, use &quot;limit -h s&quot;.</para>
        <para>        This issue does not affect programs that create threads
        using the default stack size, which you can do either by
        specifying no value for the :stack-size argument to
        MAKE-PROCESS, or by specifying the value
        CCL::*default-control-stack-size*.</para>
        <para>        If your program creates threads with a specified stack size,
        and that size is larger than the OS-specified limit, you may want
        to consider reducing the stack size in order to avoid possible
        excessive paging activity.</para>
      </section>
      <section id="as-of-august-2003">
        <title> As of August 2003:</title>
        <blockquote>
          <itemizedlist>
            <listitem><para>It's not clear that exposing
	        PROCESS-SUSPEND/PROCESS-RESUME is a good idea: it's not clear
	        that they offer ways to win, and it's clear that they offer
	        ways to lose.</para></listitem>
            <listitem><para>It has traditionally been possible to reset and enable
	        a process that's &quot;exhausted&quot; . (As used here, the
	        term &quot;exhausted&quot; means that the process's initial function
	        has run and returned and the underlying native thread has
	        been deallocated.) One of the principal uses of PROCESS-RESET
	        is to &quot;recycle&quot; threads; enabling an exhausted process
	        involves creating a new native thread (and stacks and
	        synchronization objects and ...),and this is the sort of
	        overhead that such a recycling scheme is seeking to avoid. It
	        might be worth trying to tighten things up and declare that
	        it's an error to apply PROCESS-ENABLE to an exhausted thread
	        (and to make PROCESS-ENABLE detect this error.)</para></listitem>
            <listitem><para>When native threads that aren't created by Clozure CL
	        first call into lisp, a &quot;foreign process&quot; is created, and
	        that process is given its own set of initial bindings and set
	        up to look mostly like a process that had been created by
	        MAKE-PROCESS. The life cycle of a foreign process is
	        certainly different from that of a lisp-created one: it
	        doesn't make sense to reset/preset/enable a foreign process,
	        and attempts to perform these operations should be
	        detected and treated as errors.</para></listitem>
          </itemizedlist>
        </blockquote>
      </section>
    </section>
    <section id="porting-code-from-the-old-thread-model">
      <title>Porting Code from the Old Thread Model</title>
      <para>Older versions of Clozure CL used what are often called
      &quot;user-mode threads&quot;, a less versatile threading model which does
      not require specific support from the operating system.  This
      section discusses how to port code which was written for that
      mode.</para>
      <para>      It's hard to give step-by-step instructions; there are certainly
      a few things that one should look at carefully:</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>It's wise to be suspicious of most uses
	      of WITHOUT-INTERRUPTS; there may be exceptions, but
	      WITHOUT-INTERRUPTS is often used as shorthand for
	      WITH-APPROPRIATE-LOCKING. Determining what type of locking
	      is appropriate and writing the code to implement it is
	      likely to be straightforward and simple most of the
	      time.</para></listitem>
          <listitem><para>I've only seen one case where a process's &quot;run reasons&quot;
	      were used to communicate information as well as to control
	      execution; I don't think that this is a common idiom, but may
	      be mistaken about that.
	    </para></listitem>
          <listitem><para>It's certainly possible that programs written
	      for cooperatively scheduled lisps that have run reliably for
	      a long time have done so by accident: resource-contention
	      issues tend to be timing-sensitive, and decoupling thread
	      scheduling from lisp program execution affects timing. I know
	      that there is or was code in both Clozure CL and commercial MCL
	      that was written under the explicit assumption that certain
	      sequences of open-coded operations were uninterruptable; it's
	      certainly possible that the same assumptions have been made
	      (explicitly or otherwise) by application developers.</para></listitem>
        </itemizedlist>
      </blockquote>
    </section>
    <section id="background-terminal-input">
      <title>Background Terminal Input</title>
      <section id="overview_in_background-terminal-input">
        <title>Overview</title>
        <para>
	    Unless and until Clozure CL provides alternatives (via window
	    streams, telnet streams, or some other mechanism) all lisp
	    processes share a common *TERMINAL-IO* stream (and therefore
	    share *DEBUG-IO*, *QUERY-IO*, and other standard and
	    internal interactive streams.)</para>
        <para>	    It's anticipated that most lisp processes other than
	    the &quot;Initial&quot; process run mostly in the background. If a
	    background process writes to the output side of
	    *TERMINAL-IO*, that may be a little messy and a little
	    confusing to the user, but it shouldn't really be
	    catastrophic. All I/O to Clozure CL's buffered streams goes
	    thru a locking mechanism that prevents the worst kinds of
	    resource-contention problems.</para>
        <para>	    Although the problems associated with terminal output
	    from multiple processes may be mostly cosmetic, the question
	    of which process receives input from the terminal is likely
	    to be a great deal more important. The stream locking
	    mechanisms can make a confusing situation even worse:
	    competing processes may &quot;steal&quot; terminal input from each
	    other unless locks are held longer than they otherwise need
	    to be, and locks can be held longer than they need to be (as
	    when a process is merely waiting for input to become
	    available on an underlying file descriptor).</para>
        <para>	    Even if background processes rarely need to
	    intentionally read input from the terminal, they may still
	    need to do so in response to errors or other unanticipated
	    situations. There are tradeoffs involved in any solution to
	    this problem. The protocol described below allows background
	    processes which follow it to reliably prompt for and receive
	    terminal input. Background processes which attempt to
	    receive terminal input without following this protocol will
	    likely hang indefinitely while attempting to do so. That's
	    certainly a harsh tradeoff, but since attempts to read
	    terminal input without following this protocol only worked
	    some of the time anyway, it doesn't seem to be an
	    unreasonable one.</para>
        <para>	    In the solution described here (and introduced in
	    Clozure CL 0.9), the internal stream used to provide terminal
	    input is always locked by some process (the &quot;owning&quot;
	    process.) The initial process (the process that typically
	    runs the read-eval-print loop) owns that stream when it's
	    first created. By using the macro WITH-TERMINAL-INPUT,
	    background processes can temporarily obtain ownership of the
	    terminal and relinquish ownership to the previous owner when
	    they're done with it.</para>
        <para>	    In Clozure CL, BREAK, ERROR, CERROR, Y-OR-N-P,
	    YES-OR-NO-P, and CCL:GET-STRING- FROM-USER are all defined
	    in terms of WITH-TERMINAL-INPUT, as are the :TTY
	    user-interfaces to STEP and INSPECT.</para>
      </section>
      <section id="an-example">
        <title>An example</title>
        <programlisting><para>
? Welcome to Clozure CL Version (Beta: linux) 0.9!
?</para><para>? (process-run-function &quot;sleeper&quot; #'(lambda () (sleep 5) (break &quot;broken&quot;)))
#&lt;PROCESS sleeper(1) [Enabled] #x3063B33E&gt;</para><para>?
;;
;; Process sleeper(1) needs access to terminal input.
;;
      </para></programlisting>
        <para>This example was run under ILISP; ILISP often gets confused if one
	    tries to enter input and &quot;point&quot; doesn't follow a prompt.
	    Entering a &quot;simple&quot; expression at this point gets it back in
	    synch; that's otherwise not relevant to this example.</para>
        <programlisting>
()
NIL
? (:y 1)
;;
;; process sleeper(1) now controls terminal input
;;
&gt; Break in process sleeper(1): broken
&gt; While executing: #&lt;Anonymous Function #x3063B276&gt;
&gt; Type :GO to continue, :POP to abort.
&gt; If continued: Return from BREAK.
Type :? for other options.
1 &gt; :b
(30C38E30) : 0 &quot;Anonymous Function #x3063B276&quot; 52
(30C38E40) : 1 &quot;Anonymous Function #x304984A6&quot; 376
(30C38E90) : 2 &quot;RUN-PROCESS-INITIAL-FORM&quot; 340
(30C38EE0) : 3 &quot;%RUN-STACK-GROUP-FUNCTION&quot; 768
1 &gt; :pop
;;
;; control of terminal input restored to process Initial(0)
;;
?
      </programlisting>
      </section>
      <section id="a-more-elaborate-example.">
        <title>A more elaborate example.</title>
        <para>If a background process (&quot;A&quot;) needs access to the terminal
	    input stream and that stream is owned by another background process
	    (&quot;B&quot;), process &quot;A&quot; announces that fact, then waits until
	    the initial process regains control.</para>
        <programlisting><para>
? Welcome to Clozure CL Version (Beta: linux) 0.9!
?</para><para>? (process-run-function &quot;sleep-60&quot; #'(lambda () (sleep 60) (break &quot;Huh?&quot;)))
#&lt;PROCESS sleep-60(1) [Enabled] #x3063BF26&gt;</para><para>? (process-run-function &quot;sleep-5&quot; #'(lambda () (sleep 5) (break &quot;quicker&quot;)))
#&lt;PROCESS sleep-5(2) [Enabled] #x3063D0A6&gt;</para><para>?       ;;
;; Process sleep-5(2) needs access to terminal input.
;;
()
NIL</para><para>? (:y 2)
;;
;; process sleep-5(2) now controls terminal input
;;
&gt; Break in process sleep-5(2): quicker
&gt; While executing: #x3063CFDE&gt;
&gt; Type :GO to continue, :POP to abort.
&gt; If continued: Return from BREAK.
Type :? for other options.
1 &gt;     ;; Process sleep-60(1) will need terminal access when
;; the initial process regains control of it.
;;
()
NIL
1 &gt; :pop
;;
;; Process sleep-60(1) needs access to terminal input.
;;
;;
;; control of terminal input restored to process Initial(0)
;;</para><para>? (:y 1)
;;
;; process sleep-60(1) now controls terminal input
;;
&gt; Break in process sleep-60(1): Huh?
&gt; While executing: #x3063BE5E&gt;
&gt; Type :GO to continue, :POP to abort.
&gt; If continued: Return from BREAK.
Type :? for other options.
1 &gt; :pop
;;
;; control of terminal input restored to process Initial(0)
;;</para><para>?
      </para></programlisting>
      </section>
      <section id="summary_in_background-terminal-input">
        <title>Summary</title>
        <para>This scheme is certainly not bulletproof: imaginative
	    use of PROCESS-INTERRUPT and similar functions might be able
	    to defeat it and deadlock the lisp, and any scenario where
	    several background processes are clamoring for access to the
	    shared terminal input stream at the same time is likely to be
	    confusing and chaotic. (An alternate scheme, where the input
	    focus was magically granted to whatever thread the user was
	    thinking about, was considered and rejected due to technical
	    limitations.)</para>
        <para>	    The longer-term fix would probably involve using network or
	    window-system streams to give each process unique instances of
	    *TERMINAL-IO*.</para>
        <para>        Existing code that attempts to read from *TERMINAL-IO*
        from a background process will need to be changed to use
        WITH-TERMINAL-INPUT.  Since that code was probably not working
        reliably in previous versions of Clozure CL, this requirement
        doesn't seem to be too onerous.</para>
        <para>        Note that WITH-TERMINAL-INPUT both requests ownership of
        the terminal input stream and promises to restore that
        ownership to the initial process when it's done with it. An ad
        hoc use of READ or READ-CHAR doesn't make this promise; this
        is the rationale for the restriction on the :Y command.</para>
      </section>
    </section>
    <section id="the-threads-which-clozure-cl-uses-for-its-own-purposes">
      <title>The Threads which Clozure CL Uses for Its Own Purposes</title>
      <para>
      In the &quot;tty world&quot;, Clozure CL starts out with 2 lisp-level threads:</para>
      <programlisting>
? :proc
1 : -&gt; listener     [Active]
0 :    Initial      [Active]
    </programlisting>
      <para>If you look at a running Clozure CL with a debugging tool,
      such as GDB, or Apple's Thread Viewer.app, you'll see an
      additional kernel-level thread on Darwin; this is used by the
      Mach exception-handling mechanism.</para>
      <para>      The initial thread, conveniently named &quot;initial&quot;, is the
      one that was created by the operating system when it launched
      Clozure CL.  It maps the heap image into memory, does some
      Lisp-level initialization, and, when the Cocoa IDE isn't being
      used, creates the thread &quot;listener&quot;, which runs the top-level
      loop that reads input, evaluates it, and prints the
      result.</para>
      <para>      After the listener thread is created, the initial thread
      does &quot;housekeeping&quot;: it sits in a loop, sleeping most of the
      time and waking up occasionally to do &quot;periodic tasks&quot;.  These
      tasks include forcing output on specified interactive streams,
      checking for and handling control-C interrupts, etc.  Currently,
      those tasks also include polling for the exit status of external
      processes and handling some kinds of I/O to and from those
      processes.</para>
      <para>      In this environment, the initial thread does these
      &quot;housekeeping&quot; activities as necessary, until
      <literal>ccl:quit</literal> is called;
      <literal>quit</literal>ting interrupts the initial thread, which
      then ends all other threads in as orderly a fashion as possible
      and calls the C function <literal>#_exit</literal>.</para>
      <para>      The short-term plan is to handle each external-process in
      a dedicated thread; the worst-case behavior of the current
      scheme can involve busy-waiting and excessive CPU utilization
      while waiting for an external process to terminate in some
      cases.</para>
      <para>      The Cocoa features use more threads.  Adding a Cocoa
      listener creates two threads:</para>
      <programlisting>
      ? :proc
      3 : -&gt; Listener     [Active]
      2 :    housekeeping  [Active]
      1 :    listener     [Active]
      0 :    Initial      [Active]
    </programlisting>
      <para>The Cocoa event loop has to run in the initial thread;
      when the event loop starts up, it creates a new thread to do the
      &quot;housekeeping&quot; tasks which the initial thread would do in the
      terminal-only mode.  The initial thread then becomes the one to
      receive all Cocoa events from the window server; it's the only
      thread which can.</para>
      <para>      It also creates one &quot;Listener&quot; (capital-L) thread for each
      listener window, with a lifetime that lasts as long as the
      thread does.  So, if you open a second listener, you'll see five
      threads all together:</para>
      <programlisting>
      ? :proc
      4 : -&gt; Listener-2   [Active]
      3 :    Listener     [Active]
      2 :    housekeeping  [Active]
      1 :    listener     [Active]
      0 :    Initial      [Active]
    </programlisting>
      <para>Unix signals, such as SIGINT (control-C), invoke a handler
      installed by the Lisp kernel.  Although the OS doesn't make any
      specific guarantee about which thread will receive the signal,
      in practice, it seems to be the initial thread.  The handler
      just sets a flag and returns; the housekeeping thread (which may
      be the initial thread, if Cocoa's not being used) will check for
      the flag and take whatever action is appropriate to the
      signal.</para>
      <para>      In the case of SIGINT, the action is to enter a break
      loop, by calling on the thread being interrupted.  When there's
      more than one Lisp listener active, it's not always clear what
      thread that should be, since it really depends on the user's
      intentions, which there's no way to divine programmatically.  To
      make its best guess, the handler first checks whether the value
      of <literal>ccl:*interactive-abort-process*</literal> is a
      thread, and, if so, uses it.  If that fails, it chooses the
      thread which currently &quot;owns&quot; the default terminal input stream;
      see .</para>
      <para>      In the bleeding-edge version of the Cocoa support which is
      based on Hemlock, an Emacs-like editor, each editor window has a
      dedicated thread associated with it.  When a keypress event
      comes in which affects that specific window the initial thread
      sends it to the window's dedicated thread.  The dedicated thread
      is responsible for trying to interpret keypresses as Hemlock
      commands, applying those commands to the active buffer; it
      repeats this in a loop, until the window closes.  The initial
      thread handles all other events, such as mouse clicks and
      drags.</para>
      <para>      This thread-per-window scheme makes many things simpler,
      including the process of entering a &quot;recursive command loop&quot; in
      commands like &quot;Incremental Search Forward&quot;, etc.  (It might be
      possible to handle all Hemlock commands in the Cocoa event
      thread, but these &quot;recursive command loops&quot; would have to
      maintain a lot of context/state information; threads are a
      straightforward way of maintaining that information.)</para>
      <para>      Currently (August 2004), when a dedicated thread needs to
      alter the contents of the buffer or the selection, it does so by
      invoking methods in the initial thread, for synchronization
      purposes, but this is probably overkill and will likely be
      replaced by a more efficient scheme in the future.</para>
      <para>      The per-window thread could probably take more
      responsibility for drawing and handling the screen than it
      currently does; -something- needs to be done to buffer screen
      updates a bit better in some cases: you don't need to see
      everything that happens during something like indentation; you
      do need to see the results...</para>
      <para>      When Hemlock is being used, listener windows are editor
      windows, so in addition to each &quot;Listener&quot; thread, you should
      also see a thread which handles Hemlock command
      processing.</para>
      <para>      The Cocoa runtime may make additional threads in certain
      special situations; these threads usually don't run lisp code,
      and rarely if ever run much of it.</para>
    </section>
    <section id="threads-dictionary">
      <title>Threads Dictionary</title>
      <refentry id="f_all-processes">
        <indexterm zone="f_all-processes"><primary><literal>ALL-PROCESSES</literal></primary></indexterm>
        <refnamediv>
          <refname>ALL-PROCESSES</refname>
          <refpurpose>Obtain a fresh list of all known Lisp
	      threads.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>all-processes =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_all-processes">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>a list of all lisp processes (threads)
		        known to Clozure CL.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_all-processes">
          <title>Description</title>
          <para>Returns a list of all lisp processes (threads) known
	      to Clozure CL as of
	      the precise instant it's called. It's safe to traverse
	      this list and to modify the cons cells that comprise that list
	      (it's freshly consed.) Since other threads can create and kill
	      threads at any time, there's generally no way to get an
	      &quot;accurate&quot; list of all threads, and (generally) no
	      sense in which such a list can be accurate.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_all-processes">
          <title>See Also</title>
          <para><indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_make-process">
        <indexterm zone="f_make-process"><primary><literal>MAKE-PROCESS</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-PROCESS</refname>
          <refpurpose>Creates and returns a new process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-process name &amp;key persistent priority class initargs stack-size vstack-size tstack-size initial-bindings use-standard-initial-bindings =&gt; process</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_make-process">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>a string, used to identify the process.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>persistent</parameter></term>
                <listitem><para>if true, requests that information about the process
		        be retained by SAVE-APPLICATION so that an equivalent
		        process can be restarted when a saved image is run.  The
		        default is nil.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>priority</parameter></term>
                <listitem><para>ignored.  It
		        shouldn't be ignored of course, but there are
		        complications on some platforms.  The default is 0.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>class</parameter></term>
                <listitem><para>the class of process object to create;
		        should be a subclass of CCL:PROCESS.  The default is
		        CCL:PROCESS.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initargs</parameter></term>
                <listitem><para>Any additional initargs to pass to MAKE-INSTANCE. The default is ().</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>stack-size</parameter></term>
                <listitem><para>the size, in bytes, of the newly-created process's
		        control stack; used for foreign function calls and to save
		        function return address context.  The default is
		        CCL:*DEFAULT-CONTROL-STACK-SIZE*.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>vstack-size</parameter></term>
                <listitem><para>the size, in bytes, of the newly-created process's
		        value stack; used for lisp function arguments, local
		        variables, and other stack-allocated lisp objects.
		        The default is CCL:*DEFAULT-VALUE-STACK-SIZE*.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>tstack-size</parameter></term>
                <listitem><para>the size, in bytes, of the newly-created process's
		        temp stack; used for the allocation of dynamic-extent
		        objects.  The default is CCL:*DEFAULT-TEMP-STACK-SIZE*.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>use-standard-initial-bindings</parameter></term>
                <listitem><para>when true, the global &quot;standard initial
		        bindings&quot; are put into effect in the new thread before. See
		        DEF-STANDARD-INITIAL-BINDING.  &quot;standard&quot; initial bindings
		        are put into effect before any bindings specified by
		        :initial-bindings are.  The default is t.</para><para>                       <emphasis>This option is deprecated: the correct
                      behavior of many Clozure CL components depends on thread-local
                      bindings of many special variables being in effect.</emphasis></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initial-bindings</parameter></term>
                <listitem><para>an alist of (<parameter>symbol</parameter> .
		        <parameter>valueform</parameter>) pairs, which can be
		        used to initialize special variable bindings in the new
		        thread. Each <parameter>valueform</parameter> is used to
		        compute the value of a new binding of
		        <parameter>symbol</parameter> in the execution environment of
		        the newly-created thread.  The default is nil.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>the newly-created process.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-process">
          <title>Description</title>
          <para>Creates and returns a new lisp process (thread) with the
	      specified attributes. <parameter>process</parameter> will not begin
	      execution immediately; it will need to be
	      <emphasis>preset</emphasis> (given
	      an initial function to run, as by
	      <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>) and
	      <emphasis>enabled</emphasis>
	      (allowed to execute, as by <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>)
	      before it's able to actually do anything.</para>
          <para>If <parameter>valueform</parameter> is a function, it is
	      called, with no arguments, in the execution environment of the
	      newly-created thread; the primary value it returns is used for
	      the binding of the corresponding <parameter>symbol</parameter>.</para>
          <para>	      Otherwise, <parameter>valueform</parameter> is evaluated in the
	      execution
	      environment of the newly-created thread, and the resulting value
	      is used.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_make-process">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>, <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>, <indexterm><primary><literal>PROCESS-RUN-FUNCTION</literal></primary></indexterm><link linkend="f_process-run-function"><literal>PROCESS-RUN-FUNCTION</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-suspend">
        <indexterm zone="f_process-suspend"><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-SUSPEND</refname>
          <refpurpose>Suspends a specified process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-suspend process =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-suspend">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>T if <parameter>process</parameter> had been runnable
		        and is now suspended; NIL otherwise.  That is, T if
		        <parameter>process</parameter>'s
		        <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link>
		        transitioned from 0 to 1.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-suspend">
          <title>Description</title>
          <para>Suspends <parameter>process</parameter>, preventing it from
	      running, and stopping it if it was already running. This is a fairly
	      expensive operation, because it involves a few
	      calls to the OS.  It also risks creating deadlock if used
	      improperly, for instance, if the process being suspended owns a
	      lock or other resource which another process will wait for.</para>
          <para>
	      Each
	      call to <indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link> must be reversed by
	      a matching call to <indexterm><primary><literal>PROCESS-RESUME</literal></primary></indexterm><link linkend="f_process-resume"><literal>PROCESS-RESUME</literal></link>
	      before <parameter>process</parameter> is able to run.  What
	      <indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link> actually does is increment
	      the <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link> of
	      <parameter>process</parameter>.
	    </para>
          <para>A process can't suspend itself, though this once
	    worked and this documentation claimed has claimed that it
	    did.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-suspend">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-RESUME</literal></primary></indexterm><link linkend="f_process-resume"><literal>PROCESS-RESUME</literal></link>, <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-suspend">
          <title>Notes</title>
          <para><indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link> was previously called
	      <literal>process-disable</literal>.
	      <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>
	      now names a function for which there is no
	      obvious inverse, so <literal>process-disable</literal>
	      is no longer
	      defined.</para>
        </refsect1>
      </refentry>
      <refentry id="f_process-resume">
        <indexterm zone="f_process-resume"><primary><literal>PROCESS-RESUME</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-RESUME</refname>
          <refpurpose>Resumes a specified process which had previously
	      been suspended by process-suspend.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-resume process =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-resume">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>T if <parameter>process</parameter> had been suspended
		        and is now runnable; NIL otherwise.  That is, T if
		        <parameter>process</parameter>'s
		        <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link>
		        transitioned from  to 0.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-resume">
          <title>Description</title>
          <para>Undoes the effect of a previous call to
	      <indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link>; if
	      all such calls are undone, makes the process runnable. Has no
	      effect if the process is not suspended.  What
	      <indexterm><primary><literal>PROCESS-RESUME</literal></primary></indexterm><link linkend="f_process-resume"><literal>PROCESS-RESUME</literal></link> actually does is decrement
	      the <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link> of
	      <parameter>process</parameter>, to a minimum of 0.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-resume">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link>, <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-resume">
          <title>Notes</title>
          <para>
	      This was previously called PROCESS-ENABLE;
	      <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link> now does something slightly
	      different.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_process-suspend-count">
        <indexterm zone="f_process-suspend-count"><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-SUSPEND-COUNT</refname>
          <refpurpose>Returns the number of currently-pending suspensions
	      applicable to a given process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-suspend-count process =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-suspend-count">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>The number of &quot;outstanding&quot;
		        <indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link> calls on
		        <parameter>process</parameter>, or NIL if
		        <parameter>process</parameter> has expired.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-suspend-count">
          <title>Description</title>
          <para>An &quot;outstanding&quot; <indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link> call
	      is one which has not yet been reversed by a call to
	      <indexterm><primary><literal>PROCESS-RESUME</literal></primary></indexterm><link linkend="f_process-resume"><literal>PROCESS-RESUME</literal></link>.  A process expires when
	      its initial function returns, although it may later be
	      reset.</para>
          <para>A process is <emphasis>runnable</emphasis> when it has a
	      <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link> of 0, has been
	      preset as by <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>, and has been
	      enabled as by <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>.  Newly-created
	      processes have a <indexterm><primary><literal>PROCESS-SUSPEND-COUNT</literal></primary></indexterm><link linkend="f_process-suspend-count"><literal>PROCESS-SUSPEND-COUNT</literal></link> of
	      0.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-suspend-count">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-SUSPEND</literal></primary></indexterm><link linkend="f_process-suspend"><literal>PROCESS-SUSPEND</literal></link>, <indexterm><primary><literal>PROCESS-RESUME</literal></primary></indexterm><link linkend="f_process-resume"><literal>PROCESS-RESUME</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-preset">
        <indexterm zone="f_process-preset"><primary><literal>PROCESS-PRESET</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-PRESET</refname>
          <refpurpose>Sets the initial function and arguments of a specified
	      process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-preset process function <literal>&amp;rest</literal> args =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-preset">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>function</parameter></term>
                <listitem><para>a function, designated by itself or by a symbol
		        which names it.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>args</parameter></term>
                <listitem><para>a list of values, appropriate as arguments to
		        <parameter>function</parameter>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>undefined.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-preset">
          <title>Description</title>
          <para>Typically used to initialize a newly-created or newly-reset
	      process, setting things up so that when <parameter>process</parameter>
	      becomes enabled, it will begin execution by
	      applying <parameter>function</parameter> to <parameter>args</parameter>.
	      <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link> does not enable
	      <parameter>process</parameter>,
	      although a process must be <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>
	      before it can be enabled.  Processes are normally enabled by
	      <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>.
	    </para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-preset">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>, <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>, <indexterm><primary><literal>PROCESS-RUN-FUNCTION</literal></primary></indexterm><link linkend="f_process-run-function"><literal>PROCESS-RUN-FUNCTION</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-enable">
        <indexterm zone="f_process-enable"><primary><literal>PROCESS-ENABLE</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-ENABLE</refname>
          <refpurpose>Begins executing the initial function of a specified
	      process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-enable process <literal>&amp;optional</literal> timeout</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-enable">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>timeout</parameter></term>
                <listitem><para>a time interval in seconds.  May be any
		        non-negative real number the <indexterm><primary><literal>FLOOR</literal></primary></indexterm><literal>FLOOR</literal> of
		        which fits in 32 bits.  The default is 1.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>undefined.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-enable">
          <title>Description</title>
          <para>Tries to begin the execution of <parameter>process</parameter>.
	      An error is signaled if <parameter>process</parameter> has never
	      been <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>.  Otherwise,
	      <parameter>process</parameter> invokes its initial function.
	    </para>
          <para><indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link> attempts to
	      synchronize with <parameter>process</parameter>, which is presumed
	      to be reset or in the act of resetting itself.  If this attempt
	      is not successful within the time interval specified by
	      <parameter>timeout</parameter>, a continuable error is signaled,
	      which offers the opportunity to continue waiting.</para>
          <para>A process cannot meaningfully attempt to enable itself.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-enable">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>, <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>, <indexterm><primary><literal>PROCESS-RUN-FUNCTION</literal></primary></indexterm><link linkend="f_process-run-function"><literal>PROCESS-RUN-FUNCTION</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-enable">
          <title>Notes</title>
          <para>It would be nice to have more discussion of what it means
	      to synchronize with the process.</para>
        </refsect1>
      </refentry>
      <refentry id="f_process-run-function">
        <indexterm zone="f_process-run-function"><primary><literal>PROCESS-RUN-FUNCTION</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-RUN-FUNCTION</refname>
          <refpurpose>Creates a process, presets it, and enables it.
	    </refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-run-function process-specifier function <literal>&amp;rest</literal> args =&gt; process</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-run-function">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process-specifier</parameter></term>
                <listitem><para><parameter>name</parameter> | 
		        (<literal>&amp;key</literal> <parameter>name</parameter><parameter>persistent</parameter><parameter>priority</parameter><parameter>class</parameter><parameter>initargs</parameter><parameter>stack-size</parameter><parameter>vstack-size</parameter><parameter>tstack-size</parameter>)
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>a string, used to identify the process.
		        Passed to <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>function</parameter></term>
                <listitem><para>a function, designated by itself or by a symbol
		        which names it.  Passed to
		        <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>persistent</parameter></term>
                <listitem><para>a boolean, passed to <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>priority</parameter></term>
                <listitem><para>ignored.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>class</parameter></term>
                <listitem><para>a subclass of CCL:PROCESS.  Passed to
		        <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initargs</parameter></term>
                <listitem><para>a list of any additional initargs to pass to
		        <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>stack-size</parameter></term>
                <listitem><para>a size, in bytes.  Passed to
		        <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>vstack-size</parameter></term>
                <listitem><para>a size, in bytes.  Passed to
		        <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>tstack-size</parameter></term>
                <listitem><para>a size, in bytes.  Passed to
		        <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>the newly-created process.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-run-function">
          <title>Description</title>
          <para>Creates a lisp process (thread) via
	      <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>,
	      presets it via <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>, and
	      enables it via <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>.  This means
	      that <parameter>process</parameter> will immediately begin to
	      execute.
	      <indexterm><primary><literal>PROCESS-RUN-FUNCTION</literal></primary></indexterm><link linkend="f_process-run-function"><literal>PROCESS-RUN-FUNCTION</literal></link> is
	      the simplest way to create and run a process.
	    </para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-run-function">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link>, <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>, <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-interrupt">
        <indexterm zone="f_process-interrupt"><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-INTERRUPT</refname>
          <refpurpose>Arranges for the target process to invoke a
	      specified function at some point in the near future, and then
	      return to what it was doing.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-interrupt process function <literal>&amp;rest</literal> args =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-interrupt">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>function</parameter></term>
                <listitem><para>a function.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>args</parameter></term>
                <listitem><para>a list of values, appropriate as arguments to
		        <parameter>function</parameter>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the result of applying <parameter>function</parameter>
		        to <parameter>args</parameter> if <parameter>process</parameter>
		        is the <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link>, otherwise
		        NIL.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-interrupt">
          <title>Description</title>
          <para>Arranges for <parameter>process</parameter>
	      to apply <parameter>function</parameter> to <parameter>args</parameter> at
	      some point in the near future (interrupting whatever
	      <parameter>process</parameter>
	      was doing.) If <parameter>function</parameter> returns normally,
	      <parameter>process</parameter> resumes
	      execution at the point at which it was interrupted.</para>
          <para>	      <parameter>process</parameter> must be in an enabled state in
	      order to respond
	      to a <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link> request.  It's
	      perfectly legal for a process to call
	      <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link> on itself.</para>
          <para>	      <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link>
	      uses asynchronous POSIX signals to interrupt threads. If the
	      thread being interrupted is executing lisp code, it can
	      respond to the interrupt almost immediately (as soon as it
	      has finished pseudo-atomic operations like consing and
	      stack-frame initialization.)</para>
          <para>	      If the interrupted thread is
	      blocking in a system call, that system call is aborted by
	      the signal and the interrupt is handled on return.</para>
          <para>	      It is
	      still difficult to reliably interrupt arbitrary foreign code
	      (that may be stateful or otherwise non-reentrant); the
	      interrupt request is handled when such foreign code returns
	      to or enters lisp.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-interrupt">
          <title>See Also</title>
          <para><indexterm><primary><literal>WITHOUT-INTERRUPTS</literal></primary></indexterm><link linkend="m_without-interrupts"><literal>WITHOUT-INTERRUPTS</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-interrupt">
          <title>Notes</title>
          <para>It would probably be better for <parameter>result</parameter>
	      to always be NIL, since the present behavior is inconsistent.</para>
          <para>	      <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link> works by sending signals
	      between threads, via the C function
	      <literal>#_pthread_signal</literal>.  It could be argued
	      that it should be done in one of several possible other ways
	      under
	      Darwin, to make it practical to asynchronously interrupt
	      things which make heavy use of the Mach nanokernel.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="v_current-process">
        <indexterm zone="v_current-process"><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm>
        <refnamediv>
          <refname>*CURRENT-PROCESS*</refname>
          <refpurpose>Bound in each process, to that process
	      itself.</refpurpose>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*CURRENT-PROCESS*</synopsis></refsynopsisdiv>
        <refsect1 id="value-type_in_v_current-process">
          <title>Value Type</title>
          <para>A lisp process (thread).</para>
        </refsect1>
        <refsect1 id="initial-value_in_v_current-process">
          <title>Initial Value</title>
          <para>Bound separately in each process, to that process itself.
	    </para>
        </refsect1>
        <refsect1 id="description_in_v_current-process">
          <title>Description</title>
          <para>Used when lisp code needs to find out what process it is
	      executing in.  Shouldn't be set by user code.</para>
        </refsect1>
        <refsect1 id="see-also_in_v_current-process">
          <title>See Also</title>
          <para><indexterm><primary><literal>ALL-PROCESSES</literal></primary></indexterm><link linkend="f_all-processes"><literal>ALL-PROCESSES</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-reset">
        <indexterm zone="f_process-reset"><primary><literal>PROCESS-RESET</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-RESET</refname>
          <refpurpose>Causes a specified process to cleanly exit from
	      any ongoing computation.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-reset process <literal>&amp;optional</literal> kill-option =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-reset">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>kill-option</parameter></term>
                <listitem><para>an internal argument, must be nil.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>undefined.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-reset">
          <title>Description</title>
          <para>Causes <parameter>process</parameter> to cleanly exit
	      from any ongoing computation and enter a state where it can be
	      <indexterm><primary><literal>PROCESS-PRESET</literal></primary></indexterm><link linkend="f_process-preset"><literal>PROCESS-PRESET</literal></link>. This
	      is implemented by signaling a condition of type PROCESS-RESET;
	      user-defined condition handlers should generally refrain from
	      attempting to handle conditions of this type.</para>
          <para>The <parameter>kill-option</parameter> argument is for internal
            use only and should not be specified by user code</para>
          <para>A process can meaningfully reset itself.</para>
          <para>There is in general no way to know precisely when
	      <parameter>process</parameter>
	      has completed the act of resetting or killing itself; a process
	      which has either entered the limbo of the reset state or exited
	      has few ways of communicating either fact.
	      <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link>
	      can reliably determine when a process has entered
	      the &quot;limbo of the reset state&quot;, but can't predict how long the
	      clean exit from ongoing computation might take: that depends on
	      the behavior of <indexterm><primary><literal>UNWIND-PROTECT</literal></primary></indexterm><link linkend="m_unwind-protect"><literal>UNWIND-PROTECT</literal></link> cleanup
	      forms, and of the OS scheduler.</para>
          <para>Resetting a process other than
	      <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link> involves the
	      use of <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link>.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-reset">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-KILL</literal></primary></indexterm><link linkend="f_process-kill"><literal>PROCESS-KILL</literal></link>, <indexterm><primary><literal>PROCESS-ABORT</literal></primary></indexterm><link linkend="f_process-abort"><literal>PROCESS-ABORT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-reset-and-enable">
        <indexterm zone="f_process-reset-and-enable"><primary><literal>PROCESS-RESET-AND-ENABLE</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-RESET-AND-ENABLE</refname>
          <refpurpose>Reset and enable the specified process, which
	    may not be the current process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-reset-and-enable process =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-reset-and-enable">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread), which
		      may not be the current process.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>undefined.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-reset-and-enable">
          <title>Description</title>
          <para>
	      Equivalent to calling (process-reset process) and
	      (process-enable process).
	    </para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-reset-and-enable">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-RESET</literal></primary></indexterm><link linkend="f_process-reset"><literal>PROCESS-RESET</literal></link>, <indexterm><primary><literal>PROCESS-ENABLE</literal></primary></indexterm><link linkend="f_process-enable"><literal>PROCESS-ENABLE</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-kill">
        <indexterm zone="f_process-kill"><primary><literal>PROCESS-KILL</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-KILL</refname>
          <refpurpose>Causes a specified process to cleanly exit from any
	      ongoing computation, and then exit.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-kill process =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-kill">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>undefined.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-kill">
          <title>Description</title>
          <para>
	      Causes <parameter>process</parameter> to cleanly exit
	      from any ongoing computation, and then exit.
	    </para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-kill">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-RESET</literal></primary></indexterm><link linkend="f_process-reset"><literal>PROCESS-RESET</literal></link>, <indexterm><primary><literal>PROCESS-ABORT</literal></primary></indexterm><link linkend="f_process-abort"><literal>PROCESS-ABORT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-abort">
        <indexterm zone="f_process-abort"><primary><literal>PROCESS-ABORT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-ABORT</refname>
          <refpurpose>Causes a specified process to process an abort
	      condition, as if it had invoked
	      <indexterm><primary><literal>ABORT</literal></primary></indexterm><literal>ABORT</literal>.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-abort process <literal>&amp;optional</literal> condition =&gt; NIL</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-abort">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>condition</parameter></term>
                <listitem><para>a lisp condition.  The default is NIL.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-abort">
          <title>Description</title>
          <para>Entirely equivalent to calling
	      (<indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link><parameter>process</parameter>
	      (<indexterm><primary><literal>LAMBDA</literal></primary></indexterm><literal>LAMBDA</literal> ()
	      (<indexterm><primary><literal>ABORT</literal></primary></indexterm><literal>ABORT</literal><parameter>condition</parameter>))).
	      Causes <parameter>process</parameter> to transfer control to the
	      applicable handler or restart for <indexterm><primary><literal>ABORT</literal></primary></indexterm><literal>ABORT</literal>.</para>
          <para>If <parameter>condition</parameter> is non-NIL,
	      <indexterm><primary><literal>PROCESS-ABORT</literal></primary></indexterm><link linkend="f_process-abort"><literal>PROCESS-ABORT</literal></link> does not consider any
	      handlers which are explicitly bound to conditions other than
	      <parameter>condition</parameter>.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-abort">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-RESET</literal></primary></indexterm><link linkend="f_process-reset"><literal>PROCESS-RESET</literal></link>, <indexterm><primary><literal>PROCESS-KILL</literal></primary></indexterm><link linkend="f_process-kill"><literal>PROCESS-KILL</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="v_ticks-per-second">
        <indexterm zone="v_ticks-per-second"><primary><literal>*TICKS-PER-SECOND*</literal></primary></indexterm>
        <refnamediv>
          <refname>*TICKS-PER-SECOND*</refname>
          <refpurpose>Bound to the clock resolution of the OS
	      scheduler.</refpurpose>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*TICKS-PER-SECOND*</synopsis></refsynopsisdiv>
        <refsect1 id="value-type_in_v_ticks-per-second">
          <title>Value Type</title>
          <para>A positive integer.</para>
        </refsect1>
        <refsect1 id="initial-value_in_v_ticks-per-second">
          <title>Initial Value</title>
          <para>The clock resolution of the OS scheduler.  Currently,
	      both LinuxPPC and DarwinPPC yield an initial value of 100.
	    </para>
        </refsect1>
        <refsect1 id="description_in_v_ticks-per-second">
          <title>Description</title>
          <para>This value is ordinarily of marginal interest at best,
	      but, for backward compatibility, some functions accept timeout
	      values expressed in &quot;ticks&quot;.  This value gives the number of
	      ticks per second.</para>
        </refsect1>
        <refsect1 id="see-also_in_v_ticks-per-second">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></primary></indexterm><link linkend="f_process-wait-with-timeout"><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-whostate">
        <indexterm zone="f_process-whostate"><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-WHOSTATE</refname>
          <refpurpose>Returns a string which describes the status of
	      a specified process.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-whostate process =&gt; whostate</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_process-whostate">
          <title>Description</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a lisp process (thread).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>whostate</parameter></term>
                <listitem><para>a string which describes the &quot;state&quot; of
		        <parameter>process</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <para>This information is primarily for the benefit of
	      debugging tools.  <parameter>whostate</parameter> is a terse report
	      on what <parameter>process</parameter> is doing, or not doing,
	      and why.</para>
          <para>If the process is currently waiting in a call to
	      <indexterm><primary><literal>PROCESS-WAIT</literal></primary></indexterm><link linkend="f_process-wait"><literal>PROCESS-WAIT</literal></link> or
	      <indexterm><primary><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></primary></indexterm><link linkend="f_process-wait-with-timeout"><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></link>, its
	      <indexterm><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm><link linkend="f_process-whostate"><literal>PROCESS-WHOSTATE</literal></link> will be the value
	      which was passed to that function as <parameter>whostate</parameter>.
	    </para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-whostate">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-WAIT</literal></primary></indexterm><link linkend="f_process-wait"><literal>PROCESS-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></primary></indexterm><link linkend="f_process-wait-with-timeout"><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-whostate">
          <title>Notes</title>
          <para>This should arguably be SETFable, but doesn't seem to
	      ever have been.</para>
        </refsect1>
      </refentry>
      <refentry id="f_process-allow-schedule">
        <indexterm zone="f_process-allow-schedule"><primary><literal>PROCESS-ALLOW-SCHEDULE</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-ALLOW-SCHEDULE</refname>
          <refpurpose>Used for cooperative multitasking; probably never
	      necessary.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-allow-schedule</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_process-allow-schedule">
          <title>Description</title>
          <para>Advises the OS scheduler that the current thread has nothing
	      useful to do and that it should try to find some other thread to
	      schedule in its place. There's almost always a better
	      alternative, such as waiting for some specific event to
	      occur.  For example, you could use a lock or semaphore.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-allow-schedule">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-allow-schedule">
          <title>Notes</title>
          <para>This is a holdover from the days of cooperative
	      multitasking.  All modern general-purpose operating systems use
	      preemptive multitasking.</para>
        </refsect1>
      </refentry>
      <refentry id="f_process-wait">
        <indexterm zone="f_process-wait"><primary><literal>PROCESS-WAIT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-WAIT</refname>
          <refpurpose>Causes the current lisp process (thread) to wait for
	      a given
	      predicate to return true.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-wait whostate function <literal>&amp;rest</literal> args =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-wait">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>whostate</parameter></term>
                <listitem><para>a string, which will be the value of
		        <indexterm><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm><link linkend="f_process-whostate"><literal>PROCESS-WHOSTATE</literal></link>
		        while the process is waiting.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>function</parameter></term>
                <listitem><para>a function, designated by itself or by a symbol
		        which names it.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>args</parameter></term>
                <listitem><para>a list of values, appropriate as arguments to
		        <parameter>function</parameter>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>NIL.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-wait">
          <title>Description</title>
          <para>Causes the current lisp process (thread) to repeatedly
	      apply <parameter>function</parameter> to
	      <parameter>args</parameter> until the call returns a true result, then
	      returns NIL. After
	      each failed call, yields the CPU as if by
	      <indexterm><primary><literal>PROCESS-ALLOW-SCHEDULE</literal></primary></indexterm><link linkend="f_process-allow-schedule"><literal>PROCESS-ALLOW-SCHEDULE</literal></link>.</para>
          <para>
	      As with <indexterm><primary><literal>PROCESS-ALLOW-SCHEDULE</literal></primary></indexterm><link linkend="f_process-allow-schedule"><literal>PROCESS-ALLOW-SCHEDULE</literal></link>, it's almost
	      always more efficient to wait for some
	      specific event to occur; this isn't exactly busy-waiting, but
	      the OS scheduler can do a better job of scheduling if it's given
	      the relevant information.  For example, you could use a lock
	      or semaphore.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-wait">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm><link linkend="f_process-whostate"><literal>PROCESS-WHOSTATE</literal></link>, <indexterm><primary><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></primary></indexterm><link linkend="f_process-wait-with-timeout"><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-wait-with-timeout">
        <indexterm zone="f_process-wait-with-timeout"><primary><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-WAIT-WITH-TIMEOUT</refname>
          <refpurpose>Causes the current thread to wait for a given
	      predicate to return true, or for a timeout to expire.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-wait-with-timeout whostate ticks function args =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-wait-with-timeout">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>whostate</parameter></term>
                <listitem><para>a string, which will be the value of
		        <indexterm><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm><link linkend="f_process-whostate"><literal>PROCESS-WHOSTATE</literal></link>
		        while the process is waiting.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>ticks</parameter></term>
                <listitem><para>either a positive integer expressing a duration
		        in &quot;ticks&quot; (see <indexterm><primary><literal>*TICKS-PER-SECOND*</literal></primary></indexterm><link linkend="v_ticks-per-second"><literal>*TICKS-PER-SECOND*</literal></link>),
		        or NIL.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>function</parameter></term>
                <listitem><para>a function, designated by itself or by a symbol
		        which names it.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>args</parameter></term>
                <listitem><para>a list of values, appropriate as arguments to
		        <parameter>function</parameter>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>T if <indexterm><primary><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></primary></indexterm><link linkend="f_process-wait-with-timeout"><literal>PROCESS-WAIT-WITH-TIMEOUT</literal></link>
		        returned because its <parameter>function</parameter> returned
		        true, or NIL if it returned because the duration
		        <parameter>ticks</parameter> has been exceeded.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-wait-with-timeout">
          <title>Description</title>
          <para>If <parameter>ticks</parameter> is NIL, behaves exactly like
	      <indexterm><primary><literal>PROCESS-WAIT</literal></primary></indexterm><link linkend="f_process-wait"><literal>PROCESS-WAIT</literal></link>, except for returning T.
	      Otherwise, <parameter>function</parameter> will be tested repeatedly,
	      in the same
	      kind of test/yield loop as in <indexterm><primary><literal>PROCESS-WAIT</literal></primary></indexterm><link linkend="f_process-wait"><literal>PROCESS-WAIT</literal></link>
	      until either <parameter>function</parameter> returns true,
	      or the duration <parameter>ticks</parameter> has been exceeded.
	    </para>
          <para> Having already read the descriptions of
	      <indexterm><primary><literal>PROCESS-ALLOW-SCHEDULE</literal></primary></indexterm><link linkend="f_process-allow-schedule"><literal>PROCESS-ALLOW-SCHEDULE</literal></link> and
	      <indexterm><primary><literal>PROCESS-WAIT</literal></primary></indexterm><link linkend="f_process-wait"><literal>PROCESS-WAIT</literal></link>, the
	      astute reader has no doubt anticipated the observation that
	      better alternatives should be used whenever possible.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-wait-with-timeout">
          <title>See Also</title>
          <para><indexterm><primary><literal>*TICKS-PER-SECOND*</literal></primary></indexterm><link linkend="v_ticks-per-second"><literal>*TICKS-PER-SECOND*</literal></link>, <indexterm><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm><link linkend="f_process-whostate"><literal>PROCESS-WHOSTATE</literal></link>, <indexterm><primary><literal>PROCESS-WAIT</literal></primary></indexterm><link linkend="f_process-wait"><literal>PROCESS-WAIT</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="m_without-interrupts">
        <indexterm zone="m_without-interrupts"><primary><literal>WITHOUT-INTERRUPTS</literal></primary></indexterm>
        <refnamediv>
          <refname>WITHOUT-INTERRUPTS</refname>
          <refpurpose>Evaluates its body in an environment in which
	      process-interrupt requests are deferred.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>without-interrupts <literal>&amp;body</literal> body =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_without-interrupts">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>an implicit progn.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the primary value returned by
		        <parameter>body</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_without-interrupts">
          <title>Description</title>
          <para>Executes <parameter>body</parameter>
	      in an environment in which <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link>
	      requests are
	      deferred. As noted in the description of
	      <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link>, this has nothing to do
	      with the
	      scheduling of other threads; it may be necessary to inhibit
	      <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link> handling when
	      (for instance) modifying some data
	      structure (for which the current thread holds an appropriate lock)
	      in some manner that's not reentrant.</para>
        </refsect1>
        <refsect1 id="see-also_in_m_without-interrupts">
          <title>See Also</title>
          <para><indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="m_with-interrupts-enabled">
        <indexterm zone="m_with-interrupts-enabled"><primary><literal>WITH-INTERRUPTS-ENABLED</literal></primary></indexterm>
        <refnamediv>
          <refname>WITH-INTERRUPTS-ENABLED</refname>
          <refpurpose>Evaluates its body in an environment in which
	      process-interrupt requests have immediate effect.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-interrupts-enabled <literal>&amp;body</literal> body =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_with-interrupts-enabled">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>an implicit progn.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the primary value returned by
		        <parameter>body</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_with-interrupts-enabled">
          <title>Description</title>
          <para>Executes <parameter>body</parameter>
	      in an environment in which <indexterm><primary><literal>PROCESS-INTERRUPT</literal></primary></indexterm><link linkend="f_process-interrupt"><literal>PROCESS-INTERRUPT</literal></link>
	      requests have immediate effect.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_make-lock">
        <indexterm zone="f_make-lock"><primary><literal>MAKE-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-LOCK</refname>
          <refpurpose>Creates and returns a lock object, which can
	      be used for synchronization between threads.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-lock <literal>&amp;optional</literal> name =&gt; lock</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_make-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>any lisp object; saved as part of
		        <parameter>lock</parameter>.  Typically a string or symbol
		        which may appear in the <indexterm><primary><literal>PROCESS-WHOSTATE</literal></primary></indexterm><link linkend="f_process-whostate"><literal>PROCESS-WHOSTATE</literal></link>s
		        of threads which are waiting for <parameter>lock</parameter>.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>lock</parameter></term>
                <listitem><para>a newly-allocated object of type CCL:LOCK.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-lock">
          <title>Description</title>
          <para>Creates and returns a lock object, which can
	      be used to synchronize access to some shared resource.
	      <parameter>lock</parameter> is
	      initially in a &quot;free&quot; state; a lock can also be
	      &quot;owned&quot; by a
	      thread.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_make-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm><link linkend="m_with-lock-grabbed"><literal>WITH-LOCK-GRABBED</literal></link>, <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link>, <indexterm><primary><literal>RELEASE-LOCK</literal></primary></indexterm><link linkend="f_release-lock"><literal>RELEASE-LOCK</literal></link>, <indexterm><primary><literal>TRY-LOCK</literal></primary></indexterm><link linkend="f_try-lock"><literal>TRY-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="m_with-lock-grabbed">
        <indexterm zone="m_with-lock-grabbed"><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm>
        <refnamediv>
          <refname>WITH-LOCK-GRABBED</refname>
          <refpurpose>Waits until a given lock can be obtained, then
	      evaluates its body with the lock held.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-lock-grabbed (lock) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_with-lock-grabbed">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>lock</parameter></term>
                <listitem><para>an object of type CCL:LOCK.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>an implicit progn.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the primary value returned by
		        <parameter>body</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_with-lock-grabbed">
          <title>Description</title>
          <para>Waits until <parameter>lock</parameter> is either free or
	      owned by the calling
	      thread, then executes <parameter>body</parameter> with the
	      lock owned by the calling thread. If <parameter>lock</parameter>
	      was free when <indexterm><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm><link linkend="m_with-lock-grabbed"><literal>WITH-LOCK-GRABBED</literal></link> was called,
	      it is restored to a free state after <parameter>body</parameter>
	      is executed.</para>
        </refsect1>
        <refsect1 id="see-also_in_m_with-lock-grabbed">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link>, <indexterm><primary><literal>RELEASE-LOCK</literal></primary></indexterm><link linkend="f_release-lock"><literal>RELEASE-LOCK</literal></link>, <indexterm><primary><literal>TRY-LOCK</literal></primary></indexterm><link linkend="f_try-lock"><literal>TRY-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_grab-lock">
        <indexterm zone="f_grab-lock"><primary><literal>GRAB-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>GRAB-LOCK</refname>
          <refpurpose>Waits until a given lock can be obtained, then
	      obtains it.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>grab-lock lock</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_grab-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>lock</parameter></term>
                <listitem><para>an object of type CCL:LOCK.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_grab-lock">
          <title>Description</title>
          <para>Blocks until <parameter>lock</parameter> is owned by the
	      calling thread.</para>
          <para>The macro <indexterm><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm><link linkend="m_with-lock-grabbed"><literal>WITH-LOCK-GRABBED</literal></link><emphasis>could</emphasis> be defined in
	      terms of <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link> and
	      <indexterm><primary><literal>RELEASE-LOCK</literal></primary></indexterm><link linkend="f_release-lock"><literal>RELEASE-LOCK</literal></link>, but it is actually
	      implemented at a slightly lower level.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_grab-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm><link linkend="m_with-lock-grabbed"><literal>WITH-LOCK-GRABBED</literal></link>, <indexterm><primary><literal>RELEASE-LOCK</literal></primary></indexterm><link linkend="f_release-lock"><literal>RELEASE-LOCK</literal></link>, <indexterm><primary><literal>TRY-LOCK</literal></primary></indexterm><link linkend="f_try-lock"><literal>TRY-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_release-lock">
        <indexterm zone="f_release-lock"><primary><literal>RELEASE-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>RELEASE-LOCK</refname>
          <refpurpose>Relinquishes ownership of a given lock.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>release-lock lock</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_release-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>lock</parameter></term>
                <listitem><para>an object of type CCL:LOCK.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_release-lock">
          <title>Description</title>
          <para>Signals an error of type CCL:LOCK-NOT-OWNER if
	      <parameter>lock</parameter>
	      is not already owned by the calling thread; otherwise, undoes the
	      effect of one previous 
	      <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link>.  If this means that
	      <indexterm><primary><literal>RELEASE-LOCK</literal></primary></indexterm><link linkend="f_release-lock"><literal>RELEASE-LOCK</literal></link> has now been called on
	      <parameter>lock</parameter> the same number of times as
	      <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link> has, <parameter>lock</parameter>
	      becomes free.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_release-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm><link linkend="m_with-lock-grabbed"><literal>WITH-LOCK-GRABBED</literal></link>, <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link>, <indexterm><primary><literal>TRY-LOCK</literal></primary></indexterm><link linkend="f_try-lock"><literal>TRY-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_try-lock">
        <indexterm zone="f_try-lock"><primary><literal>TRY-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>TRY-LOCK</refname>
          <refpurpose>Obtains the given lock, but only if it is not
	      necessary to wait for it.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>try-lock lock =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_try-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>lock</parameter></term>
                <listitem><para>an object of type CCL:LOCK.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>T if <parameter>lock</parameter> has been obtained,
		        or NIL if it has not.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_try-lock">
          <title>Description</title>
          <para>Tests whether <parameter>lock</parameter>
	      can be obtained without blocking - that is, either
	      <parameter>lock</parameter> is already free, or it is already owned
	      by <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link>.  If it can,
	      causes it to
	      be owned by the calling lisp process (thread) and returns T.
	      Otherwise, the lock
	      is already owned by another thread and cannot be obtained without
	      blocking; NIL is returned in this case.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_try-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>WITH-LOCK-GRABBED</literal></primary></indexterm><link linkend="m_with-lock-grabbed"><literal>WITH-LOCK-GRABBED</literal></link>, <indexterm><primary><literal>GRAB-LOCK</literal></primary></indexterm><link linkend="f_grab-lock"><literal>GRAB-LOCK</literal></link>, <indexterm><primary><literal>RELEASE-LOCK</literal></primary></indexterm><link linkend="f_release-lock"><literal>RELEASE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_make-read-write-lock">
        <indexterm zone="f_make-read-write-lock"><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-READ-WRITE-LOCK</refname>
          <refpurpose>Creates and returns a read-write lock, which can
	      be used for synchronization between threads.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-read-write-lock =&gt; read-write-lock</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_make-read-write-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>read-write-lock</parameter></term>
                <listitem><para>a newly-allocated object of type
		        CCL:READ-WRITE-LOCK.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-read-write-lock">
          <title>Description</title>
          <para>Creates and returns an object of type CCL::READ-WRITE-LOCK.
	      A read-write lock may, at any given time, belong to any number
	      of lisp processes (threads) which act as &quot;readers&quot;; or, it may
	      belong to at most one process which acts as a &quot;writer&quot;.  A
	      read-write lock may never be held by a reader at the same time as
	      a writer.  Initially, <parameter>read-write-lock</parameter> has
	      no readers and no writers.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_make-read-write-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>WITH-READ-LOCK</literal></primary></indexterm><link linkend="m_with-read-lock"><literal>WITH-READ-LOCK</literal></link>, <indexterm><primary><literal>WITH-WRITE-LOCK</literal></primary></indexterm><link linkend="m_with-write-lock"><literal>WITH-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_make-read-write-lock">
          <title>Notes</title>
          <para>There probably should be some way to
	      atomically &quot;promote&quot; a reader, making it a writer without
	      releasing the lock, which could otherwise cause delay.</para>
        </refsect1>
      </refentry>
      <refentry id="m_with-read-lock">
        <indexterm zone="m_with-read-lock"><primary><literal>WITH-READ-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>WITH-READ-LOCK</refname>
          <refpurpose>Waits until a given lock is available for
	      read-only access, then evaluates its body with the lock
	      held.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-read-lock (read-write-lock) <literal>&amp;body</literal> body =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_with-read-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>read-write-lock</parameter></term>
                <listitem><para>an object of type
		        CCL:READ-WRITE-LOCK.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>an implicit progn.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the primary value returned by
		        <parameter>body</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_with-read-lock">
          <title>Description</title>
          <para>Waits until <parameter>read-write-lock</parameter> has no
	      writer,
	      ensures that <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link> is a
	      reader of it, then executes <parameter>body</parameter>.
	    </para>
          <para>After executing <parameter>body</parameter>, if
	      <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link> was not a reader of
	      <parameter>read-write-lock</parameter> before
	      <indexterm><primary><literal>WITH-READ-LOCK</literal></primary></indexterm><link linkend="m_with-read-lock"><literal>WITH-READ-LOCK</literal></link> was called, the lock is
	      released.  If it was already a reader, it remains one.</para>
        </refsect1>
        <refsect1 id="see-also_in_m_with-read-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>WITH-WRITE-LOCK</literal></primary></indexterm><link linkend="m_with-write-lock"><literal>WITH-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="m_with-write-lock">
        <indexterm zone="m_with-write-lock"><primary><literal>WITH-WRITE-LOCK</literal></primary></indexterm>
        <refnamediv>
          <refname>WITH-WRITE-LOCK</refname>
          <refpurpose>Waits until the given lock is available for write
	      access, then executes its body with the lock held.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-write-lock (read-write-lock) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_with-write-lock">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>read-write-lock</parameter></term>
                <listitem><para>an object of type
		        CCL:READ-WRITE-LOCK.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>an implicit progn.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the primary value returned by
		        <parameter>body</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_with-write-lock">
          <title>Description</title>
          <para>Waits until <parameter>read-write-lock</parameter> has no
	      readers and no writer other than <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link>,
	      then ensures that <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link> is the
	      writer of it.  With the lock held, executes <parameter>body</parameter>.
	    </para>
          <para>After executing <parameter>body</parameter>, if
	      <indexterm><primary><literal>*CURRENT-PROCESS*</literal></primary></indexterm><link linkend="v_current-process"><literal>*CURRENT-PROCESS*</literal></link> was not the writer of
	      <parameter>read-write-lock</parameter> before
	      <indexterm><primary><literal>WITH-WRITE-LOCK</literal></primary></indexterm><link linkend="m_with-write-lock"><literal>WITH-WRITE-LOCK</literal></link> was called, the lock is
	      released.  If it was already the writer, it remains the
	      writer.</para>
        </refsect1>
        <refsect1 id="see-also_in_m_with-write-lock">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>WITH-READ-LOCK</literal></primary></indexterm><link linkend="m_with-read-lock"><literal>WITH-READ-LOCK</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_make-semaphore">
        <indexterm zone="f_make-semaphore"><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-SEMAPHORE</refname>
          <refpurpose>Creates and returns a semaphore, which can be used
	      for synchronization between threads.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-semaphore =&gt; semaphore</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_make-semaphore">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>semaphore</parameter></term>
                <listitem><para>a newly-allocated object of type CCL:SEMAPHORE.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-semaphore">
          <title>Description</title>
          <para>Creates and returns an object of type CCL:SEMAPHORE.
	      A semaphore has an associated &quot;count&quot; which may be incremented
	      and decremented atomically; incrementing it represents sending
	      a signal, and decrementing it represents handling that signal.
	      <parameter>semaphore</parameter> has an initial count of 0.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_make-semaphore">
          <title>See Also</title>
          <para><indexterm><primary><literal>SIGNAL-SEMAPHORE</literal></primary></indexterm><link linkend="f_signal-semaphore"><literal>SIGNAL-SEMAPHORE</literal></link>, <indexterm><primary><literal>WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_wait-on-semaphore"><literal>WAIT-ON-SEMAPHORE</literal></link>, <indexterm><primary><literal>TIMED-WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_timed-wait-on-semaphore"><literal>TIMED-WAIT-ON-SEMAPHORE</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_signal-semaphore">
        <indexterm zone="f_signal-semaphore"><primary><literal>SIGNAL-SEMAPHORE</literal></primary></indexterm>
        <refnamediv>
          <refname>SIGNAL-SEMAPHORE</refname>
          <refpurpose>Atomically increments the count of a given
	      semaphore.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>signal-semaphore semaphore =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_signal-semaphore">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>semaphore</parameter></term>
                <listitem><para>an object of type CCL:SEMAPHORE.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>an integer representing an error identifier
		        which was returned by the underlying OS call.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_signal-semaphore">
          <title>Description</title>
          <para>Atomically increments <parameter>semaphore</parameter>'s
	      &quot;count&quot; by 1; this
	      may enable a waiting thread to resume execution.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_signal-semaphore">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_wait-on-semaphore"><literal>WAIT-ON-SEMAPHORE</literal></link>, <indexterm><primary><literal>TIMED-WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_timed-wait-on-semaphore"><literal>TIMED-WAIT-ON-SEMAPHORE</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_signal-semaphore">
          <title>Notes</title>
          <para><parameter>result</parameter> should probably be interpreted
	      and acted on by <indexterm><primary><literal>SIGNAL-SEMAPHORE</literal></primary></indexterm><link linkend="f_signal-semaphore"><literal>SIGNAL-SEMAPHORE</literal></link>, because
	      it is not likely to be meaningful to a lisp program, and the
	      most common cause of failure is a type error.</para>
        </refsect1>
      </refentry>
      <refentry id="f_wait-on-semaphore">
        <indexterm zone="f_wait-on-semaphore"><primary><literal>WAIT-ON-SEMAPHORE</literal></primary></indexterm>
        <refnamediv>
          <refname>WAIT-ON-SEMAPHORE</refname>
          <refpurpose>Waits until the given semaphore has a positive
	      count which can be atomically decremented.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>wait-on-semaphore semaphore =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_wait-on-semaphore">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>semaphore</parameter></term>
                <listitem><para>an object of type CCL:SEMAPHORE.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>an integer representing an error identifier
		        which was returned by the underlying OS call.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_wait-on-semaphore">
          <title>Description</title>
          <para>Waits until <parameter>semaphore</parameter>
	      has a positive count that can be
	      atomically decremented; this will succeed exactly once for each
	      corresponding call to SIGNAL-SEMAPHORE.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_wait-on-semaphore">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>SIGNAL-SEMAPHORE</literal></primary></indexterm><link linkend="f_signal-semaphore"><literal>SIGNAL-SEMAPHORE</literal></link>, <indexterm><primary><literal>TIMED-WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_timed-wait-on-semaphore"><literal>TIMED-WAIT-ON-SEMAPHORE</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_wait-on-semaphore">
          <title>Notes</title>
          <para><parameter>result</parameter> should probably be interpreted
	      and acted on by <indexterm><primary><literal>WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_wait-on-semaphore"><literal>WAIT-ON-SEMAPHORE</literal></link>, because
	      it is not likely to be meaningful to a lisp program, and the
	      most common cause of failure is a type error.</para>
        </refsect1>
      </refentry>
      <refentry id="f_timed-wait-on-semaphore">
        <indexterm zone="f_timed-wait-on-semaphore"><primary><literal>TIMED-WAIT-ON-SEMAPHORE</literal></primary></indexterm>
        <refnamediv>
          <refname>TIMED-WAIT-ON-SEMAPHORE</refname>
          <refpurpose>Waits until the given semaphore has a positive
	      count which can be atomically decremented, or until a timeout
	      expires.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>timed-wait-on-semaphore semaphore timeout =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_timed-wait-on-semaphore">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>semaphore</parameter></term>
                <listitem><para>An object of type CCL:SEMAPHORE.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>timeout</parameter></term>
                <listitem><para>a time interval in seconds.  May be any
		        non-negative real number the <indexterm><primary><literal>FLOOR</literal></primary></indexterm><literal>FLOOR</literal> of
		        which fits in 32 bits.  The default is 1.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>T if <indexterm><primary><literal>TIMED-WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_timed-wait-on-semaphore"><literal>TIMED-WAIT-ON-SEMAPHORE</literal></link>
		        returned because it was able to decrement the count of
		        <parameter>semaphore</parameter>; NIL if it returned because
		        the duration <parameter>timeout</parameter> has been
		        exceeded.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_timed-wait-on-semaphore">
          <title>Description</title>
          <para>Waits until <parameter>semaphore</parameter>
	      has a positive count that can be
	      atomically decremented, or until the duration
	      <parameter>timeout</parameter> has
	      elapsed.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_timed-wait-on-semaphore">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>WAIT-ON-SEMAPHORE</literal></primary></indexterm><link linkend="f_wait-on-semaphore"><literal>WAIT-ON-SEMAPHORE</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_process-input-wait">
        <indexterm zone="f_process-input-wait"><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-INPUT-WAIT</refname>
          <refpurpose>Waits until input is available on a given
	      file-descriptor.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-input-wait fd <literal>&amp;optional</literal> timeout</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-input-wait">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>fd</parameter></term>
                <listitem><para>a file descriptor, which is a non-negative integer
		        used by the OS to refer to an open file, socket, or similar
		        I/O connection.  See <indexterm><primary><literal>STREAM-DEVICE</literal></primary></indexterm><link linkend="f_stream-device"><literal>STREAM-DEVICE</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>timeout</parameter></term>
                <listitem><para>either NIL or a time interval in milliseconds.  Must be a non-negative integer.  The default is NIL.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-input-wait">
          <title>Description</title>
          <para>Wait until input is available on <parameter>fd</parameter>.
	      This uses the <literal>select()</literal> system call, and is
	      generally a fairly
	      efficient way of blocking while waiting for input. More
	      accurately, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>
	      waits until it's possible to read
	      from fd without blocking, or until <parameter>timeout</parameter>, if
	      it is not NIL, has been exceeded.</para>
          <para>	      Note that it's possible to read without blocking if
	      the file is at its end - although, of course, the read will
	      return zero bytes.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-input-wait">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-input-wait">
          <title>Notes</title>
          <para><indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link> has a timeout parameter,
	      and
	      <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link> does not.  This
	      inconsistency should probably be corrected.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_process-output-wait">
        <indexterm zone="f_process-output-wait"><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm>
        <refnamediv>
          <refname>PROCESS-OUTPUT-WAIT</refname>
          <refpurpose>Waits until output is possible on a given file
	      descriptor.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>process-output-wait fd <literal>&amp;optional</literal> timeout</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_process-output-wait">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>fd</parameter></term>
                <listitem><para>a file descriptor, which is a non-negative integer
		        used by the OS to refer to an open file, socket, or similar
		        I/O connection.  See <indexterm><primary><literal>STREAM-DEVICE</literal></primary></indexterm><link linkend="f_stream-device"><literal>STREAM-DEVICE</literal></link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>timeout</parameter></term>
                <listitem><para>either NIL or a time interval in milliseconds.  Must be a non-negative integer.  The default is NIL.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_process-output-wait">
          <title>Description</title>
          <para>Wait until output is possible on <parameter>fd</parameter> or until <parameter>timeout</parameter>, if
	      it is not NIL, has been exceeded.
	      This uses the <literal>select()</literal> system call, and is
	      generally a fairly
	      efficient way of blocking while waiting to output.</para>
          <para>	      If <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link> is called on
	      a network socket which has not yet established a connection, it
	      will wait until the connection is established.  This is an
	      important use, often overlooked.</para>
        </refsect1>
        <refsect1 id="see-also_in_f_process-output-wait">
          <title>See Also</title>
          <para><indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link></para>
        </refsect1>
        <refsect1 id="notes_in_f_process-output-wait">
          <title>Notes</title>
          <para><indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link> has a timeout parameter,
	      and
	      <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link> does not.  This
	      inconsistency should probably be corrected.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="m_with-terminal-input">
        <indexterm zone="m_with-terminal-input"><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm>
        <refnamediv>
          <refname>WITH-TERMINAL-INPUT</refname>
          <refpurpose>Executes its body in an environment with exclusive
	      read access to the terminal.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-terminal-input <literal>&amp;body</literal> body =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_with-terminal-input">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>an implicit progn.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>the primary value returned by
		        <parameter>body</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_with-terminal-input">
          <title>Description</title>
          <para>Requests exclusive read access to the standard terminal
	      stream, <indexterm><primary><literal>*TERMINAL-IO*</literal></primary></indexterm><literal>*TERMINAL-IO*</literal>.  Executes
	      <parameter>body</parameter> in an environment with that access.
	    </para>
        </refsect1>
        <refsect1 id="see-also_in_m_with-terminal-input">
          <title>See Also</title>
          <para><indexterm><primary><literal>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</literal></primary></indexterm><link linkend="v_request-terminal-input-via-break"><literal>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</literal></link>, <indexterm><primary><literal>&quot;:Y&quot;</literal></primary></indexterm><link linkend="tc_y"><literal>&quot;:Y&quot;</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="v_request-terminal-input-via-break">
        <indexterm zone="v_request-terminal-input-via-break"><primary><literal>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</literal></primary></indexterm>
        <refnamediv>
          <refname>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</refname>
          <refpurpose>Controls how attempts to obtain ownership of
	      terminal input are made.</refpurpose>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</synopsis></refsynopsisdiv>
        <refsect1 id="value-type_in_v_request-terminal-input-via-break">
          <title>Value Type</title>
          <para>A boolean.</para>
        </refsect1>
        <refsect1 id="initial-value_in_v_request-terminal-input-via-break">
          <title>Initial Value</title>
          <para>NIL.</para>
        </refsect1>
        <refsect1 id="description_in_v_request-terminal-input-via-break">
          <title>Description</title>
          <para>Controls how attempts to obtain ownership of terminal input
	      are made. When NIL, a message is printed on *TERMINAL-IO*;
	      it's expected that the user will later yield
	      control of the terminal via the :Y toplevel command. When T, a
	      BREAK condition is signaled in the owning process; continuing from
	      the break loop will yield the terminal to the requesting process
	      (unless the :Y command was already used to do so in the break
	      loop.)</para>
        </refsect1>
        <refsect1 id="see-also_in_v_request-terminal-input-via-break">
          <title>See Also</title>
          <para><indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link>, <indexterm><primary><literal>&quot;:Y&quot;</literal></primary></indexterm><link linkend="tc_y"><literal>&quot;:Y&quot;</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="tc_y">
        <indexterm zone="tc_y"><primary><literal>&quot;:Y&quot;</literal></primary></indexterm>
        <refnamediv>
          <refname>&quot;:Y&quot;</refname>
          <refpurpose>Yields control of terminal input to a specified
	      lisp process (thread).</refpurpose>
          <refclass>Toplevel Command</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>( :y p)</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_tc_y">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>p</parameter></term>
                <listitem><para>a lisp process (thread), designated either by
		        an integer which matches its
		        <indexterm><primary><literal>PROCESS-SERIAL-NUMBER</literal></primary></indexterm><literal>PROCESS-SERIAL-NUMBER</literal>,
		        or by a string which is <indexterm><primary><literal>EQUAL</literal></primary></indexterm><literal>EQUAL</literal> to
		        its <indexterm><primary><literal>PROCESS-NAME</literal></primary></indexterm><literal>PROCESS-NAME</literal>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_tc_y">
          <title>Description</title>
          <para>:Y is a toplevel command, not a function.  As such, it
	      can only be used interactively, and only from the initial
	      process.</para>
          <para>The command yields control of terminal input to the
	      process <parameter>p</parameter>, which must have used
	      <indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link> to request access to the
	      terminal input stream.</para>
        </refsect1>
        <refsect1 id="see-also_in_tc_y">
          <title>See Also</title>
          <para><indexterm><primary><literal>WITH-TERMINAL-INPUT</literal></primary></indexterm><link linkend="m_with-terminal-input"><literal>WITH-TERMINAL-INPUT</literal></link>, <indexterm><primary><literal>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</literal></primary></indexterm><link linkend="v_request-terminal-input-via-break"><literal>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</literal></link>, <indexterm><primary><literal>MAKE-LOCK</literal></primary></indexterm><link linkend="f_make-lock"><literal>MAKE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link>, <indexterm><primary><literal>MAKE-SEMAPHORE</literal></primary></indexterm><link linkend="f_make-semaphore"><literal>MAKE-SEMAPHORE</literal></link>, <indexterm><primary><literal>PROCESS-INPUT-WAIT</literal></primary></indexterm><link linkend="f_process-input-wait"><literal>PROCESS-INPUT-WAIT</literal></link>, <indexterm><primary><literal>PROCESS-OUTPUT-WAIT</literal></primary></indexterm><link linkend="f_process-output-wait"><literal>PROCESS-OUTPUT-WAIT</literal></link></para>
        </refsect1>
      </refentry>
      <refentry id="f_join-process">
        <indexterm zone="f_join-process"><primary><literal>JOIN-PROCESS</literal></primary></indexterm>
        <refnamediv>
          <refname>JOIN-PROCESS</refname>
          <refpurpose>Waits for a specified process to complete and
	returns the values that that process's initial function
	returned.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>join-process process <literal>&amp;optional</literal> default =&gt; values</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_join-process">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>process</parameter></term>
                <listitem><para>a process, typically created by <indexterm><primary><literal>PROCESS-RUN-FUNCTION</literal></primary></indexterm><link linkend="f_process-run-function"><literal>PROCESS-RUN-FUNCTION</literal></link> or by <indexterm><primary><literal>MAKE-PROCESS</literal></primary></indexterm><link linkend="f_make-process"><literal>MAKE-PROCESS</literal></link></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>default</parameter></term>
                <listitem><para>A default value to be returned if the specified
	      process doesn't exit normally.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>values</parameter></term>
                <listitem><para>The values returned by the specified process's
	      initial function if that function returns, or the value
	      of the default argument, otherwise.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_join-process">
          <title>Description</title>
          <para>Waits for the specified process to terminate.  If the
	process terminates &quot;normally&quot; (if its initial function
	returns), returns the values that that initial function
	returnes.  If the process does not terminate normally (e.g.,
	if it's terminated via <indexterm><primary><literal>PROCESS-KILL</literal></primary></indexterm><link linkend="f_process-kill"><literal>PROCESS-KILL</literal></link> and a
	default argument is provided, returns the value of that
	default argument.  If the process doesn't terminate normally
	and no default argument is provided, signals an error.</para>
          <para>A process can't successfully join itself, and only one
	process can successfully receive notification of another process's
	termination.</para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="programming-with-sockets">
    <title>Programming with Sockets</title>
    <section id="overview_in_programming-with-sockets">
      <title>Overview</title>
      <para>Clozure CL supports the socket abstraction for
      interprocess communication. A socket represents a connection to
      another process, typically (but not necessarily) a TCP/IP
      network connection to a client or server running on some other
      machine on the network.</para>
      <para>IPv6 is supported by the :internet6 address family.
      Applications should use the <indexterm><primary><literal>RESOLVE-ADDRESS</literal></primary></indexterm><link linkend="f_resolve-address"><literal>RESOLVE-ADDRESS</literal></link>
      function to translate host and port specifications to socket
      addresses.  While host and port numbers can still be dealt with
      separately, it is preferable to use <indexterm><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm><link linkend="c_socket-address"><literal>CCL::SOCKET-ADDRESS</literal></link> instances to specify socket
      endpoints for unified parsing of string representations and
      printing.</para>
      <para>All symbols mentioned in this chapter are exported from
      the CCL package. As of version 0.13, these symbols are
      additionally exported from the OPENMCL-SOCKET package.</para>
      <para>Clozure CL supports three types of sockets: TCP sockets, UDP
      sockets, and Unix-domain sockets.  This should be enough for all
      but the most esoteric network situations.  All sockets are
      created by <indexterm><primary><literal>MAKE-SOCKET</literal></primary></indexterm><link linkend="f_make-socket"><literal>MAKE-SOCKET</literal></link>.  The type of socket
      depends on the arguments to it, as follows:</para>
      <blockquote>
        <variablelist>
          <varlistentry>
            <term>tcp-stream</term>
            <listitem><para>A buffered bi-directional stream over a TCP/IP connection.
	    tcp-stream is a subclass of stream, and you can read and write to it
	    using all the usual stream functions. Created by (make-socket
	    :address-family :internet :type :stream :connect :active ...) or by
	    (accept-connection ...).</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>file-socket-stream</term>
            <listitem><para>A buffered bi-directional stream over a &quot;UNIX domain&quot;
	    connection. file-socket-stream is a subclass of stream, and you can
	    read and write to it using all the usual stream functions. Created
	    by (make-socket :address-family :file :type :stream :connect :active
	    ...) or by (accept-connection ...),</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>listener-socket</term>
            <listitem><para>A passive socket used to listen for incoming TCP/IP
	    connections on a particular port. A listener-socket is not a stream.
	    It doesn't support I/O. It can only be used to create new
	    tcp-streams by accept-connection. Created by (make-socket :type
	    :stream :connect :passive ...)</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>file-listener-socket</term>
            <listitem><para>A passive socket used to listen for incoming UNIX domain
	    connections named by a file in the local filesystem. A
	    listener-socket is not a stream. It doesn't support I/O. It can
	    only be used to create new file-socket-streams by accept-connection.
	    Created by (make-socket :address-family :file :type :stream :connect
	    :passive ...)</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>udp-socket</term>
            <listitem><para>A socket representing a packet-based UDP/IP connection. A
	    udp-socket supports I/O but it is not a stream. Instead, you must
	    use the special functions send-to and receive-from to read and write
	    to it. Created by (make-socket :type :datagram ...)</para></listitem>
          </varlistentry>
        </variablelist>
      </blockquote>
    </section>
    <section id="sockets-dictionary">
      <title>Sockets Dictionary</title>
      <refentry id="f_make-socket">
        <indexterm zone="f_make-socket"><primary><literal>MAKE-SOCKET</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-SOCKET</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-socket <literal>&amp;key</literal> address-family type connect eol format remote-address remote-host remote-port local-address local-host local-port local-filename remote-filename keepalive reuse-address nodelay broadcast linger backlog input-timeout output-timeout connect-timeout auto-close deadline</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_make-socket">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>address-family</parameter></term>
                <listitem><para>The address/protocol family of this
		socket. Currently, :internet (the default), meaning
		IPv4, :internet6, meaning IPv6, and :file, referring
		to UNIX domain addresses, are supported.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>type</parameter></term>
                <listitem><para>One of :stream (the default) to request a
		connection-oriented socket, or :datagram to request a
		connectionless socket. The default is :stream.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>connect</parameter></term>
                <listitem><para>This argument is only relevant to sockets of type
		:stream. One of :active (the default) to request a :passive
		to request a file or TCP listener socket.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>eol</parameter></term>
                <listitem><para>This argument is currently ignored (it is accepted for
		compatibility with Franz Allegro).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>format</parameter></term>
                <listitem><para>One of :text (the default), :binary, or :bivalent.
		This argument is ignored for :stream sockets for now, as
		:stream sockets are currently always bivalent (i.e. they
		support both character and byte I/O). For :datagram sockets,
		this argument is ignored (the format of a datagram socket
		is always :binary).
		</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote</parameter></term>
                <listitem><para>For TCP streams, it specifies the socket address
		to connect to, specified as socket-address instance.
		Ignored for listener sockets. For UDP sockets, it can
		be used to specify a default address for subsequent calls
		to send-to or receive-from.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote-host</parameter></term>
                <listitem><para>For TCP streams, it specifies the host to
		connect to (in any format acceptable to resolve-address).
		Ignored for listener sockets. For UDP sockets, it can be
		used to specify a default host for subsequent calls to
		send-to or receive-from.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote-port</parameter></term>
                <listitem><para>For TCP streams, it specifies the port to
		connect to (in any format acceptable to resolve-address).
		Ignored for listener sockets. For UDP sockets, it can be
		used to specify a default port for subsequent calls to for
		subsequent calls to send-to or receive-from.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote-filename</parameter></term>
                <listitem><para>For file-socket streams, it specifies the
		name of a file in the local filesystem (e.g., NOT mounted
		via NFS, AFP, SMB, ...) which names and controls access to a
		UNIX-domain socket.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>local-address</parameter></term>
                <listitem><para>Allows you to specify a local address for a
		listener or UDP socket, for the case where you want to
		restrict connections to those coming to a specific local
		address for security reasons.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>local-host</parameter></term>
                <listitem><para>Allows you to specify a local host address for a
		listener or UDP socket, for the case where you want to
		restrict connections to those coming to a specific local
		address for security reasons.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>local-port</parameter></term>
                <listitem><para>Specify a local port for a socket. Most useful for
		listener sockets, where it is the port on which the socket
		will listen for connections.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>local-filename</parameter></term>
                <listitem><para>For file-listener-sockets, specifies the name
		of a file in the local filesystem which is used to name a
		UNIX-domain socket. The actual filesystem file should not
		previously exist when the file-listener-socket is created;
		its parent directory should exist and be writable by the
		caller. The file used to name the socket will be deleted
		when the file-listener-socket is closed.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>keepalive</parameter></term>
                <listitem><para>If true, enables the periodic transmission of
		&quot;keepalive&quot; messages.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>reuse-address</parameter></term>
                <listitem><para>If true, allows the reuse of local ports in listener
		sockets, overriding some TCP/IP protocol specifications. You
		will need this if you are debugging a server..</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>nodelay</parameter></term>
                <listitem><para>If true, disables Nagle's algorithm, which tries
		to minimize TCP packet fragmentation by introducing
		transmission delays in the absence of replies. Try setting
		this if you are using a protocol which involves sending a
		steady stream of data with no replies and are seeing
		significant degradations in throughput.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>broadcast</parameter></term>
                <listitem><para>If true, requests permission to broadcast datagrams on
		a UDP socket.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>linger</parameter></term>
                <listitem><para>If specified and non-nil, should be the number of
		seconds the OS is allowed to wait for data to be pushed
		through when a close is done. Only relevant for TCP sockets.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>backlog</parameter></term>
                <listitem><para>For a listener socket, specifies the number of
		connections which can be pending but not accepted. The
		default is 5, which is also the maximum on some operating
		systems.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>input-timeout</parameter></term>
                <listitem><para>The number of seconds before an input operation
		times out.  Must be a real number between zero and one
		million.  If an input operation takes longer than the
		specified number of seconds, an
		<literal>input-timeout</literal> error is signalled.
		(see <xref linkend="stream-timeouts-and-deadlines"/>)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>output-timeout</parameter></term>
                <listitem><para>The number of seconds before an output operation
		times out.  Must be a real number between zero and one
		million.  If an output operation takes longer than the
		specified number of seconds, an
		<literal>output-timeout</literal> error is signalled.
		(see <xref linkend="stream-timeouts-and-deadlines"/>)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>connect-timeout</parameter></term>
                <listitem><para>The number of seconds before a connection
		attempt times out. [TODO: what are acceptable values?]
		If a connection attempt takes longer than the
		specified number of seconds, a
		<literal>socket-error</literal> is signalled.  This
		can be useful if the specified interval is shorter
		than the interval that the OS's socket layer imposes,
		which is sometimes a minute or two.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>auto-close</parameter></term>
                <listitem><para>When non-nil, any resulting socket stream will
		be closed when the GC can prove that the stream is
		unreferenced.  This is done via CCL's termination
		mechanism [TODO add xref].</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>deadline</parameter></term>
                <listitem><para>Specifies an absolute time in
		internal-time-units.  If an I/O operation on the
		stream does not complete before the deadline then a
		<literal>COMMUNICATION-DEADLINE-EXPIRED</literal>
		error is signalled.  A deadline takes precedence over
		any input/output timeouts that may be set.  (see <xref linkend="stream-timeouts-and-deadlines"/>)</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-socket">
          <title>Description</title>
          <para>Creates and returns a new socket.  For :passive
	  sockets, the :local-address, :local-port or :local-filename
	  arguments are required, depending on the type of the socket.
	  For :active sockets, either the :remote-address, the
	  :remote-host and :remote-port, or the :remote-filename
	  arguments must be present, depending on the socket
	  type.</para>
        </refsect1>
      </refentry>
      <refentry id="f_accept-connection">
        <indexterm zone="f_accept-connection"><primary><literal>ACCEPT-CONNECTION</literal></primary></indexterm>
        <refnamediv>
          <refname>ACCEPT-CONNECTION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>accept-connection (socket listener-socket) <literal>&amp;key</literal> wait</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_accept-connection">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The listener-socket to listen on.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>wait</parameter></term>
                <listitem><para>If true (the default), and there are no connections
		waiting to be accepted, waits until one arrives. If false,
		returns NIL immediately.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_accept-connection">
          <title>Description</title>
          <para>Extracts the first connection on the queue of pending
	  connections, accepts it (i.e. completes the connection startup
	  protocol) and returns a new tcp-stream or file-socket-stream
	  representing the newly established connection. The tcp stream
	  inherits any properties of the listener socket that are relevant
	  (e.g. :keepalive, :nodelay, etc.) The original listener socket
	  continues to be open listening for more connections, so you can
	  call accept-connection on it again.</para>
        </refsect1>
      </refentry>
      <refentry id="f_resolve-address">
        <indexterm zone="f_resolve-address"><primary><literal>RESOLVE-ADDRESS</literal></primary></indexterm>
        <refnamediv>
          <refname>RESOLVE-ADDRESS</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>resolve-address <literal>&amp;key</literal> host port socket-type connect address-family numeric-host-p numeric-service-p singlep errorp</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_resolve-address">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>host</parameter></term>
                <listitem><para>Specification of the host, as a string.  This
		can be either a host name such as
		&quot;clozure.com&quot; or any of the literal address
		forms accepted by getaddrinfo().</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>port</parameter></term>
                <listitem><para>Specification of the port.  This
		can be either a service name such as
		&quot;http&quot; or a port number.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>socket-type</parameter></term>
                <listitem><para>Service type for port lookups, can be either
		:stream for TCP services or :datagram for UDP.
		Defaults to :stream.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>connect</parameter></term>
                <listitem><para>Specifies how the returned <indexterm><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm><link linkend="c_socket-address"><literal>CCL::SOCKET-ADDRESS</literal></link> instances will be used.
		If :active is passed, which is the default, the host
		address will default to the address of the loopback
		interface of the local host if not specified.  When
		:passive is used, the host address will default to the
		wildcard address for the given address family.  This
		parameter has no effect if the :host parameter is
		used.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>address-family</parameter></term>
                <listitem><para>Specifies the address family that should be
		returned, can be specified as either :internet or
		:internet6.  If it is specified, only addresses of
		that family are returned.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>numeric-host-p</parameter></term>
                <listitem><para>If this argument is true, no host name lookups
		will be performed for the host address.  A numeric
		address literal must be passed in this case.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>numeric-port-p</parameter></term>
                <listitem><para>If this argument is true, no service name
		lookups will be performed for the port address.  A
		numeric port number must be passed in this
		case.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>singlep</parameter></term>
                <listitem><para>If this argument is set to a true value, which
		is the default, only the first matching address is
		returned.  If it is passed as NIL, all matching
		addresses are returned as a list.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>errorp</parameter></term>
                <listitem><para>If this argument is set to a true value, which
		is the default, an error is signalled if the given
		host and/or port combination did not yield any
		matches.  If it is passed as NIL, the function returns
		NIL if no addresses matched the supplied
		arguments.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_resolve-address">
          <title>Description</title>
          <para>Converts a host and/or port specification to one or
	  more <indexterm><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm><link linkend="c_socket-address"><literal>CCL::SOCKET-ADDRESS</literal></link> instances.  This
	  function uses the getaddrinfo() system function underneath
	  which knows how to translate all standard address and port
	  formats and appropriately orders adresses for hosts with
	  multiple addresses.  It returns the best matching
	  translation or, if the :singlep argument is passed as false,
	  or all matching translations for the given parameter
	  combination.</para>
        </refsect1>
      </refentry>
      <refentry id="f_dotted-to-ipaddr">
        <indexterm zone="f_dotted-to-ipaddr"><primary><literal>DOTTED-TO-IPADDR</literal></primary></indexterm>
        <refnamediv>
          <refname>DOTTED-TO-IPADDR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>dotted-to-ipaddr dotted <literal>&amp;key</literal> errorp</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_dotted-to-ipaddr">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>dotted</parameter></term>
                <listitem><para>A string representing an IP address in the
		&quot;nn.nn.nn.nn&quot; format</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>errorp</parameter></term>
                <listitem><para>If true (the default) an error is signaled if dotted
		is invalid. If false, NIL is returned.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_dotted-to-ipaddr">
          <title>Description</title>
          <para>Converts a dotted-string representation of a host address to
	  a 32-bit unsigned IP address.</para>
        </refsect1>
      </refentry>
      <refentry id="f_ipaddr-to-dotted">
        <indexterm zone="f_ipaddr-to-dotted"><primary><literal>IPADDR-TO-DOTTED</literal></primary></indexterm>
        <refnamediv>
          <refname>IPADDR-TO-DOTTED</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>ipaddr-to-dotted ipaddr <literal>&amp;key</literal> values</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_ipaddr-to-dotted">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>ipaddr</parameter></term>
                <listitem><para>A 32-bit integer representing an IPv4 host
		address</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>values</parameter></term>
                <listitem><para>If false (the default), returns a string in the form
		&quot;nn.nn.nn.nn&quot;. If true, returns four values
		representing the four octets of the address as unsigned
		8-bit integers.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_ipaddr-to-dotted">
          <title>Description</title>
          <para>Converts a 32-bit unsigned IPv4 address into octets.</para>
        </refsect1>
      </refentry>
      <refentry id="f_ipaddr-to-hostname">
        <indexterm zone="f_ipaddr-to-hostname"><primary><literal>IPADDR-TO-HOSTNAME</literal></primary></indexterm>
        <refnamediv>
          <refname>IPADDR-TO-HOSTNAME</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>ipaddr-to-hostname ipaddr <literal>&amp;key</literal> ignore-cache</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_ipaddr-to-hostname">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>ipaddr</parameter></term>
                <listitem><para>a 32-bit integer representing an IPv4 host address</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>ignore-cache</parameter></term>
                <listitem><para>This argument is ignored (it is accepted for
		compatibility with Franz Allegro)</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_ipaddr-to-hostname">
          <title>Description</title>
          <para>Converts a 32-bit unsigned IPv4 address into a host name
	  string</para>
        </refsect1>
      </refentry>
      <refentry id="f_lookup-hostname">
        <indexterm zone="f_lookup-hostname"><primary><literal>LOOKUP-HOSTNAME</literal></primary></indexterm>
        <refnamediv>
          <refname>LOOKUP-HOSTNAME</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>lookup-hostname host</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_lookup-hostname">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>host</parameter></term>
                <listitem><para>Specifies the host. It can be either a host name
		string such as &quot;clozure.com&quot;, or a dotted address
		string such as &quot;192.168.0.1&quot;, or a 32-bit unsigned
		IPv4 address such as 3232235521.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_lookup-hostname">
          <title>Description</title>
          <para>Converts a host spec in any of the acceptable formats
	  into a 32-bit unsigned IPv4 address.  IPv6-enabled
	  applications should use the <indexterm><primary><literal>RESOLVE-ADDRESS</literal></primary></indexterm><link linkend="f_resolve-address"><literal>RESOLVE-ADDRESS</literal></link> function instead.</para>
        </refsect1>
      </refentry>
      <refentry id="f_lookup-port">
        <indexterm zone="f_lookup-port"><primary><literal>LOOKUP-PORT</literal></primary></indexterm>
        <refnamediv>
          <refname>LOOKUP-PORT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>lookup-port port protocol</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_lookup-port">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>port</parameter></term>
                <listitem><para>Specifies the port. It can be either a string,
		such as &quot;http&quot; or a symbol, such as :http, or
		an unsigned port number. Note that a string is
		case-sensitive. A symbol is lowercased before
		lookup.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>protocol</parameter></term>
                <listitem><para>Must be one of &quot;tcp&quot; or &quot;udp&quot;.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_lookup-port">
          <title>Description</title>
          <para>Finds the port number for the specified port and protocol</para>
        </refsect1>
      </refentry>
      <refentry id="f_receive-from">
        <indexterm zone="f_receive-from"><primary><literal>RECEIVE-FROM</literal></primary></indexterm>
        <refnamediv>
          <refname>RECEIVE-FROM</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>receive-from (socket udp-socket) size <literal>&amp;key</literal> buffer extract offset</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_receive-from">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket to read from</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>size</parameter></term>
                <listitem><para>Maximum number of bytes to read. If the packet is
		larger than this, any extra bytes are discarded.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>buffer</parameter></term>
                <listitem><para>If specified, must be an octet vector
		which will be used to read in the data. If not specified, a
		new buffer will be created (of type determined by
		socket-format).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>extract</parameter></term>
                <listitem><para>If true, the subsequence of the buffer corresponding
		only to the data read in is extracted and returned as the
		first value. If false (the default) the original buffer is
		returned even if it is only partially filled.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>offset</parameter></term>
                <listitem><para>Specifies the start offset into the buffer at which
		data is to be stored. The default is 0.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>want-socket-address-p</parameter></term>
                <listitem><para>Indicates that the address of the sender of the
		data should be returned as a <indexterm><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm><link linkend="c_socket-address"><literal>CCL::SOCKET-ADDRESS</literal></link> instance rather than as
		separate host and port values.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_receive-from">
          <title>Description</title>
          <para>Reads a UDP packet from a socket. If no packets are
	  available, waits for a packet to arrive.</para>
          <para>          If :want-socket-address-p is NIL, which is the
          default, four values are returned:</para>
          <blockquote>
            <orderedlist>
              <listitem><para>The buffer with the data</para></listitem>
              <listitem><para>The number of bytes read</para></listitem>
              <listitem><para>The 32-bit unsigned IPv4 address or the 16 byte
	      IPv6 addresss of the sender of the data</para></listitem>
              <listitem><para>The port number of the sender of the data</para></listitem>
            </orderedlist>
          </blockquote>
          <para>If :want-socket-address-p is true, three values are
          returned:</para>
          <blockquote>
            <orderedlist>
              <listitem><para>The buffer with the data</para></listitem>
              <listitem><para>The number of bytes read</para></listitem>
              <listitem><para>The <indexterm><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm><link linkend="c_socket-address"><literal>CCL::SOCKET-ADDRESS</literal></link> instance of
	      the sender of the data.</para></listitem>
            </orderedlist>
          </blockquote>
        </refsect1>
      </refentry>
      <refentry id="f_send-to">
        <indexterm zone="f_send-to"><primary><literal>SEND-TO</literal></primary></indexterm>
        <refnamediv>
          <refname>SEND-TO</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>send-to (socket udp-socket) buffer size <literal>&amp;key</literal> remote remote-host remote-port offset</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_send-to">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket to write to</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>buffer</parameter></term>
                <listitem><para>A vector containing the data to send. It must be
		an octet vector.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>size</parameter></term>
                <listitem><para>Number of octets to send</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote</parameter></term>
                <listitem><para>The remote address to send the packet to, as a
		<indexterm><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm><link linkend="c_socket-address"><literal>CCL::SOCKET-ADDRESS</literal></link> instance. The
		default is the remote address specified in the call to
		make-socket.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote-host</parameter></term>
                <listitem><para>The host to send the packet to, in any format
		acceptable to lookup-hostname. The default is the remote
		host specified in the call to make-socket.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>remote-port</parameter></term>
                <listitem><para>The port to send the packet to, in any format
		acceptable to lookup-port. The default is the remote port
		specified in the call to make-socket.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>offset</parameter></term>
                <listitem><para>The offset in the buffer where the packet data starts</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_send-to">
          <title>Description</title>
          <para>Send a UDP packet over a socket.</para>
        </refsect1>
      </refentry>
      <refentry id="f_shutdown">
        <indexterm zone="f_shutdown"><primary><literal>SHUTDOWN</literal></primary></indexterm>
        <refnamediv>
          <refname>SHUTDOWN</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>shutdown socket <literal>&amp;key</literal> direction</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_shutdown">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket to shut down (typically a tcp-stream)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>direction</parameter></term>
                <listitem><para>One of :input to disallow further input, or :output to
		disallow further output.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_shutdown">
          <title>Description</title>
          <para>Shuts down part of a bidirectional connection. This is
	  useful if e.g. you need to read responses after sending an
	  end-of-file signal.</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-os-fd">
        <indexterm zone="f_socket-os-fd"><primary><literal>SOCKET-OS-FD</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-OS-FD</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-os-fd socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-os-fd">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-os-fd">
          <title>Description</title>
          <para>Returns the native OS's representation of the socket, or
	  NIL if the socket is closed. On Unix, this is the Unix 'file
	  descriptor', a small non-negative integer. Note that it is
	  rather dangerous to mess around with tcp-stream fd's, as there
	  is all sorts of buffering and asynchronous I/O going on above the
	  OS level. listener-socket and udp-socket fd's are safer to
	  mess with directly as there is less magic going on.</para>
        </refsect1>
      </refentry>
      <refentry id="f_remote-host">
        <indexterm zone="f_remote-host"><primary><literal>REMOTE-HOST</literal></primary></indexterm>
        <refnamediv>
          <refname>REMOTE-HOST</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>remote-host socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_remote-host">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_remote-host">
          <title>Description</title>
          <para>Returns the 32-bit unsigned IPv4 address of the remote host,
	  or NIL if the socket is not connected.</para>
        </refsect1>
      </refentry>
      <refentry id="f_remote-port">
        <indexterm zone="f_remote-port"><primary><literal>REMOTE-PORT</literal></primary></indexterm>
        <refnamediv>
          <refname>REMOTE-PORT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>remote-port socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_remote-port">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_remote-port">
          <title>Description</title>
          <para>Returns the remote port number, or NIL if the socket is not
	  connected.</para>
        </refsect1>
      </refentry>
      <refentry id="f_local-host">
        <indexterm zone="f_local-host"><primary><literal>LOCAL-HOST</literal></primary></indexterm>
        <refnamediv>
          <refname>LOCAL-HOST</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>local-host socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_local-host">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_local-host">
          <title>Description</title>
          <para>Returns 32-bit unsigned IPv4 address or the 16 byte
	  IPv6 address of the local host.</para>
        </refsect1>
      </refentry>
      <refentry id="f_local-port">
        <indexterm zone="f_local-port"><primary><literal>LOCAL-PORT</literal></primary></indexterm>
        <refnamediv>
          <refname>LOCAL-PORT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>local-port socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_local-port">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_local-port">
          <title>Description</title>
          <para>Returns the local port number</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-address-family">
        <indexterm zone="f_socket-address-family"><primary><literal>SOCKET-ADDRESS-FAMILY</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ADDRESS-FAMILY</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-address-family thing</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-address-family">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>thing</parameter></term>
                <listitem><para>The socket or socket-address for which the
		address family is to be queried.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-address-family">
          <title>Description</title>
          <para>Returns :internet, :internet6 or :file, as appropriate.</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-address-host">
        <indexterm zone="f_socket-address-host"><primary><literal>SOCKET-ADDRESS-HOST</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ADDRESS-HOST</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-address-host socket-address</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-address-host">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket-address</parameter></term>
                <listitem><para>The socket-address for which the
		host address is to be queried.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-address-host">
          <title>Description</title>
          <para>Returns the host portion of the given socket-address.
	  For :internet addresses, this is a 32-bit integer.  For
	  :internet6 addresses, an array of 16 bytes returned.  For
	  :file addresses, it is the file name string.</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-address-port">
        <indexterm zone="f_socket-address-port"><primary><literal>SOCKET-ADDRESS-PORT</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ADDRESS-PORT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-address-port socket-address</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-address-port">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket-address</parameter></term>
                <listitem><para>The socket-address for which the
		port number is to be queried.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-address-port">
          <title>Description</title>
          <para>Returns the port number of the given socket-address.
	  This function is available only for :internet and :internet6
	  socket addresses.</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-connect">
        <indexterm zone="f_socket-connect"><primary><literal>SOCKET-CONNECT</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-CONNECT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-connect socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-connect">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-connect">
          <title>Description</title>
          <para>Returns :active for tcp-stream, :passive for
	  listener-socket, and NIL for udp-socket</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-format">
        <indexterm zone="f_socket-format"><primary><literal>SOCKET-FORMAT</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-FORMAT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-format socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-format">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-format">
          <title>Description</title>
          <para>Returns the socket format as specified by the :format
	  argument to make-socket.</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-type">
        <indexterm zone="f_socket-type"><primary><literal>SOCKET-TYPE</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-TYPE</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-type socket</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-type">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-type">
          <title>Description</title>
          <para>returns :stream for tcp-stream and listener-socket, and
	  :datagram for udp-socket.</para>
        </refsect1>
      </refentry>
      <refentry id="c_socket-address">
        <indexterm zone="c_socket-address"><primary><literal>CCL::SOCKET-ADDRESS</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::SOCKET-ADDRESS</refname>
          <refpurpose/>
          <refclass>Class</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>SOCKET-ADDRESS</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_c_socket-address">
          <title>Description</title>
          <para>Representation of a socket endpoint address.
          Instances of this class are used to encapsulate the host and
          port of an IP socket endpoint or the filename of a file
          socket.  They can be created by applications from a possibly
          symbolic address representation by the <indexterm><primary><literal>RESOLVE-ADDRESS</literal></primary></indexterm><link linkend="f_resolve-address"><literal>RESOLVE-ADDRESS</literal></link> function.</para>
        </refsect1>
      </refentry>
      <refentry id="c_socket-error">
        <indexterm zone="c_socket-error"><primary><literal>SOCKET-ERROR</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ERROR</refname>
          <refpurpose/>
          <refclass>Class</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>SOCKET-ERROR</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_c_socket-error">
          <title>Description</title>
          <para>The class of OS errors signaled by socket functions</para>
        </refsect1>
        <refsect1 id="superclasses_in_c_socket-error">
          <title>Superclasses</title>
          <para>simple-error</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-error-code">
        <indexterm zone="f_socket-error-code"><primary><literal>SOCKET-ERROR-CODE</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ERROR-CODE</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-error-code socket-error</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-error-code">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket-error</parameter></term>
                <listitem><para>the condition</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-error-code">
          <title>Description</title>
          <para>The OS error code of the error</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-error-identifier">
        <indexterm zone="f_socket-error-identifier"><primary><literal>SOCKET-ERROR-IDENTIFIER</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ERROR-IDENTIFIER</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-error-identifier socket-error</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-error-identifier">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket-error</parameter></term>
                <listitem><para>the condition</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-error-identifier">
          <title>Description</title>
          <para>A symbol representing the error code in a more
	  OS-independent way.</para>
          <para>	  One of: :address-in-use :connection-aborted :no-buffer-space
	  :connection-timed-out :connection-refused :host-unreachable
	  :host-down :network-down :address-not-available :network-reset
	  :connection-reset :shutdown :access-denied or :unknown.</para>
        </refsect1>
      </refentry>
      <refentry id="f_socket-error-situation">
        <indexterm zone="f_socket-error-situation"><primary><literal>SOCKET-ERROR-SITUATION</literal></primary></indexterm>
        <refnamediv>
          <refname>SOCKET-ERROR-SITUATION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>socket-error-situation socket-error</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_socket-error-situation">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket-error</parameter></term>
                <listitem><para>the condition</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_socket-error-situation">
          <title>Description</title>
          <para>A string describing the context where the error happened. On
	  Linux, this is the name of the system call which returned the
	  error.</para>
        </refsect1>
      </refentry>
      <refentry id="m_close">
        <indexterm zone="m_close"><primary><literal>CLOSE</literal></primary></indexterm>
        <refnamediv>
          <refname>CLOSE</refname>
          <refpurpose/>
          <refclass>Method</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>close (socket socket) <literal>&amp;key</literal> abort</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_close">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>socket</parameter></term>
                <listitem><para>The socket to close</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>abort</parameter></term>
                <listitem><para>If false (the default), closes the socket in an
		orderly fashion, finishing up any buffered pending I/O,
		before closing the connection. If true, aborts/ignores
		pending I/O. (For listener and udp sockets, this argument is
		effectively ignored since there is never any buffered I/O to
		clean up).</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_close">
          <title>Description</title>
          <para>The close generic function can be applied to sockets. It
	  releases the operating system resources associated with the
	  socket.</para>
        </refsect1>
      </refentry>
      <refentry id="m_with-open-socket">
        <indexterm zone="m_with-open-socket"><primary><literal>WITH-OPEN-SOCKET</literal></primary></indexterm>
        <refnamediv>
          <refname>WITH-OPEN-SOCKET</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-open-socket (var . make-socket-args) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_with-open-socket">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>var</parameter></term>
                <listitem><para>variable to bind</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>make-socket-args</parameter></term>
                <listitem><para>arguments suitable for passing to make-socket</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>body to execute</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_with-open-socket">
          <title>Description</title>
          <para>executes body with var bound to the result of applying
	  make-socket to make-socket-args. The socket gets closed on exit.</para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="running-other-programs-as-subprocesses">
    <title>Running Other Programs as Subprocesses</title>
    <section id="overview_in_running-other-programs-as-subprocesses">
      <title>Overview</title>
      <para>Clozure CL provides primitives to run external Unix programs,
      to select and connect Lisp streams to their input and output
      sources, to (optionally) wait for their completion and to check
      their execution and exit status.</para>
      <para>      All of the global symbols described below are exported
      from the CCL package.</para>
      <para>      This implementation is modeled on - and uses some code
      from - similar facilities in CMUCL.</para>
    </section>
    <section id="examples_in_running-other-programs-as-subprocesses">
      <title>Examples</title>
      <programlisting>
;;; Capture the output of the &quot;uname&quot; program in a lisp string-stream
;;; and return the generated string (which will contain a trailing
;;; newline.)
? (with-output-to-string (stream)
    (run-program &quot;uname&quot; '(&quot;-r&quot;) :output stream))
;;; Write a string to *STANDARD-OUTPUT*, the hard way.
? (run-program &quot;cat&quot; () :input (make-string-input-stream &quot;hello&quot;) :output t)
;;; Find out that &quot;ls&quot; doesn't expand wildcards.
? (run-program &quot;ls&quot; '(&quot;*.lisp&quot;) :output t)
;;; Let the shell expand wildcards.
? (run-program &quot;sh&quot; '(&quot;-c&quot; &quot;ls *.lisp&quot;) :output t)
</programlisting>
      <para>These last examples will only produce output if Clozure CL's
      current directory contains .lisp files, of course.</para>
    </section>
    <section id="limitations-and-known-bugs_in_running-other-programs-as-subprocesses">
      <title>Limitations and known bugs</title>
      <blockquote>
        <itemizedlist>
          <listitem><para>Clozure CL and the external process may get
        confused about who owns which streams when input, output, or
        error are specified as T and wait is specified as
        NIL.</para></listitem>
          <listitem><para>External processes that need to talk to a
        terminal device may not work properly; the environment (SLIME,
        ILISP) under which Clozure CL is run can affect
        this.</para></listitem>
        </itemizedlist>
      </blockquote>
    </section>
    <section id="external-program-dictionary">
      <title>External-Program Dictionary</title>
      <refentry id="f_run-program">
        <indexterm zone="f_run-program"><primary><literal>RUN-PROGRAM</literal></primary></indexterm>
        <refnamediv>
          <refname>RUN-PROGRAM</refname>
          <refpurpose>Invokes an external program as an OS subprocess
	    of lisp.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>run-program program args <literal>&amp;key</literal> (wait t) pty sharing input if-input-does-not-exist output (if-output-exists :error) (error :output) (if-error-exists :error) status-hook external-format env (silently-ignore-catastrophic-failures *silently-ignore-catastrophic-failure-in-run-program*)</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_run-program">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>program</parameter></term>
                <listitem><para>A string or pathname which denotes an executable file.
		  The PATH environment variable is used to find programs whose
		  name doesn't contain a directory component.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>args</parameter></term>
                <listitem><para>A list of simple-strings</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>wait</parameter></term>
                <listitem><para>Indicates whether or not run-program should wait for
		  the EXTERNAL-PROCESS to complete or should return
		  immediately.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>pty</parameter></term>
                <listitem><para>This option is accepted but currently ignored;
		  it's intended to make it easier to run external programs
		  that need to interact with a terminal device.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>sharing</parameter></term>
                <listitem><para>Sets a specific sharing mode
                  (see <xref linkend="additional-keywords-for-open-and-make-socket"/>) for any streams created
                  within RUN-PROGRAM when INPUT, OUTPUT or ERROR are requested
                  to be a :STREAM.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>input</parameter></term>
                <listitem><para>Selects the input source used by the EXTERNAL-PROCESS.
		  May be any of the following:</para><blockquote><itemizedlist><listitem><para>NIL Specifies that a null input stream (e.g.,
		      /dev/null) should be used.</para></listitem><listitem><para>T Specifies that the EXTERNAL-PROCESS should use
		      the input source with which Clozure CL was invoked.</para></listitem><listitem><para>A string or pathname. Specifies that the
		      EXTERNAL-PROCESS should receive its input from the named
		      existing file.</para></listitem><listitem><para>:STREAM Creates a Lisp stream opened for character
		      output. Any data written to this stream (accessible as
		      the EXTERNAL-PROCESS-INPUT-STREAM of the
		      EXTERNAL-PROCESS object) appears as input to the
		      external process.</para></listitem><listitem><para>A stream. Specifies that the lisp stream should
		      provide input to the EXTERNAL-PROCESS.</para></listitem></itemizedlist></blockquote></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>if-input-does-not-exist</parameter></term>
                <listitem><para>If the input argument specifies the name of an
		  existing file, this argument is used as the
		  if-does-not-exist argument to OPEN when that file is opened.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>output</parameter></term>
                <listitem><para>Specifies where standard output from the external
		  process should be sent. Analogous to input above.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>if-output-exists</parameter></term>
                <listitem><para>If output is specified as a string or pathname, this
		  argument is used as the if-exists argument to OPEN when that
		  file is opened.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>error</parameter></term>
                <listitem><para>Specifies where error output from the external process
		  should be sent. In addition to the values allowed for
		  output, the keyword :OUTPUT can be used to indicate that
		  error output should be sent where standard output goes.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>if-error-exists</parameter></term>
                <listitem><para>Analogous to if-output-exists.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>status-hook</parameter></term>
                <listitem><para>A user-defined function of one argument (the
		  EXTERNAL-PROCESS structure.) This function is called
		  whenever Clozure CL detects a change in the status of the
		  EXTERNAL-PROCESS.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>external-format</parameter></term>
                <listitem><para>
		    The external format (see <xref linkend="external-formats"/>) for all of the
		    streams (input, output, and error) used to
		    communicate with the external process.
		  </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>env</parameter></term>
                <listitem><para>
		    New OS environment variable bindings for the
		    external process.  By default the external process
		    inherits the environment of the running Lisp
		    process.  Env is an association list with elements
		    (&lt;Environment Variable
		    Name&gt; . &lt;Value&gt;). Name and
		    value are case sensitive strings. See <indexterm><primary><literal>SETENV</literal></primary></indexterm><link linkend="f_setenv"><literal>SETENV</literal></link>.
		  </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>&gt;silently-ignore-catastrophic-failures</parameter></term>
                <listitem><para>
		    If NIL, signal an error if run-program is unable
		    to start the program. If non-NIL, treat failure to
		    start the same as failure from the program itself,
		    by setting the status and exit-code
		    fields. Default is
		    <indexterm><primary><literal>CCL::*SILENTLY-IGNORE-CATASTROPHIC-FAILURE-IN-RUN-PROGRAM*</literal></primary></indexterm><literal>CCL::*SILENTLY-IGNORE-CATASTROPHIC-FAILURE-IN-RUN-PROGRAM*</literal>.
		  </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_run-program">
          <title>Description</title>
          <para>Runs the specified program in an external (Unix) process,
	    returning an object of type EXTERNAL-PROCESS if successful.</para>
          <para>            The implementation involves a lisp process/thread which
            monitors the status of this external process and arranges for
            the standard I/O descriptors for the external process to be
            connected to the specified lisp streams.  Since this may require
            the monitoring thread to do I/O on lisp streams in some cases,
            streams provided as the values of the <literal>:INPUT</literal>,
            <literal>:OUTPUT</literal>, and <literal>:ERROR</literal> arguments
            should not be private to some other lisp thread.</para>
        </refsect1>
      </refentry>
      <refentry id="f_signal-external-process">
        <indexterm zone="f_signal-external-process"><primary><literal>SIGNAL-EXTERNAL-PROCESS</literal></primary></indexterm>
        <refnamediv>
          <refname>SIGNAL-EXTERNAL-PROCESS</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>signal-external-process proc signal-number <literal>&amp;key</literal> (error-if-exited t)</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_signal-external-process">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>proc</parameter></term>
                <listitem><para>An EXTERNAL-PROCESS, as returned by RUN-PROGRAM.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>signal</parameter></term>
                <listitem><para>A small integer.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>error-if-exited</parameter></term>
                <listitem><para>A boolean, by default T.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_signal-external-process">
          <title>Description</title>
          <para>
	      Sends <parameter>signal</parameter> to the external process
	      <parameter>proc</parameter>. (Typically, it would only be
	      useful to call this function if the EXTERNAL-PROCESS was
	      created with :WAIT NIL.)</para>
          <para>	      If successful, the function returns T; otherwise, an
	      error is signaled.</para>
          <para>	      However, if <parameter>error-if-exited</parameter> is nil,
	      and the attempt to signal the external process fails
	      because the external process has already exited, the
	      function will return nil rather than signaling an error.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_external-process-id">
        <indexterm zone="f_external-process-id"><primary><literal>EXTERNAL-PROCESS-ID</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL-PROCESS-ID</refname>
          <refpurpose>Returns the &quot;process ID&quot; of an OS subprocess,
	    a positive integer which identifies it.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external-process-id proc</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_external-process-id">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>proc</parameter></term>
                <listitem><para>An EXTERNAL-PROCESS, as returned by RUN-PROGRAM.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_external-process-id">
          <title>Description</title>
          <para>Returns the <emphasis>process id</emphasis> assigned to
	    the external process by the operating system. This is typically
	    a positive, 16-bit number.</para>
        </refsect1>
      </refentry>
      <refentry id="f_external-process-input-stream">
        <indexterm zone="f_external-process-input-stream"><primary><literal>EXTERNAL-PROCESS-INPUT-STREAM</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL-PROCESS-INPUT-STREAM</refname>
          <refpurpose>Returns the lisp stream which is used to write
	    input to a given OS subprocess, if it has one.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external-process-input-stream proc</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_external-process-input-stream">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>proc</parameter></term>
                <listitem><para>An EXTERNAL-PROCESS, as returned by RUN-PROGRAM.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_external-process-input-stream">
          <title>Description</title>
          <para>Returns the stream created when the input argument to
	    run-program is specified as :STREAM.</para>
        </refsect1>
      </refentry>
      <refentry id="f_external-process-output-stream">
        <indexterm zone="f_external-process-output-stream"><primary><literal>EXTERNAL-PROCESS-OUTPUT-STREAM</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL-PROCESS-OUTPUT-STREAM</refname>
          <refpurpose>Returns the lisp stream which is used to read
	    output from an OS subprocess, if there is one.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external-process-output-stream proc</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_external-process-output-stream">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>proc</parameter></term>
                <listitem><para>An EXTERNAL-PROCESS, as returned by RUN-PROGRAM.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_external-process-output-stream">
          <title>Description</title>
          <para>Returns the stream created when the output argument to
	    run-program is specified as :STREAM.</para>
        </refsect1>
      </refentry>
      <refentry id="f_external-process-error-stream">
        <indexterm zone="f_external-process-error-stream"><primary><literal>EXTERNAL-PROCESS-ERROR-STREAM</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL-PROCESS-ERROR-STREAM</refname>
          <refpurpose>Returns the stream which is used to read
	    &quot;error&quot; output from a given OS subprocess, if it has
	    one.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external-process-error-stream proc</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_external-process-error-stream">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>proc</parameter></term>
                <listitem><para>An EXTERNAL-PROCESS, as returned by RUN-PROGRAM.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_external-process-error-stream">
          <title>Description</title>
          <para>Returns the stream created when the error argument to
	    run-program is specified as :STREAM.</para>
        </refsect1>
      </refentry>
      <refentry id="f_external-process-status">
        <indexterm zone="f_external-process-status"><primary><literal>EXTERNAL-PROCESS-STATUS</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL-PROCESS-STATUS</refname>
          <refpurpose>Returns information about whether an OS
	    subprocess is running; or, if not, why not; and what its
	    result code was if it completed.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external-process-status proc</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_external-process-status">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>proc</parameter></term>
                <listitem><para>An EXTERNAL-PROCESS, as returned by RUN-PROGRAM.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_external-process-status">
          <title>Description</title>
          <para>Returns, as multiple values, a keyword denoting the status
	    of the external process (one of :running, :stopped, :signaled, or
	    :exited), and the exit code or terminating signal if the first
	    value is other than :running.</para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="streams">
    <title>Streams</title>
    <section id="stream-extensions">
      <title>Stream Extensions</title>
      <section id="stream-external-format">
        <title>Stream External Format</title>
        <para><indexterm><primary><literal>STREAM-EXTERNAL-FORMAT</literal></primary></indexterm><literal>STREAM-EXTERNAL-FORMAT</literal> can be applied to
    (and may return a non-null result for) open streams that are not
    <literal>FILE-STREAM</literal>s.</para>
        <para>    <indexterm><primary><literal>(SETF STREAM-EXTERNAL-FORMAT)</literal></primary></indexterm><literal>(SETF STREAM-EXTERNAL-FORMAT)</literal> can be used to
    change the external format of open streams created with <indexterm><primary><literal>OPEN</literal></primary></indexterm><literal>OPEN</literal> or <indexterm><primary><literal>MAKE-SOCKET</literal></primary></indexterm><link linkend="f_make-socket"><literal>MAKE-SOCKET</literal></link>.
    </para>
      </section>
      <section id="additional-keywords-for-open-and-make-socket">
        <title>Additional keywords for OPEN and MAKE-SOCKET</title>
        <para><indexterm><primary><literal>OPEN</literal></primary></indexterm><literal>OPEN</literal> and
      <indexterm><primary><literal>MAKE-SOCKET</literal></primary></indexterm><link linkend="f_make-socket"><literal>MAKE-SOCKET</literal></link> have each been extended to take
      the additional keyword arguments: <literal>:CLASS</literal>,
      <literal>:SHARING</literal>, and
      <literal>:BASIC</literal>.</para>
        <blockquote>
          <variablelist>
            <varlistentry>
              <term><literal>:CLASS</literal></term>
              <listitem><para>A symbol that names the desired class of the stream.
	  The specified class must inherit from
	  <literal>FILE-STREAM</literal> for
	  <indexterm><primary><literal>OPEN</literal></primary></indexterm><literal>OPEN</literal>.</para></listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>:SHARING</literal></term>
              <listitem><para>Specifies how a stream can be used by multiple
	  threads.  The possible values are:
	  <literal>:PRIVATE</literal>, <literal>:LOCK</literal> and
	  <literal>:EXTERNAL</literal>. <literal>:PRIVATE</literal> is
	  the default.  <literal>NIL</literal> is also accepted as a
	  synonym for <literal>:EXTERNAL</literal>.</para><blockquote><variablelist><varlistentry><term><literal>:PRIVATE</literal></term><listitem><para>Specifies that the stream can only be accessed
		by the thread that first tries to do I/O to it; that
                thread becomes the &quot;owner&quot; of the stream and
                is not necessarily the same thread as the one which
                created the stream.  This is the default.
		(There was some discussion on openmcl-devel about the
		idea of &quot;transferring ownership&quot; of a stream; this has
		not yet been implemented.)  Attempts to do I/O on a
		stream with :PRIVATE sharing from a thread other than
		the stream's owner yield an error.</para></listitem></varlistentry><varlistentry><term><literal>:LOCK</literal></term><listitem><para>Specifies that all access to the stream require
		the calling thread to obtain a lock. There are
		separate &quot;read&quot; and &quot;write&quot; locks for IO streams.
		This makes it possible for instance, for one thread to
		read from such a stream while another thread writes to
		it.  (see also <indexterm><primary><literal>MAKE-READ-WRITE-LOCK</literal></primary></indexterm><link linkend="f_make-read-write-lock"><literal>MAKE-READ-WRITE-LOCK</literal></link><indexterm><primary><literal>WITH-READ-LOCK</literal></primary></indexterm><link linkend="m_with-read-lock"><literal>WITH-READ-LOCK</literal></link><indexterm><primary><literal>WITH-WRITE-LOCK</literal></primary></indexterm><link linkend="m_with-write-lock"><literal>WITH-WRITE-LOCK</literal></link>)</para></listitem></varlistentry><varlistentry><term><literal>:EXTERNAL</literal></term><listitem><para>Specifies that I/O primitives enforce no access
		protocol.  This may be appropriate for some types of
		application which can control stream access via
		application-level protocols.  Note that since even the
		act of reading from a stream changes its internal
		state (and simultaneous access from multiple threads
		can therefore lead to corruption of that state), some
		care must be taken in the design of such protocols.</para></listitem></varlistentry></variablelist></blockquote></listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>:BASIC</literal></term>
              <listitem><para>A boolean that indicates whether or not the stream is
	  a Gray stream, i.e. whether or not the stream is an instance
	  of <literal>FUNDAMENTAL-STREAM</literal> or
	  <literal>CCL::BASIC-STREAM</literal>(see <xref linkend="basic-versus-fundamental-streams"/>).  Defaults to
	  <literal>T</literal>.</para></listitem>
            </varlistentry>
          </variablelist>
        </blockquote>
      </section>
      <section id="basic-versus-fundamental-streams">
        <title>Basic Versus Fundamental Streams</title>
        <para>Gray streams (see <xref linkend="creating-your-own-stream-classes-with-gray-streams"/>)
      all inherit from <literal>FUNDAMENTAL-STREAM</literal> whereas
      basic streams inherit from <literal>CCL::BASIC-STREAM</literal>.
      The tradeoff between FUNDAMENTAL and BASIC streams is entirely
      between flexibility and performance, potential or actual.  I/O
      primitives can recognize BASIC-STREAMs and exploit knowledge of
      implementation details. FUNDAMENTAL stream classes can be
      subclassed and extended in a standard way (the Gray streams
      protocol).</para>
        <para>      For existing stream classes (FILE-STREAMs, SOCKETs, and
      the internal CCL::FD-STREAM classes used to implement file
      streams and sockets), a lot of code can be shared between the
      FUNDAMENTAL and BASIC implementations.  The biggest difference
      should be that that code can be reached from I/O primitives like
      READ-CHAR without going through some steps that're there to
      support generality and extensibility, and skipping those steps
      when that support isn't needed can improve I/O performance.</para>
        <para>      The Gray stream method
      <indexterm><primary><literal>STREAM-READ-CHAR</literal></primary></indexterm><literal>STREAM-READ-CHAR</literal> should work on appropriate
      <literal>BASIC-STREAM</literal>s.  (There may still be cases
      where such methods are undefined; such cases should be
      considered bugs.)  It is not guaranteed that Gray stream methods
      would ever be called by I/O primitives to read a character from
      a <literal>BASIC-STREAM</literal>, though there are still cases
      where this happens.</para>
        <para>      A simple loop reading 2M characters from a text file runs
      about 10X faster when the file is opened the new defaults
      <literal>(:SHARING :PRIVATE :BASIC T)</literal> than it had
      before these changes were made.  That sounds good, until one
      realizes that the &quot;equivalent&quot; C loop can be about 10X faster
      still ...</para>
      </section>
      <section id="stream-timeouts-and-deadlines">
        <title>Stream Timeouts and Deadlines</title>
        <para>A stream that is associated with a file descriptor has
        attributes and accessors:
        <indexterm><primary><literal>STREAM-INPUT-TIMEOUT</literal></primary></indexterm><literal>STREAM-INPUT-TIMEOUT</literal>,
        <indexterm><primary><literal>STREAM-OUTPUT-TIMEOUT</literal></primary></indexterm><literal>STREAM-OUTPUT-TIMEOUT</literal>, and
        <indexterm><primary><literal>STREAM-DEADLINE</literal></primary></indexterm><literal>STREAM-DEADLINE</literal>.  All three accessors have
        corresponding <indexterm><primary><literal>SETF</literal></primary></indexterm><literal>SETF</literal> methods.
        <indexterm><primary><literal>STREAM-INPUT-TIMEOUT</literal></primary></indexterm><literal>STREAM-INPUT-TIMEOUT</literal> and
        <indexterm><primary><literal>STREAM-OUTPUT-TIMEOUT</literal></primary></indexterm><literal>STREAM-OUTPUT-TIMEOUT</literal> are specified in
        seconds and can be any positive real number less than one million.
        When a timeout is set and the corresponding I/O operation takes
        longer than the specified interval, an error is signalled.  The
        error is <literal>INPUT-TIMEOUT</literal> for input and
        <literal>OUTPUT-TIMEOUT</literal> for output.
        <literal>STREAM-DEADLINE</literal> specifies an absolute time in
        internal-time-units.  If an I/O operation on the stream does not
        complete before the deadline then a
        <literal>COMMUNICATION-DEADLINE-EXPIRED</literal> error is
        signalled.  A deadline takes precedence over any
        input/output timeouts that may be set.</para>
      </section>
      <section id="open-file-streams">
        <title>Open File Streams</title>
        <para>Historically, Clozure CL and MCL maintained a list of open
        file streams in the value of
        <literal>CCL:*OPEN-FILE-STREAMS*</literal>.  This functionality
        has been replaced with the thread-safe function:
        <literal>CCL:OPEN-FILE-STREAMS</literal> and its two helper
        functions: <literal>CCL:NOTE-OPEN-FILE-STREAM</literal> and
        <literal>CCL:REMOVE-OPEN-FILE-STREAM</literal>.  Maintaining
        this list helps to ensure that streams get closed in an orderly
        manner when the lisp exits.</para>
        <refentry id="f_open-file-streams">
          <indexterm zone="f_open-file-streams"><primary><literal>OPEN-FILE-STREAMS</literal></primary></indexterm>
          <refnamediv>
            <refname>OPEN-FILE-STREAMS</refname>
            <refpurpose>Returns the list of file streams that are currently open.</refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>open-file-streams =&gt; stream-list</synopsis></refsynopsisdiv>
          <refsect1 id="values_in_f_open-file-streams">
            <title>Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream-list</parameter></term>
                  <listitem><para>A list of open file streams.  This is a copy of
		          an internal list so it may be destructively
		          modified without ill effect.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_open-file-streams">
            <title>Description</title>
            <para>Returns a list of open file streams.</para>
          </refsect1>
          <refsect1 id="see-also_in_f_open-file-streams">
            <title>See Also</title>
            <para><indexterm><primary><literal>NOTE-OPEN-FILE-STREAM</literal></primary></indexterm><link linkend="f_note-open-file-stream"><literal>NOTE-OPEN-FILE-STREAM</literal></link>, <indexterm><primary><literal>REMOVE-OPEN-FILE-STREAM</literal></primary></indexterm><link linkend="f_remove-open-file-stream"><literal>REMOVE-OPEN-FILE-STREAM</literal></link></para>
          </refsect1>
        </refentry>
        <refentry id="f_note-open-file-stream">
          <indexterm zone="f_note-open-file-stream"><primary><literal>NOTE-OPEN-FILE-STREAM</literal></primary></indexterm>
          <refnamediv>
            <refname>NOTE-OPEN-FILE-STREAM</refname>
            <refpurpose>Adds a file stream to the internal list of open
	        file streams that is returned by
	        <indexterm><primary><literal>NOTE-OPEN-FILE-STREAM</literal></primary></indexterm><link linkend="f_note-open-file-stream"><literal>NOTE-OPEN-FILE-STREAM</literal></link>.</refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>note-open-file-stream file-stream</synopsis></refsynopsisdiv>
          <refsect1 id="arguments_in_f_note-open-file-stream">
            <title>Arguments</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>file-stream</parameter></term>
                  <listitem><para>A file stream.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_note-open-file-stream">
            <title>Description</title>
            <para>Adds a file stream to the internal list of open
	        file streams that is returned by
	        <indexterm><primary><literal>OPEN-FILE-STREAMS</literal></primary></indexterm><link linkend="f_open-file-streams"><literal>OPEN-FILE-STREAMS</literal></link>.  This function is
	        thread-safe.  It will usually only be called from custom
	        stream code when a file-stream is created.</para>
          </refsect1>
          <refsect1 id="see-also_in_f_note-open-file-stream">
            <title>See Also</title>
            <para><indexterm><primary><literal>OPEN-FILE-STREAMS</literal></primary></indexterm><link linkend="f_open-file-streams"><literal>OPEN-FILE-STREAMS</literal></link>, <indexterm><primary><literal>REMOVE-OPEN-FILE-STREAM</literal></primary></indexterm><link linkend="f_remove-open-file-stream"><literal>REMOVE-OPEN-FILE-STREAM</literal></link></para>
          </refsect1>
        </refentry>
        <refentry id="f_remove-open-file-stream">
          <indexterm zone="f_remove-open-file-stream"><primary><literal>REMOVE-OPEN-FILE-STREAM</literal></primary></indexterm>
          <refnamediv>
            <refname>REMOVE-OPEN-FILE-STREAM</refname>
            <refpurpose>Removes file stream from the internal list of open
	        file streams that is returned by
	        <indexterm><primary><literal>OPEN-FILE-STREAMS</literal></primary></indexterm><link linkend="f_open-file-streams"><literal>OPEN-FILE-STREAMS</literal></link>.</refpurpose>
            <refclass>Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>remove-open-file-stream file-stream</synopsis></refsynopsisdiv>
          <refsect1 id="arguments_in_f_remove-open-file-stream">
            <title>Arguments</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>file-stream</parameter></term>
                  <listitem><para>A file stream.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_remove-open-file-stream">
            <title>Description</title>
            <para>Remove file stream from the internal list of open file
	        streams that is returned by
	        <indexterm><primary><literal>OPEN-FILE-STREAMS</literal></primary></indexterm><link linkend="f_open-file-streams"><literal>OPEN-FILE-STREAMS</literal></link>.  This function is
	        thread-safe.  It will usually only be called from custom
	        stream code when a file-stream is closed.</para>
          </refsect1>
          <refsect1 id="see-also_in_f_remove-open-file-stream">
            <title>See Also</title>
            <para><indexterm><primary><literal>OPEN-FILE-STREAMS</literal></primary></indexterm><link linkend="f_open-file-streams"><literal>OPEN-FILE-STREAMS</literal></link>, <indexterm><primary><literal>NOTE-OPEN-FILE-STREAM</literal></primary></indexterm><link linkend="f_note-open-file-stream"><literal>NOTE-OPEN-FILE-STREAM</literal></link></para>
          </refsect1>
        </refentry>
      </section>
    </section>
    <section id="creating-your-own-stream-classes-with-gray-streams">
      <title>Creating Your Own Stream Classes with Gray Streams</title>
      <section id="overview_in_creating-your-own-stream-classes-with-gray-streams">
        <title>Overview</title>
        <para>This sect1 is still being written and revised, because
        it is woefully incomplete.  The dictionary section currently
        only lists a couple functions.  Caveat lector.</para>
        <para>        Gray streams are an extension to Common Lisp.  They were
        proposed for standardization by David Gray (the astute reader
        now understands their name) quite some years ago, but not
        accepted, because they had not been tried sufficiently to find
        conceptual problems with them.</para>
        <para>        They have since been implemented by quite a few modern
        Lisp implementations.  However, they do indeed have some
        inadequacies, and each implementation has addressed these in
        different ways.  The situation today is that it's difficult to
        even find out how to get started using Gray streams.  This is
        why standards are important.</para>
        <para>        Here's a list of some classes which you might wish for
        your new stream class to inherit from:</para>
        <blockquote>
          <simplelist>
            <member>fundamental-stream</member>
            <member>fundamental-input-stream</member>
            <member>fundamental-output-stream</member>
            <member>fundamental-character-stream</member>
            <member>fundamental-binary-stream</member>
            <member>fundamental-character-input-stream</member>
            <member>fundamental-character-output-stream</member>
            <member>fundamental-binary-input-stream</member>
            <member>fundamental-binary-output-stream</member>
            <member>ccl::buffered-stream-mixin</member>
            <member>ccl::buffered-input-stream-mixin</member>
            <member>ccl::buffered-output-stream-mixin</member>
            <member>ccl::buffered-io-stream-mixin</member>
            <member>ccl::buffered-character-input-stream-mixin</member>
            <member>ccl::buffered-character-output-stream-mixin</member>
            <member>ccl::buffered-character-io-stream-mixin</member>
            <member>ccl::buffered-binary-input-stream-mixin</member>
            <member>ccl::buffered-binary-output-stream-mixin</member>
            <member>ccl::buffered-binary-io-stream-mixin</member>
            <member>file-stream</member>
            <member>file-input-stream</member>
            <member>file-output-stream</member>
            <member>file-io-stream</member>
            <member>file-character-input-stream</member>
            <member>file-character-output-stream</member>
            <member>file-character-io-stream</member>
            <member>file-binary-input-stream</member>
            <member>file-binary-output-stream</member>
            <member>file-binary-io-stream</member>
            <member>ccl::fd-stream</member>
            <member>ccl::fd-input-stream</member>
            <member>ccl::fd-output-stream</member>
            <member>ccl::fd-io-stream</member>
            <member>ccl::fd-character-input-stream</member>
            <member>ccl::fd-character-output-stream</member>
            <member>ccl::fd-character-io-stream</member>
            <member>ccl::fd-binary-input-stream</member>
            <member>ccl::fd-binary-output-stream</member>
            <member>ccl::fd-binary-io-stream</member>
          </simplelist>
        </blockquote>
        <para>All of these are defined in ccl/level-1/l1-streams.lisp,
        except for the ccl:file-* ones, which are in
        ccl/level-1/l1-sysio.lisp.</para>
        <para>        According to the original Gray streams proposal, you
        should inherit from the most specific of the fundamental-*
        classes which applies.  Using Clozure CL, though, if you want
        buffering for better performance, which, unless you know of some
        reason you wouldn't, you do, you should instead inherit from the
        appropriate ccl::buffered-* class The buffering you get this way
        is exactly the same as the buffering which is used on ordinary,
        non-Gray streams, and force-output will work properly on
        it.</para>
        <para>        Notice that -mixin suffix in the names of all the
        ccl::buffered-* classes?  The suffix means that this class is
        not &quot;complete&quot; by itself; you still need to inherit from a
        fundamental-* stream, even if you also inherit from a *-mixin
        stream.  You might consider making your own class like this.
        ....  Except that they do inherit from the fundamental-*
        streams, that's weird.</para>
        <para>        If you want to be able to create an instance of your class
        with the :class argument to (open) and (with-open-file), you
        should make it inherit from one of the file-* classes.  If you
        do this, it's not necessary to inherit from any of the other
        classes (though it won't hurt anything), since the file-*
        classes already do.</para>
        <para>        When you inherit from the file-* classes, you can use
        (call-next-method) in any of your methods to get the standard
        behavior.  This is especially useful if you want to create a
        class which performs some simple filtering operation, such as
        changing everything to uppercase or to a different character
        encoding.  If you do this, you will definitely need to
        specialize ccl::select-stream-class.  Your method on
        ccl::stream-select-class should accept an instance of the class,
        but pay no attention to its contents, and return a symbol naming
        the class to actually be instantiated.</para>
        <para>        If you need to make your functionality generic across all
        the different types of stream, probably the best way to
        implement it is to make it a mixin, define classes with all the
        variants of input, output, io, character, and binary, which
        inherit both from your mixin and from the appropriate other
        class, then define a method on ccl::select-stream-class which
        chooses from among those classes.</para>
        <para>        Note that some of these classes are internal to the CCL
        package.  If you try to inherit from those ones without the
        ccl:: prefix, you'll get an error which may confuse you, calling
        them &quot;forward-referenced classes&quot;.  That just means you used the
        wrong symbol, so add the prefix.</para>
        <para>        Here's a list of some generic functions which you might
        wish to specialize for your new stream class, and which ought to
        be documented at some point.</para>
        <blockquote>
          <simplelist>
            <member>stream-direction stream =&gt;</member>
            <member>stream-device stream direction =&gt;</member>
            <member>stream-length stream <literal>&amp;optional</literal> new =&gt;</member>
            <member>stream-position stream <literal>&amp;optional</literal> new =&gt;</member>
            <member>streamp stream =&gt; boolean</member>
            <member>stream-write-char output-stream char =&gt;</member>
            <member>stream-write-entire-string output-stream string =&gt;</member>
            <member>stream-read-char input-stream =&gt;</member>
            <member>stream-unread-char input-stream char =&gt;</member>
            <member>stream-force-output output-stream =&gt; nil</member>
            <member>stream-maybe-force-output output-stream =&gt; nil</member>
            <member>stream-finish-output output-stream =&gt; nil</member>
            <member>stream-clear-output output-stream =&gt; nil</member>
            <member>close stream <literal>&amp;key</literal> abort =&gt; boolean</member>
            <member>stream-fresh-line stream =&gt; t</member>
            <member>stream-line-length stream =&gt; length</member>
            <member>interactive-stream-p stream =&gt; boolean</member>
            <member>stream-clear-input input-stream =&gt; nil</member>
            <member>stream-listen input-stream =&gt; boolean</member>
            <member>stream-filename stream =&gt; string</member>
            <member>ccl::select-stream-class instance in-p out-p char-p =&gt;
	      class</member>
          </simplelist>
        </blockquote>
        <para>The following functions are standard parts of Common Lisp, but
        behave in special ways with regard to Gray streams.</para>
        <blockquote>
          <simplelist>
            <member>open-stream-p stream =&gt; generalized-boolean</member>
            <member>input-stream-p stream =&gt; generalized-boolean</member>
            <member>output-stream-p stream =&gt; generalized-boolean</member>
            <member>stream-element-type stream =&gt;</member>
            <member>stream-error-stream =&gt;</member>
            <member>open</member>
            <member>close</member>
            <member>with-open-file</member>
          </simplelist>
        </blockquote>
        <para>Specifically, (open) and (with-open-file) accept a new
        keyword argument, :class, which may be a symbol naming a class;
        the class itself; or an instance of it.  The class so given must
        be a subtype of 'stream, and an instance of it with no
        particular contents will be passed to ccl::select-stream-class
        to determine what class to actually instantiate.</para>
        <para>        The following are standard, and do not behave specially
        with regard to Gray streams, but probably should.</para>
        <blockquote>
          <simplelist>
            <member>stream-external-format</member>
          </simplelist>
        </blockquote>
      </section>
      <section id="extending-read-sequence-and-write-sequence">
        <title>Extending READ-SEQUENCE and WRITE-SEQUENCE</title>
        <section id="overview_in_extending-read-sequence-and-write-sequence">
          <title>Overview</title>
          <para>The &quot;Gray Streams&quot; API is based on an informal proposal that was
	      made before ANSI CL adopted the READ-SEQUENCE and WRITE-SEQUENCE
	      functions; as such, there is no &quot;standard&quot; way for the author of a Gray
	      stream class to improve the performance of these functions by exploiting
	      knowledge of the stream's internals (e.g., the buffering mechanism it
	      uses.)</para>
          <para>	      In the absence of any such knowledge, READ-SEQUENCE and
	      WRITE-SEQUENCE are effectively just convenient shorthand for a
	      loop which calls READ-CHAR/READ-BYTE/WRITE-CHAR/WRITE-BYTE as
	      appropriate. The mechanism described below allows subclasses
	      of FUNDAMENTAL-STREAM to define more specialized (and
	      presumably more efficient) behavior.</para>
        </section>
        <section id="notes_in_extending-read-sequence-and-write-sequence">
          <title>Notes</title>
          <para>READ-SEQUENCE and WRITE-SEQUENCE do a certain amount of
	      sanity-checking and normalization of their arguments before
	      dispatching to one of the methods above. If an individual
	      method can't do anything particularly clever, CALL-NEXT-METHOD
	      can be used to handle the general case.</para>
        </section>
        <section id="example_in_extending-read-sequence-and-write-sequence">
          <title>Example</title>
          <programlisting><para>
(defclass my-string-input-stream (fundamental-character-input-stream)
  ((string :initarg :string :accessor my-string-input-stream-string)
   (index :initform 0 :accessor my-string-input-stream-index)
   (length)))</para><para>(defmethod stream-read-vector ((stream my-string-input-stream) vector start end)
  (if (not (typep vector 'simple-base-string))
      (call-next-method)
      (with-slots (string index length)
	      (do* ((outpos start (1+ outpos)))
               ((or (= outpos end)
                    (= index length))
                outpos))
        (setf (schar vector outpos)
              (schar string index))
        (incf index)))))
	    </para></programlisting>
        </section>
      </section>
      <section id="multibyte-i-o">
        <title>Multibyte I/O</title>
        <para>All heap-allocated objects in Clozure CL that cannot contain
        pointers to lisp objects are represented as
        <emphasis>ivectors</emphasis>. Clozure CL provides low-level
        functions, and , to efficiently transfer data between buffered
        streams and ivectors. There's some overlap in functionality
        between the functions described here and the ANSI CL
        READ-SEQUENCE and WRITE-SEQUENCE functions.</para>
        <para>        As used here, the term &quot;octet&quot; means roughly the same
        thing as the term &quot;8-bit byte&quot;. The functions described below
        transfer a specified sequence of octets between a buffered
        stream and an ivector, and don't really concern themselves with
        higher-level issues (like whether that octet sequence is within
        bounds or how it relates to the logical contents of the
        ivector.) For these reasons, these functions are generally less
        safe and more flexible than their ANSI counterparts.</para>
      </section>
      <section id="gray-streams-dictionary">
        <title>Gray Streams Dictionary</title>
        <refentry id="f_stream-read-list">
          <indexterm zone="f_stream-read-list"><primary><literal>STREAM-READ-LIST</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-READ-LIST</refname>
            <refpurpose/>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>stream-read-list stream list count</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_stream-read-list">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream</parameter></term>
                  <listitem><para>a stream, presumably a fundamental-input-stream.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>list</parameter></term>
                  <listitem><para>a list. When a STREAM-READ-LIST method is called by
		          READ-SEQUENCE, this argument is guaranteed to be a proper
		          list.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>count</parameter></term>
                  <listitem><para>a non-negative integer. When a STREAM-READ-LIST method
		          is called by READ-SEQUENCE, this argument is guaranteed not
		          to be greater than the length of the list.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_stream-read-list">
            <title>Description</title>
            <para>Should try to read up to count elements from stream into the
	        list list, returning the number of elements actually read (which
	        may be less than count in case of a premature end-of-file.)</para>
          </refsect1>
        </refentry>
        <refentry id="f_stream-write-list">
          <indexterm zone="f_stream-write-list"><primary><literal>STREAM-WRITE-LIST</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-WRITE-LIST</refname>
            <refpurpose/>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>stream-write-list stream list count</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_stream-write-list">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream</parameter></term>
                  <listitem><para>a stream, presumably a fundamental-output-stream.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>list</parameter></term>
                  <listitem><para>a list. When a STREAM-WRITE-LIST method is called by
		          WRITE-SEQUENCE, this argument is guaranteed to be a proper
		          list.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>count</parameter></term>
                  <listitem><para>a non-negative integer. When a STREAM-WRITE-LIST
		          method is called by WRITE-SEQUENCE, this argument is
		          guaranteed not to be greater than the length of the list.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_stream-write-list">
            <title>Description</title>
            <para>should try to write the first count elements of list to
	        stream. The return value of this method is ignored.</para>
          </refsect1>
        </refentry>
        <refentry id="f_stream-read-vector">
          <indexterm zone="f_stream-read-vector"><primary><literal>STREAM-READ-VECTOR</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-READ-VECTOR</refname>
            <refpurpose/>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>stream-read-vector stream vector start end</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_stream-read-vector">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream</parameter></term>
                  <listitem><para>a stream, presumably a fundamental-input-stream</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>vector</parameter></term>
                  <listitem><para>a vector. When a STREAM-READ-VECTOR method is called
		          by READ-SEQUENCE, this argument is guaranteed to be a simple
		          one-dimensional array.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>start</parameter></term>
                  <listitem><para>a non-negative integer. When a STREAM-READ-VECTOR
		          method is called by READ-SEQUENCE, this argument is
		          guaranteed to be no greater than end and not greater than
		          the length of vector.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>end</parameter></term>
                  <listitem><para>a non-negative integer. When a STREAM-READ-VECTOR
		          method is called by READ-SEQUENCE, this argument is
		          guaranteed to be no less than end and not greater than the
		          length of vector.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_stream-read-vector">
            <title>Description</title>
            <para>should try to read successive elements from stream into
	        vector, starting at element start (inclusive) and continuing
	        through element end (exclusive.) Should return the index of the
	        vector element beyond the last one stored into, which may be less
	        than end in case of premature end-of-file.</para>
          </refsect1>
        </refentry>
        <refentry id="f_stream-write-vector">
          <indexterm zone="f_stream-write-vector"><primary><literal>STREAM-WRITE-VECTOR</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-WRITE-VECTOR</refname>
            <refpurpose/>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>stream-write-vector stream vector start end</synopsis></refsynopsisdiv>
          <refsect1 id="arguments-and-values_in_f_stream-write-vector">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream</parameter></term>
                  <listitem><para>a stream, presumably a fundamental-output-stream</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>vector</parameter></term>
                  <listitem><para>a vector. When a STREAM-WRITE-VECTOR method is called
		          by WRITE-SEQUENCE, this argument is guaranteed to be a
		          simple one-dimensional array.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>start</parameter></term>
                  <listitem><para>a non-negative integer. When a STREAM-WRITE-VECTOR
		          method is called by WRITE-SEQUENCE, this argument is
		          guaranteed to be no greater than end and not greater than
		          the length of vector.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>end</parameter></term>
                  <listitem><para>a non-negative integer. When a STREAM-WRITE-VECTOR
		          method is called by WRITE-SEQUENCE, this argument is
		          guaranteed to be no less than end and not greater than the
		          length of vector.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_stream-write-vector">
            <title>Description</title>
            <para>should try to write successive elements of vector to stream,
	        starting at element start (inclusive) and continuing through
	        element end (exclusive.)</para>
          </refsect1>
        </refentry>
        <refentry id="f_stream-device">
          <indexterm zone="f_stream-device"><primary><literal>STREAM-DEVICE</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-DEVICE</refname>
            <refpurpose>Returns the OS file descriptor associated with a
	        given lisp stream.</refpurpose>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>ccl::stream-device s direction</synopsis></refsynopsisdiv>
          <refsect1 id="method-signatures">
            <title>Method Signatures</title>
            <para><literal><indexterm><primary><literal>STREAM-DEVICE</literal></primary></indexterm><link linkend="f_stream-device"><literal>STREAM-DEVICE</literal></link>
	        (s stream) direction =&gt; fd</literal></para>
          </refsect1>
          <refsect1 id="arguments-and-values_in_f_stream-device">
            <title>Arguments and Values</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>s</parameter></term>
                  <listitem><para>a stream.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>direction</parameter></term>
                  <listitem><para>either :INPUT or :OUTPUT.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>fd</parameter></term>
                  <listitem><para>a file descriptor, which is a non-negative integer
		          used by the OS to refer to an open file, socket, or similar
		          I/O connection.  NIL if there is no file descriptor associated
		          with <parameter>s</parameter> in the direction given by
		          <parameter>direction</parameter>.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="description_in_f_stream-device">
            <title>Description</title>
            <para>Returns the file descriptor associated with
	        <parameter>s</parameter> in the direction given by
	        <parameter>direction</parameter>.  It is necessary to specify
	        <parameter>direction</parameter> because the input and output
	        file descriptors may be different; the most common case is when
	        one of them has been redirected by the Unix shell.</para>
          </refsect1>
        </refentry>
        <refentry id="f_stream-read-ivector">
          <indexterm zone="f_stream-read-ivector"><primary><literal>STREAM-READ-IVECTOR</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-READ-IVECTOR</refname>
            <refpurpose/>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>stream-read-ivector stream ivector start-octet max-octets</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_stream-read-ivector">
            <title>Description</title>
            <para>Reads up to max-octets octets from stream into ivector,
	        storing them at start-octet. Returns the number of octets actually
	        read.</para>
          </refsect1>
          <refsect1 id="arguments_in_f_stream-read-ivector">
            <title>Arguments</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream</parameter></term>
                  <listitem><para>An input stream. The method defined on
		          BUFFERED-INPUT-STREAMs requires that the size in octets of
		          an instance of the stream's element type is 1.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>ivector</parameter></term>
                  <listitem><para>Any ivector.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>start-octet</parameter></term>
                  <listitem><para>A non-negative integer.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>max-octets</parameter></term>
                  <listitem><para>A non-negative integer. The return value may be less
		          than the value of this parameter if EOF was encountered.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
        </refentry>
        <refentry id="f_stream-write-ivector">
          <indexterm zone="f_stream-write-ivector"><primary><literal>STREAM-WRITE-IVECTOR</literal></primary></indexterm>
          <refnamediv>
            <refname>STREAM-WRITE-IVECTOR</refname>
            <refpurpose/>
            <refclass>Generic Function</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>stream-write-ivector stream ivector start-octet max-octets</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_f_stream-write-ivector">
            <title>Description</title>
            <para>Writes max-octets octets to stream from ivector, starting at
	        start-octet. Returns max-octets.</para>
          </refsect1>
          <refsect1 id="arguments_in_f_stream-write-ivector">
            <title>Arguments</title>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>stream</parameter></term>
                  <listitem><para>An input stream. The method defined on
		          BUFFERED-OUTPUT-STREAMs requires that the size in octets of
		          an instance of the stream's element type is 1.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>ivector</parameter></term>
                  <listitem><para>Any ivector</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>start-octet</parameter></term>
                  <listitem><para>A non-negative integer.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>max-octet</parameter></term>
                  <listitem><para>A non-negative integer.</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
          <refsect1 id="examples_in_f_stream-write-ivector">
            <title>Examples</title>
            <programlisting><para>
;;; Write the contents of a (SIMPLE-ARRAY(UNSIGNED-BYTE 16) 3) 
;;; to a character file stream. Read back the characters.
(let* ((a (make-array 3 
                      :element-type '(unsigned-byte 16)
                      :initial-contents '(26725 27756 28449))))
  (with-open-file (s &quot;junk&quot;
                     :element-type 'character
                     :direction :io
                     :if-does-not-exist :create
                     :if-exists :supersede)
    ;; Write six octets (three elements).
    (stream-write-ivector s a 0 6)
    ;; Rewind, then read a line
    (file-position s 0)
    (read-line s)))</para><para>;;; Write a vector of DOUBLE-FLOATs. Note that (to maintain
;;; alignment) there are 4 octets of padding before the 0th 
;;; element of a (VECTOR DOUBLE-FLOAT) on 32-bit platforms.
;;; (Note that (= (- target::misc-dfloat-offset 
;;;                  target::misc-data-offset) 4))
(defun write-double-float-vector
    (stream vector &amp;key (start 0) (end (length vector)))
     (check-type vector (vector double-float))
     (let* ((start-octet (+ (* start 8) 
                            (- target::misc-dfloat-offset
                               target::misc-data-offset)))
	        (num-octets (* 8 (- end start))))
       (stream-write-ivector stream vector start-octet num-octets)))
          </para></programlisting>
          </refsect1>
        </refentry>
      </section>
    </section>
    <section id="lisp-standard-streams-and-os-standard-streams">
      <title>Lisp Standard Streams and OS Standard Streams</title>
      <para>
      In normal interactive usage, the input and output sides of the
      bidirectional stream <literal>*terminal-io*</literal> are hooked
      up to the the operating system's standard input and standard
      output.  The lisp streams <literal>*standard-input*</literal>,
      <literal>*standard-output*</literal>, and
      <literal>*error-output*</literal> are synonym streams for
      <literal>*terminal-io*</literal>.</para>
      <para>      In batch mode, this arrangement is modified slightly.  The lisp
      streams <literal>*standard-input*</literal>,
      <literal>*standard-output*</literal>, and
      <literal>*standard-error*</literal> correspond directly to the
      operating system's standard input, standard output, and standard
      error.  If the lisp can determine that it has access to an
      operating system tty, then <literal>*terminal-io*</literal> will
      be hooked up to that.  Otherwise, the input and output streams
      of <literal>*terminal-io*</literal> will correspond to the
      operating system's standard input and standard output.
    </para>
    </section>
  </chapter>
  <chapter id="writing-portable-extensions-to-the-object-system-using-the-metaobject-protocol">
    <title>Writing Portable Extensions to the Object System  using the MetaObject Protocol</title>
    <section id="overview_in_writing-portable-extensions-to-the-object-system-using-the-metaobject-protocol">
      <title>Overview</title>
      <para>Clozure CL supports a fairly large subset of the
      semi-standard MetaObject Protocol (MOP) for CLOS, as defined in
      chapters 5 and 6 of &quot;The Art Of The Metaobject Protocol&quot;,
      (Kiczales et al, MIT Press 1991, ISBN 0-262-61074-4); this
      specification is also available online at
      http://www.alu.org/mop/index.html.</para>
    </section>
    <section id="implementation-status">
      <title>Implementation status</title>
      <para>The keyword :openmcl-partial-mop is on *FEATURES* to
      indicate the presence of this functionality.</para>
      <para>      All of the symbols defined in the MOP specification
      (whether implemented or not) are exported from the &quot;CCL&quot; package
      and from an &quot;OPENMCL-MOP&quot; package.</para>
      <para><table id="tab_mop-implementation-status"><title>MOP Implementation Status</title><tgroup cols="2"><thead><row><entry>construct</entry><entry>status</entry></row></thead><tbody><row><entry>accessor-method-slot-definition</entry><entry>+</entry></row><row><entry>add-dependent</entry><entry>+</entry></row><row><entry>add-direct-method</entry><entry>+</entry></row><row><entry>add-direct-subclass</entry><entry>+</entry></row><row><entry>add-method</entry><entry>+</entry></row><row><entry>class-default-initargs</entry><entry>+</entry></row><row><entry>class-direct-default-initargs</entry><entry>+</entry></row><row><entry>class-direct-slots</entry><entry>+</entry></row><row><entry>class-direct-subclasses</entry><entry>+</entry></row><row><entry>class-direct-superclasses</entry><entry>+</entry></row><row><entry>class-finalized-p</entry><entry>+</entry></row><row><entry>class-prototype</entry><entry>+</entry></row><row><entry>class-slots</entry><entry>+</entry></row><row><entry>compute-applicable-methods</entry><entry>-</entry></row><row><entry>compute-applicable-methods-using-classes</entry><entry>-</entry></row><row><entry>compute-class-precedence-list</entry><entry>+</entry></row><row><entry>compute-direct-initargs</entry><entry>+</entry></row><row><entry>compute-discriminating-function</entry><entry>-</entry></row><row><entry>compute-effective-method</entry><entry>+</entry></row><row><entry>compute-effective-slot-definition</entry><entry>+</entry></row><row><entry>compute-slots</entry><entry>+</entry></row><row><entry>direct-slot-definition-class</entry><entry>+</entry></row><row><entry>effective-slot-definition-class</entry><entry>+</entry></row><row><entry>ensure-class</entry><entry>+</entry></row><row><entry>ensure-class-using-class</entry><entry>+</entry></row><row><entry>ensure-generic-function-using-class</entry><entry>+</entry></row><row><entry>eql-specializer-object</entry><entry>+</entry></row><row><entry>extract-lambda-list</entry><entry>+</entry></row><row><entry>extract-specializer-names</entry><entry>+</entry></row><row><entry>finalize-inheritance</entry><entry>+</entry></row><row><entry>find-method-combination</entry><entry>+</entry></row><row><entry>funcallable-standard-instance-access</entry><entry>+</entry></row><row><entry>generic-function-argument-precedence-order</entry><entry>+</entry></row><row><entry>generic-function-declarations</entry><entry>+</entry></row><row><entry>generic-function-lambda-list</entry><entry>+</entry></row><row><entry>generic-function-method-class</entry><entry>+</entry></row><row><entry>generic-function-method-combination</entry><entry>+</entry></row><row><entry>generic-function-methods</entry><entry>+</entry></row><row><entry>generic-function-name</entry><entry>+</entry></row><row><entry>intern-eql-specializer</entry><entry>+</entry></row><row><entry>make-method-lambda</entry><entry>-</entry></row><row><entry>map-dependents</entry><entry>+</entry></row><row><entry>method-function</entry><entry>+</entry></row><row><entry>method-generic-function</entry><entry>+</entry></row><row><entry>method-lambda-list</entry><entry>+</entry></row><row><entry>method-qualifiers</entry><entry>+</entry></row><row><entry>method-specializers</entry><entry>+</entry></row><row><entry>reader-method-class</entry><entry>+</entry></row><row><entry>remove-dependent</entry><entry>+</entry></row><row><entry>remove-direct-method</entry><entry>+</entry></row><row><entry>remove-direct-subclass</entry><entry>+</entry></row><row><entry>remove-method</entry><entry>+</entry></row><row><entry>set-funcallable-instance-function</entry><entry>-</entry></row><row><entry>slot-boundp-using-class</entry><entry>+</entry></row><row><entry>slot-definition-allocation</entry><entry>+</entry></row><row><entry>slot-definition-initargs</entry><entry>+</entry></row><row><entry>slot-definition-initform</entry><entry>+</entry></row><row><entry>slot-definition-initfunction</entry><entry>+</entry></row><row><entry>slot-definition-location</entry><entry>+</entry></row><row><entry>slot-definition-name</entry><entry>+</entry></row><row><entry>slot-definition-readers</entry><entry>+</entry></row><row><entry>slot-definition-type</entry><entry>+</entry></row><row><entry>slot-definition-writers</entry><entry>+</entry></row><row><entry>slot-makunbound-using-class</entry><entry>+</entry></row><row><entry>slot-value-using-class</entry><entry>+</entry></row><row><entry>specializer-direct-generic-functions</entry><entry>+</entry></row><row><entry>specializer-direct-methods</entry><entry>+</entry></row><row><entry>standard-instance-access</entry><entry>+</entry></row><row><entry>update-dependent</entry><entry>+</entry></row><row><entry>validate-superclass</entry><entry>+</entry></row><row><entry>writer-method-class</entry><entry>+</entry></row></tbody></tgroup></table></para>
      <para>Note that those generic functions whose status is &quot;-&quot; in
      the table above deal with the internals of generic function
      dispatch and method invocation (the &quot;Generic Function Invocation
      Protocol&quot;.) Method functions are implemented a bit differently
      in Clozure CL from what the MOP expects, and it's not yet clear if
      or how this subprotocol can be well-supported.</para>
      <para>      Those constructs that are marked as &quot;+&quot; in the table above
      are nominally implemented as the MOP document specifies
      (deviations from the specification should be considered bugs;
      please report them as such.) Note that some CLOS implementations
      in widespread use (e.g., PCL) implement some things
      (ENSURE-CLASS-USING-CLASS comes to mind) a bit differently from
      what the MOP specifies.</para>
    </section>
    <section id="concurrency-issues">
      <title>Concurrency issues</title>
      <para>The entire CLOS class and generic function hierarchy is
      effectively a (large, complicated) shared data structure; it's
      not generally practical for a thread to request exclusive access
      to all of CLOS, and the effects of volitional modification of
      the CLOS hierarchy (via class redefinition, CHANGE-CLASS, etc) in
      a multithreaded environment aren't always tractable.</para>
      <para>      Native threads exacerbate this problem (in that they
      increase the opportunities for concurrent modification and
      access.) The implementation should try to ensure that a thread's
      view of any subset of the CLOS hierarchy is consistent (to the
      extent that that's possible) and should try to ensure that
      incidental modifications of the hierarchy (cache updates, etc.)
      happen atomically; it's not generally possible for the
      implementation to guarantee that a thread's view of things is
      correct and current.</para>
      <para>      If you are loading code and defining classes in the most
      usual way, which is to say, via the compiler, using only a
      single thread, these issues are probably not going to affect you
      much.</para>
      <para>      If, however, you are making finicky changes to the class
      hierarchy while you're running multiple threads which manipulate
      objects related to each other, more care is required.  Before
      doing such a thing, you should know what you're doing and
      already be aware of what precautions to take, without being
      told.  That said, if you do it, you should seriously consider
      what your application's critical data is, and use locks for
      critical code sections.</para>
    </section>
  </chapter>
  <chapter id="profiling">
    <title>Profiling</title>
    <section id="using-the-linux-oprofile-system-level-profiler">
      <title>Using the Linux oprofile system-level profiler</title>
      <para><ulink url="http://oprofile.sourceforge.net"><literal>oprofile</literal></ulink> is a
    system-level profiler that's available for most modern Linux
    distributions.</para>
      <para>    Use of oprofile and its companion programs isn't really documented
    here; what is described is a way of generating symbolic information that
    enables profiling summaries generated by the <literal>opreport</literal> program
    to identify lisp functions meaningfully.</para>
      <section id="generating-a-lisp-image-for-use-with-oprofile">
        <title>Generating a lisp image for use with oprofile</title>
        <para>Modern Linux uses the 'ELF&quot; (Executable and Linking Format) object
      file format; the oprofile tools can associate symbolic names with
      addresses in a memory-mapped file if that file appears to be an ELF
      object file and if it contains ELF symbol information that describes
      those memory regions. So, the general idea is to make a lisp heap image
      that looks enough like an ELF shared library to fool the
      <literal>oprofile</literal> tools (we don't actually load heap images via ELF
      dynamic linking technology, but we can make it look like we did.)</para>
      </section>
      <section id="prerequisites_in_using-the-linux-oprofile-system-level-profiler">
        <title>Prerequisites</title>
        <blockquote>
          <itemizedlist>
            <listitem><para><literal>oprofile</literal> itself, which is almost certainly
          available via your distribution's package management system if not
          already preinstalled.</para></listitem>
            <listitem><para><literal>libelf</literal>, which provides utilities for reading and
          writing ELF files (and is likewise likely preinstalled or readily
          installable.) Somewhat confusingly, there are two libelf
          implementations in widespread use on Linux, and different
          distributions refer to them by different names (they may be
          available as part of an 'elfutils' package.) The oprofile insterface
          was designed to work with a libelf implementation whose version
          number is currently around 147; the other (incompatible) libelf
          implementation has a version number around 0.8. It may be necessary
          to install the corresponding development package (-dev or -devel,
          usuallly) in order to actually be able to use the libelf shared
          library.</para></listitem>
          </itemizedlist>
        </blockquote>
      </section>
      <section id="generating-elf-symbols-for-lisp-functions">
        <title>Generating ELF symbols for Lisp functions</title>
        <para>In order to create a lisp heap image which can be used for
      <literal>oprofile</literal>- based profiling, we need to:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>load any code that we want to profile</para></listitem>
            <listitem><para>generate a file that contains ELF symbol information
          describing the names and addresses of all lisp functions.</para><para>This step involves doing (from within Clozure CL)</para><programlisting><para>
? (require &quot;ELF&quot;)
&quot;ELF&quot;
(&quot;ELF&quot;)</para><para>? (ccl::write-elf-symbols-to-file &quot;home:elf-symbols&quot;)
	    </para></programlisting><para>The argument to CCL::WRITE-ELF-SYMBOLS-TO-FILE can be any
          writable pathname. The function will do whatever's necessary to nail
          lisp functions down in memory (so that they aren't moved by GC),
          then write an ELF object file to the indicated pathname. This
          typically takes a few seconds.</para></listitem>
            <listitem><para>Generate a lisp heap image in which the ELF symbols generated
          in the previous step are prepended.</para><para>          The function CCL:SAVE-APPLICATION provides a :PREPEND-KERNEL
          argument, which is ordinarily used to save a standalone application
          in which the kernel and heap image occupy a single file.
          :PREPEND-KERNEL doesn't really care what it's prepending to the
          image, and we can just as easily ask it to prepend the ELF symbol
          file generated in the previous step.</para><programlisting>
? (save-application &quot;somewhere/image-for-profiling&quot;
    :prepend-kernel &quot;home:elf-symbols&quot;)
	    </programlisting><para>If you then run</para><programlisting>
shell&gt; ccl64 somewhare/image-for-profiling
	    </programlisting><para>any lisp code sampled by oprofile in that image will be
          identified &quot;symbolically&quot; by <literal>opreport</literal>.</para></listitem>
          </orderedlist>
        </blockquote>
      </section>
      <section id="example_in_using-the-linux-oprofile-system-level-profiler">
        <title>Example</title>
        <programlisting><para>
;;; Define some lisp functions that we want to profile and save
;;; a profiling-enabled image.  In this case, we just want to 
;;; define the FACTORIAL funcion, to keep things simple.
? (defun fact (n) (if (zerop n) 1 (* n (fact (1- n)))))
FACT
? (require &quot;ELF&quot;)
&quot;ELF&quot;
(&quot;ELF&quot;)
? (ccl::write-elf-symbols-to-file &quot;home:elf-symbols&quot;)
&quot;home:elf-symbols&quot;
? (save-application &quot;home:profiled-ccl&quot; :prepend-kernel &quot;home:elf-symbols&quot;)</para><para>;;; Setup oprofile with (mostly) default arguments.  This example was
;;; run on a Fedora 8 system where an uncompressed 'vmlinux' kernel
;;; image isn't readily available.</para><para>;;; Note that use of 'opcontrol' generally requires root access, e.g.,
;;; 'sudo' or equivalent:</para><para>[~] gb@rinpoche&gt; sudo opcontrol --no-vmlinux --setup</para><para>;;; Start the profiler</para><para>[~] gb@rinpoche&gt; sudo opcontrol --start
Using 2.6+ OProfile kernel interface.
Using log file /var/lib/oprofile/samples/oprofiled.log
Daemon started.
Profiler running.</para><para>;;; Start CCL with the &quot;profiled-ccl&quot; image created above.
;;; Invoke &quot;(FACT 10000)&quot;</para><para>[~] gb@rinpoche&gt; ccl64 profiled-ccl 
Welcome to Clozure Common Lisp Version 1.2-r9198M-trunk  (LinuxX8664)!
? (null (fact 10000))
NIL
? (quit)</para><para>;;; We could stop the profiler (opcontrol --stop) here; instead,
;;; we simply flush profiling data to disk, where 'opreport' can
;;; find it.
</para><para>
[~] gb@rinpoche&gt; sudo opcontrol --dump</para><para>;;; Ask opreport to show us where we were spending time in the
;;; 'profiled-ccl' image.</para><para>[~] gb@rinpoche&gt; opreport -l profiled-ccl | head
CPU: Core 2, speed 1596 MHz (estimated)
Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (Unhalted core cycles) count 100000
samples  %        symbol name
6417     65.2466  &lt;Compiled-function.(:INTERNAL.MULTIPLY-UNSIGNED-BIGNUM-AND-1-DIGIT-FIXNUM.MULTIPLY-BIGNUM-AND-FIXNUM).(Non-Global)..0x30004002453F&gt;
3211     32.6487  &lt;Compiled-function.%MULTIPLY-AND-ADD4.0x300040000AAF&gt;
17        0.1729  &lt;Compiled-function.%%ONE-ARG-DCODE.0x3000401740AF&gt;
11        0.1118  &lt;Compiled-function.%UNLOCK-RECURSIVE-LOCK-OBJECT.0x30004007F7DF&gt;
10        0.1017  &lt;Compiled-function.AUTO-FLUSH-INTERACTIVE-STREAMS.0x3000404ED6AF&gt;
7         0.0712  &lt;Compiled-function.%NANOSLEEP.0x30004040385F&gt;
7         0.0712  &lt;Compiled-function.%ZERO-TRAILING-SIGN-DIGITS.0x300040030F3F&gt;
	</para></programlisting>
      </section>
      <section id="issues">
        <title>Issues</title>
        <para>CCL::WRITE-ELF-SYMBOLS-TO-FILE currently only works on x86-64; it
      certainly -could- be made to work on ppc32/ppc64 as well.</para>
        <para>      So far, no one has been able to make oprofile/opreport options
      that're supposed to generate call-stack info generate meaningful
      call-stack info.</para>
        <para>      As of a few months ago, there was an attempt to provide symbol
      info for oprofile/opreport &quot;on the fly&quot;, e.g., for use in JIT
      compilation or other incremental compilation scenarios. That's obviously
      more nearly The Right Thing, but it might be awhile before that
      experimental code makes it into widespread use.</para>
      </section>
    </section>
    <section id="using-apple-s-chud-metering-tools">
      <title>Using Apple's CHUD metering tools</title>
      <para>Apple's CHUD package provides libraries, kernel extensions, and a
    set of graphical and command-line programs that can be used to measure
    many aspects of application and system performance.</para>
      <para>    One of these programs is the Shark application (often installed in
    &quot;/Developer/Applications/Performance Tools/Shark.app&quot;), which provides a
    graphical user interface for exploring and analyzing profiling results and
    provides tools for creating &quot;sampling configurations&quot; (see below), among
    other things. Use of Shark isn't really documented here (a Shark manual is
    available at &quot;Developer/Documentation/CHUD/Shark/ SharkUserGuide.pdf&quot;);
    what is described is a way of providing information about Lisp function
    names and addresses so that Shark can meaningly identify those functions
    in its output.</para>
      <section id="prerequisites_in_using-apple-s-chud-metering-tools">
        <title>Prerequisites</title>
        <para>Apple's CHUD tools have been distributed with the last several
      XCode releases. One way to determine whether or not the tools are
      installed is to run:</para>
        <programlisting>$ /usr/bin/shark -v</programlisting>
        <para>in a terminal or Emacs shell buffer. If that returns output
      like</para>
        <programlisting>shark 4.7.3 (365)</programlisting>
        <para>then the CHUD package is installed. Output like</para>
        <programlisting>shark: Command not found.</programlisting>
        <para>strongly suggests that it isn't ...</para>
      </section>
      <section id="generating-a-lisp-image-for-use-with-shark">
        <title>Generating a lisp image for use with Shark</title>
        <para>Shark can only properly identify functions that're defined in a
      shared library that's loaded by the target application. (Any other
      functions will be identified by a hex address described as being in an
      &quot;Unknown Library&quot;; the hex address is generally somewhat near the actual
      function, but it's determined heuristically and isn't always
      accurate.)</para>
        <para>      For those reasons, it's desirable to load the code that you wish
      to profile in one lisp session, save a native (Mach-O library) image,
      and invoke Shark in a new session which uses that native image. (It may
      also be useful to load the CHUD-METERING module, which defines
      CHUD:METER and friends.</para>
        <para/>
      </section>
      <section id="usage-synopsis">
        <title>Usage synopsis</title>
        <programlisting>[src/ccl-dev] gb@antinomial&gt; ccl64
Welcome to Clozure Common Lisp Version 1.7-dev-r14624M-trunk  (DarwinX8664)!
? (defun fact(n) (if (zerop n) 1 (* n (fact (1- n)))))
FACT
? (require &quot;CHUD-METERING&quot;)
&quot;CHUD-METERING&quot;
(&quot;CHUD-METERING&quot;)
? (save-application &quot;ccl:dx86cl64.dylib&quot; :native t)
[src/ccl-dev] gb@antinomial&gt; ccl64 -I dx86cl64.dylib
Welcome to Clozure Common Lisp Version 1.7-dev-r14624M-trunk  (DarwinX8664)!
? (chud:meter (dotimes (i 1000) (fact 1000)))
;;; Waiting for shark to process samples ...done.
NIL</programlisting>
        <para>and, a few seconds after the result is returned, a file whose name
      is of the form &quot;session_nnn.mshark&quot; will open in Shark.app.</para>
        <para/>
        <para>The fist time that CHUD:METER is used in a lisp session, it'll do
      a few things to prepare subsequent profiling sessions. Those things
      include:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>creating a directory to store files that are related to using
          the CHUD tools in this lisp session. This directory is created in
          the user's home directory and has a name of the form:</para><programlisting>
profiling-session-&lt;lisp-kernel&gt;-&lt;pid&gt;_&lt;mm&gt;-&lt;dd&gt;-&lt;yyyy&gt;_&lt;h&gt;.&lt;m&gt;.&lt;s&gt;
	      </programlisting></listitem>
            <listitem><para>run the shark program (&quot;/usr/bin/shark&quot;) and wait until it's
          ready to receive signals that control its operation.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>This startup activity typically takes a few seconds; after it's
      been completed, subsequent use of CHUD:METER doesn't involve that
      overhead. (See the discussion of :RESET below.)</para>
        <para>      After any startup activity is complete, CHUD:METER arranges to
      send a &quot;start profiling&quot; signal to the running shark program, executes
      the form, sends a &quot;stop profiling&quot; signal to the shark program, and
      reads its diagnostic output, looking for the name of the &quot;.mshark&quot; file
      it produces. If it's able to find this filename, it arranges for
      &quot;Shark.app&quot; to open it.</para>
      </section>
      <section id="profiling-configurations">
        <title>Profiling &quot;configurations&quot;</title>
        <para>By default, a shark profiling session will:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>use &quot;time based&quot; sampling, to periodically interrupt the lisp
          process and note the value of the program counter and at least a few
          levels of call history.</para></listitem>
            <listitem><para>do this sampling once every millisecond</para></listitem>
            <listitem><para>run for up to 30 seconds, unless told to stop earlier.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>This is known as &quot;the default configuration&quot;; it's possible to use
      items on the &quot;Config&quot; menu in the Shark application to create alternate
      configurations which provide different kinds of profiling parameters and
      to save these configurations in files for subsequent reuse. (The set of
      things that CHUD knows how to monitor is large and interesting.)</para>
        <para>      You use alternate profiling configurations (created and &quot;exported&quot;
      via Shark.app) with CHUD:METER, but the interface is a little
      awkward.</para>
      </section>
      <section id="reference">
        <title>Reference</title>
        <refentry id="v_shark-config-file">
          <indexterm zone="v_shark-config-file"><primary><literal>CHUD:*SHARK-CONFIG-FILE*</literal></primary></indexterm>
          <refnamediv>
            <refname>CHUD:*SHARK-CONFIG-FILE*</refname>
            <refpurpose/>
            <refclass>Variable</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>CHUD:*SHARK-CONFIG-FILE*</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_v_shark-config-file">
            <title>Description</title>
            <para>When non-null, this should be the pathname of an alternate
      profiling configuration file created by the &quot;Config Editor&quot; in
      Shark.app.</para>
          </refsect1>
        </refentry>
        <refentry id="m_meter">
          <indexterm zone="m_meter"><primary><literal>CHUD:METER</literal></primary></indexterm>
          <refnamediv>
            <refname>CHUD:METER</refname>
            <refpurpose/>
            <refclass>Macro</refclass>
          </refnamediv>
          <refsynopsisdiv><synopsis>CHUD:METER form <literal>&amp;key</literal> (reset nil) (debug-output nil)</synopsis></refsynopsisdiv>
          <refsect1 id="description_in_m_meter">
            <title>Description</title>
            <para>Executes FORM (an arbitrary lisp form) and returns whatever
      result(s) it returns, with CHUD profiling enabled during the form's
      execution. Tries to determine the name of the session file (*.mshark) to
      which the shark program wrote profiling data and opens this file in the
      Shark application.</para>
            <para>Arguments:</para>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term><parameter>debug-output</parameter></term>
                  <listitem><para>when non-nil, causes output generated by the shark program
            to be echoed to *TERMINAL-IO*. For debugging.</para></listitem>
                </varlistentry>
                <varlistentry>
                  <term><parameter>reset</parameter></term>
                  <listitem><para>when non-nil, terminates any running instance of the shark
            program created by previous invocations of CHUD:METER in this lisp
            session, generates a new .spatch file (describing the names and
            addresses of lisp functions), and starts a new instance of the
            shark program; if CHUD:*SHARK-CONFIG-FILE* is non-NIL when this
            new instance is started, that instance is told to use the
            specified config file for profiling (in lieu of the default
            profiling configuration.)</para></listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
          </refsect1>
        </refentry>
      </section>
      <section id="acknowledgement_in_using-apple-s-chud-metering-tools">
        <title>Acknowledgement</title>
        <para>Both Dan Knapp and Hamilton Link have posted similar CHUD
      interfaces to openmcl-devel in the past; Hamilton's also reported bugs
      in the spatch mechanism to CHUD developers (and gotten those bugs
      fixed.)</para>
      </section>
    </section>
  </chapter>
  <chapter id="the-foreign-function-interface">
    <title>The Foreign-Function Interface</title>
    <section id="specifying-and-using-foreign-types">
      <title>Specifying And Using Foreign Types</title>
      <section id="overview_in_specifying-and-using-foreign-types">
        <title>Overview</title>
        <para>Clozure CL provides a fairly rich language for defining and
        specifying foreign data types (this language is derived from
        CMUCL's &quot;alien type&quot; system.)</para>
        <para>        In practice, most foreign type definitions are
        introduced into Clozure CL via its interface database (see ),
        though it's also possible to define foreign types
        interactively and/or programmatically.</para>
        <para>        Clozure CL's foreign type system is &quot;evolving&quot; (a polite word
        for not-quite-complete): there are some inconsistencies
        involving package usage, for instance. Symbols used in foreign
        type specifiers <emphasis>should</emphasis> be keywords, but
        this convention isn't always enforced.</para>
        <para>        Foreign
        type, record, and field names are case-sensitive; Clozure CL uses
        some escaping conventions (see ) to allow keywords to be used to
        denote these names.</para>
        <section id="type-annotations">
          <title>Type Annotations</title>
          <para>As of version 1.2, Clozure CL supports annotating the types of
          foreign pointers on Mac OS X. Forms that create pointers to
          foreign memory-that is, <literal>MACPTR</literal>s-store
          with the <literal>MACPTR</literal> object a type annotation that
          identifies the foreign type of the object pointed
          to. Calling <literal>PRINT-OBJECT</literal> on a <literal>MACPTR</literal>
          attempts to print information about the identified foreign
          type, including whether it was allocated on the heap or the
          stack, and whether it's scheduled for automatic reclamation by
          the garbage collector.</para>
          <para>          Support for type annotation is not yet complete. In
          particular, some uses of <literal>PREF</literal>
          and <literal>SLOT-VALUE</literal> do ot yet take type annotations into
          account, and neither do <literal>DESCRIBE</literal>
          and <literal>INSPECT</literal>.</para>
        </section>
        <section id="foreign-types-as-classes">
          <title>Foreign Types as Classes</title>
          <para>Some types of foreign pointers take advantage of the
          support for type annotations, and pointers of these types
          can be treated as instances of known classes. Specifically,
          a pointer to an <literal>:&lt;NSR&gt;ect</literal> is recognized
          as an instance of the built-in
          class <literal>NS:NS-RECT</literal>, a pointer to
          an <literal>&lt;NSS&gt;ize</literal> is treated as an instance
          of <literal>NS:NS-SIZE</literal>, a pointer to
          an <literal>&lt;NSP&gt;oint</literal> is recognized as an
          instance of <literal>NS:NS-POINT</literal>, and a pointer to
          an <literal>&lt;NSR&gt;ange</literal> is recognized as an
          instance of <literal>NS:NS-RANGE</literal>.</para>
          <para>        A few more obscure structure types also support this
        mechanism, and it's possible that a future version will
        support user definition of similar type mappings.</para>
          <para>        This support for foreign types as classes provides the
        following conveniences for each supported type:</para>
          <blockquote>
            <itemizedlist>
              <listitem><para>a <literal>PRINT-OBJECT</literal> method is defined</para></listitem>
              <listitem><para>a foreign type name is created and treated as an alias
          for the corresponding type. As an example, the
          name <literal>:NS-RECT</literal> is a name for the type that
          corresponds to <literal>NS:NS-RECT</literal>, and you can
          use <literal>:NS-RECT</literal> as a type designator
          in <indexterm><primary><literal>RLET</literal></primary></indexterm><link linkend="m_rlet"><literal>RLET</literal></link> forms to
          specify a structure of type <literal>NS-RECT</literal>.</para></listitem>
              <listitem><para>the class is integrated into the type system so that
            <literal>(TYPEP R 'NS:NS-RECT)</literal> is implemented with
            fair efficiency.</para></listitem>
              <listitem><para>inlined accessor and <literal>SETF</literal> inverses are
            defined for the structure type's fields.  In the case of
            an <literal>&lt;NSR*gt;ect</literal>, for example, the fields in
            question are the fields of the embedded point and size, so
            that <literal>NS:NS-RECT-X</literal>, <literal>NS:NS-RECT-Y</literal>, <literal>NS:NS-RECT-WIDTH</literal>,
            <literal>NS-RECT-HEIGHT</literal> and <literal>SETF</literal> inverses
            are defined.  The accessors and setter functions typecheck
            their arguments and the setters handle coercion to the
            appropriate type of <literal>CGFLOAT</literal> where
            applicable.</para></listitem>
              <listitem><para>an initialization function is defined; for
            example,</para><programlisting>
(NS:INIT-NS-SIZE s w h)
          </programlisting><para>is roughly equivalent to</para><programlisting>
(SETF (NS:NS-SIZE-WIDTH s) w
      (NS:NS-SIZE-HEIGHT s) h)
          </programlisting><para>but might be a little more efficient.</para></listitem>
              <listitem><para>a creation function is defined; for
            example</para><programlisting>
(NS:NS-MAKE-POINT x y)
          </programlisting><para>is functionally equivalent to</para><programlisting>
(LET ((P (MAKE-GCABLE-RECORD :NS-POINT)))
  (NS:INIT-NS-POINT P X Y)
  p)
          </programlisting></listitem>
              <listitem><para>a macro is defined which, like <literal>RLET</literal>,
            stack-allocates an instance of the foreign record type,
            optionally initializes that instance, and executes a body
            of code with a variable bound to that instance.</para><para>For example,</para><programlisting>
(ns:with-ns-range (r loc len)
  (format t &quot;~&amp; range has location ~s, length ~s&quot; 
     (ns:ns-range-location r) (ns:ns-range-length r)))
          </programlisting></listitem>
              <listitem/>
            </itemizedlist>
          </blockquote>
        </section>
      </section>
      <section id="syntax-of-foreign-type-specifiers">
        <title>Syntax of Foreign Type Specifiers</title>
        <blockquote>
          <itemizedlist>
            <listitem><para>Some foreign types are builtin: keywords denote
            primitive,builtin types such as the IEEE-double-float type
            (denoted:DOUBLE-FLOAT), in much the same way as certain
            symbols(CONS, FIXNUM,etc.) define primitive CL
            types.</para></listitem>
            <listitem><para>Constructors such as :SIGNED and :UNSIGNED can be
            used to denote signed and unsigned integer subtypes
            (analogous to the CL type specifiers SIGNED-BYTE and
            UNSIGNED-BYTE.) :SIGNED is shorthand for(:SIGNED 32) and
            :UNSIGNED is shorthand for (:UNSIGNED 32).</para></listitem>
            <listitem><para>Aliases for other (perhaps more complicated) types
            can be defined via CCL:DEF-FOREIGN-TYPE (sort of like
            CL:DEFTYPE or the C typedef facility). The type :CHAR is
            defined as an alias for (:SIGNED8) on some platforms, as
            (:UNSIGNED 8) on others.</para></listitem>
            <listitem><para>The construct (:STRUCT <emphasis>name</emphasis>)
	        can be used to refer to a named structure type; (:UNION
	        <emphasis>name</emphasis>)can be used to refer to a named
	        union type. It isn't necessary to enumerate a structure or
	        union type's fields in order to refer to the type.</para></listitem>
            <listitem><para>If <emphasis>X</emphasis> is a valid foreign type
	        reference,then (:* <emphasis>X</emphasis>) denotes the
	        foreign type &quot;pointer to<emphasis>X</emphasis>&quot;. By
	        convention, (:* T) denotes an anonymous pointer type,
	        vaguely equivalent to &quot;void*&quot; in C.</para></listitem>
            <listitem><para>If a fieldlist is a list of lists, each of whose CAR
	        is a foreign field name (keyword) and whose CADR is a
	        foreign type specifier, then (:STRUCT
	        <emphasis>name</emphasis> ,@fieldlist) is a definition of
	        the structure type <emphasis>name</emphasis>,
	        and (:UNION<emphasis>name</emphasis> ,@fieldlist) is a
	        definition of the union type
	        <emphasis>name</emphasis>. Note that it's necessary
	        to define a structure or union type in order to include
	        that type in a structure, union, or array, but only
	        necessary to &quot;refer to&quot; a structure or union type in order
	        to define a type alias or a pointer type.</para></listitem>
            <listitem><para>If <emphasis>X</emphasis> is a defined foreign type
	        , then (:array <emphasis>X</emphasis> &amp;rest dims)
	        denotes the foreign type &quot;array of
	        <emphasis>X</emphasis>&quot;. Although multiple array dimensions
	        are allowed by the :array constructor,
	        only single-dimensioned arrays are (at all) well-supported
	        in Clozure CL.</para></listitem>
          </itemizedlist>
        </blockquote>
      </section>
    </section>
    <section id="foreign-function-calls">
      <title>Foreign Function Calls</title>
      <section id="overview_in_foreign-function-calls">
        <title>Overview</title>
        <para>Clozure CL provides a number of constructs for calling
        foreign functions from Lisp code (all of them based on the
        function CCL:%FF-CALL).  In many cases, Clozure CL's interface
        translator (see ) provides information about the foreign
        function's entrypoint name and argument and return types; this
        enables the use of the #_ reader macro (described below),
        which may be more concise and/or more readable than other
        constructs.</para>
        <para>        Clozure CL also provides a mechanism for defining
        <emphasis>callbacks</emphasis>: lisp functions which can be
        called from foreign code.</para>
        <para>        There's no supported way to directly pass lisp data to
        foreign functions: scalar lisp data must be coerced to an
        equivalent foreign representation, and lisp arrays (notably
        strings) must be copied to non-GCed memory.</para>
        <section id="type-designators-for-arguments-and-return-values">
          <title>Type Designators for Arguments and Return Values</title>
          <para>The types of foreign argument and return values in foreign
	      function calls and callbacks can be specified by any of the following
          keywords:</para>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><literal>:UNSIGNED-BYTE</literal></term>
                <listitem><para>The argument/return value is of type (UNSIGNED-BYTE 8)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:SIGNED-BYTE</literal></term>
                <listitem><para>The argument/return value is of type (SIGNED-BYTE 8)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UNSIGNED-HALFWORD</literal></term>
                <listitem><para>The argument/return value is of type (UNSIGNED-BYTE 16)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:SIGNED-HALFWORD</literal></term>
                <listitem><para>The argument/return value is of type (SIGNED-BYTE 16)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UNSIGNED-FULLWORD</literal></term>
                <listitem><para>The argument/return value is of type (UNSIGNED-BYTE 32)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:SIGNED-FULLWORD</literal></term>
                <listitem><para>The argument/return value is of type (SIGNED-BYTE 32)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:UNSIGNED-DOUBLEWORD</literal></term>
                <listitem><para>The argument/return value is of type (UNSIGNED-BYTE 64)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:SIGNED-DOUBLEWORD</literal></term>
                <listitem><para>The argument/return value is of type (SIGNED-BYTE 64)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:SINGLE-FLOAT</literal></term>
                <listitem><para>The argument/return value is of type SINGLE-FLOAT</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:DOUBLE-FLOAT</literal></term>
                <listitem><para>The argument/return value is of type DOUBLE-FLOAT</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:ADDRESS</literal></term>
                <listitem><para>The argument/return values
		        is <link linkend="referencing-and-using-foreign-memory-addresses">a MACPTR</link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><literal>:VOID</literal></term>
                <listitem><para>or NIL Not valid as an argument type specifier; specifies
		        that there is no meaningful return value</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <para>On some platforms, a small positive integer
          <emphasis>N</emphasis> can also be used as an argument
          specifier; it indicates that the corresponding argument is a
          pointer to an <emphasis>N</emphasis>-word structure or union
          which should be passed by value to the foreign
          function.  Exactly which foreign structures are passed
	      by value and how is very dependent on the Application
	      Binary Interface (ABI) of the platform; unless you're
	      very familiar with ABI details (some of which are quite
	      baroque), it's often easier to let higher-level constructs
	      deal with these details.</para>
        </section>
        <section id="external-entrypoints-and-named-external-entrypoints">
          <title>External Entrypoints and Named External Entrypoints</title>
          <para>PowerPC machine instructions are always aligned on
          32-bit boundaries, so the two least significant bits of the
          first instruction (&quot;entrypoint&quot;) of a foreign function are
          always 0. Clozure CL often represents an entrypoint address as
          a fixnum that's binary-equivalent to the entrypoint address:
          if<emphasis>E</emphasis> is an entrypoint address expressed
          as a signed 32-bit integer, then (ash <emphasis>E</emphasis>
          -2) is an equivalent fixnum representation of that
          address. An entrypoint address can also be encapsulated in a
          MACPTR (see FIXTHIS), but that's somewhat less efficient.</para>
          <para>          Although it's possible to use fixnums or macptrs to
          represent entrypoint addresses, it's somewhat cumbersome to
          do so. Clozure CL can cache the addresses of named external
          functions in structure-like objects of type
          CCL:EXTERNAL-ENTRY-POINT (sometimes abbreviated as EEP).
          Through the use of LOAD-TIME-VALUE, compiled lisp functions
          are able to reference EEPs as constants; the use of an
          indirection allows Clozure CL runtime system to ensure that the
          EEP's address is current and correct.</para>
        </section>
      </section>
      <section id="return-conventions-for-c-structures">
        <title>Return Conventions for C Structures</title>
        <para> On some platforms, C functions that are defined to
        return structures do so by reference: they actually
        accept a first parameter of type &quot;pointer to returned
        struct/union&quot; - which must be allocated by the caller - and
        don't return a meaningful value.</para>
        <para>	    <emphasis>Exactly</emphasis> how a C function that's
	    defined to return a foreign structure does so is dependent on
	    the ABI (and on the size and composition of the structure/union
	    in many cases.)</para>
      </section>
    </section>
    <section id="referencing-and-using-foreign-memory-addresses">
      <title>Referencing and Using Foreign Memory Addresses</title>
      <section id="overview_in_referencing-and-using-foreign-memory-addresses">
        <title>Overview</title>
        <section id="basics">
          <title>Basics</title>
          <para>For a variety of technical reasons, it isn't generally
          possible to directly reference arbitrary absolute addresses
          (such as those returned by the C library function malloc(),
          for instance) in Clozure CL. In Clozure CL (and in MCL), such
          addresses need to be <emphasis>encapsulated</emphasis> in
          objects of type CCL:MACPTR; one can think of a MACPTR as
          being a specialized type of structure whose sole purpose is
          to provide a way of referring to an underlying &quot;raw&quot;
          address.</para>
          <para>          It's sometimes convenient to blur the distinction
          between a MACPTR and the address it represents; it's
          sometimes necessary to maintain that distinction. It's
          important to remember that a MACPTR is (generally) a
          first-class Lisp object in the same sense that a CONS cell
          is: it'll get GCed when it's no longer possible to reference
          it. The &quot;lifetime&quot; of a MACPTR doesn't generally have
          anything to do with the lifetime of the block of memory its
          address points to.</para>
          <para>          It might be tempting to ask &quot;How does one obtain the
          address encapsulated by a MACPTR ?&quot;. The answer to that
          question is that one doesn't do that (and there's no way to
          do that): addresses aren't first-class objects, and there's
          no way to refer to one.</para>
          <para>          Two MACPTRs that encapsulate the same address are EQL
          to each other.</para>
          <para>          There are a small number of ways to directly create a
          MACPTR (and there's a fair amount of syntactic sugar built
          on top of of those primitives.) These primitives will be
          discussed in greater detail below, but they include:</para>
          <blockquote>
            <itemizedlist>
              <listitem><para>Creating a MACPTR with a specified address, usually
	          via the function CCL:%INT-TO-PTR.</para></listitem>
              <listitem><para>Referencing the return value of a foreign function
	          call (see )that's specified to return an address.</para></listitem>
              <listitem><para>Referencing a memory location that's specified to
	          contain an address.</para></listitem>
            </itemizedlist>
          </blockquote>
          <para>All of these primitive MACPTR-creating operations are
          usually open-coded by the compiler; it has a fairly good
          notion of what low-level operations &quot;produce&quot; MACPTRs and
          which operations &quot;consume&quot; the addresses that the
          encapsulate, and will usually optimize out the introduction
          of intermediate MACPTRs in a simple expression.</para>
          <para>          One consequence of the use of MACPTR objects to
          encapsulate foreign addresses is that (naively)
          <emphasis>every reference to a foreign address causes a
            MACPTR to be allocated.</emphasis></para>
          <para>Consider a code fragment like the following:</para>
          <programlisting>
(defun get-next-event ()
  &quot;get the next event from a hypothetical window system&quot;
  (loop
     (let* ((event (#_get_next_window_system_event))) ; via an FF-CALL
       (unless (null-event-p event)
         (handle-event event)))))
        </programlisting>
          <para>As this is written, each call to the (hypothetical)
          foreign function #_get_next_window_system_event will return
          a new MACPTR object.  Ignoring for the sake of argument the
          question of whether this code fragment exhibits a good way
          to poll for external events (it doesn't), it's not hard to
          imagine that this loop could execute several million times
          per second (producing several million MACPTRs per second.)
          Clearly, the &quot;naive&quot; approach is impractical in many
          cases.</para>
        </section>
        <section id="stack-allocation-of-and-destructive-operations-on-macptrs.">
          <title>Stack allocation of-and destructive operations on-MACPTRs.</title>
          <para>If certain conditions held in the environment in which
	      GET-NEXT-EVENT ran-namely, if it was guaranteed that
	      neither NULL-EVENT-P nor HANDLE-EVENT cached or otherwise
	      retained their arguments (the &quot;event&quot; pointer)-there'd be
	      a few alternatives to the naive approach. One of those
	      approaches would be to use the primitive function
	      %SETF-MACPTR (described in greater detail below) to
	      destructively modify a MACPTR (to change the value of the
	      address it encapsulates.) The GET-NEXT-EVENT example could
	      be re-written as:</para>
          <programlisting>
(defun get-next-event ()
  (let* ((event (%int-to-ptr 0)))     ; create a MACPTR with address 0
    (loop
       (%setf-macptr event (#_get_next_window_system_event)) ; re-use it
       (unless (null-event-p event)
         (handle-event event)))))
        </programlisting>
          <para>That version's a bit more realistic: it allocates a
          single MACPTR outside if the loop, then changes its address
          to point to the current address of the hypothetical event
          structure on each loop iteration. If there are a million
          loop iterations per call to GET-NEXT-EVENT, we're allocating
          a million times fewer MACPTRs per call; that sounds like a
          Good Thing.</para>
          <para>          An Even Better Thing would be to advise the compiler
          that the initial value (the null MACPTR) bound to the
          variable event has dynamic extent (that value won't be
          referenced once control leaves the extent of the binding of
          that variable.) Common Lisp allows us to make such an
          assertion via a DYNAMIC-EXTENT declaration; Clozure CL's
          compiler can recognize the &quot;primitive MACPTR-creating
          operation&quot; involved and can replace it with an equivalent
          operation that stack-allocates the MACPTR object. If we're
          not worried about the cost of allocating that MACPTR on
          every iteration (the cost is small and there's no hidden GC
          cost), we could move the binding back inside the
          loop:</para>
          <programlisting>
(defun get-next-event ()
  (loop
     (let* ((event (%null-ptr))) ; (%NULL-PTR) is shorthand for (%INT-TO-PTR 0)
       (declare (dynamic-extent event))
       (%setf-macptr event (#_get_next_window_system_event))
       (unless (null-event-p event)
         (handle-event event)))))
        </programlisting>
          <para>The idiom of binding one or more variables to
          stack-allocated MACPTRs, then destructively modifying those
          MACPTRs before executing a body of code is common enough
          that Clozure CL provides a macro (WITH-MACPTRS) that handles
          all of the gory details. The following version of
          GET-NEXT-EVENT is semantically equivalent to the previous
          version, but hopefully a bit more concise:</para>
          <programlisting>
(defun get-next-event ()
  (loop
     (with-macptrs ((event (#_get_next_window_system_event)))
       (unless (null-event-p event)
         (handle-event event)))))
        </programlisting>
        </section>
        <section id="stack-allocated-memory-and-stack-allocated-pointers-to-it.">
          <title>Stack-allocated memory (and stack-allocated pointers to it.)</title>
          <para>Fairly often, the blocks of foreign memory (obtained
	      by malloc or something similar) have well-defined lifetimes
	      (they can safely be freed at some point when it's known that
	      they're no longer needed and it's known that they're no
	      longer referenced.) A common idiom might be:</para>
          <programlisting>
(with-macptrs (p (#_allocate_foreign_memory size))
  (unwind-protect
       (use-foreign-memory p)
    (#_deallocate_foreign_memory p)))
        </programlisting>
          <para>That's not unreasonable code, but it's fairly
          expensive for a number of reasons: foreign functions calls
          are themselves fairly expensive (as is UNWIND-PROTECT), and
          most library routines for allocating and deallocating
          foreign memory (things like malloc and free) can be fairly
          expensive in their own right.</para>
          <para>          In the idiomatic code above, both the MACPTR P and the
          block of memory that's being allocated and freed have
          dynamic extent and are therefore good candidates for stack
          allocation. Clozure CL provides the %STACK-BLOCK macro, which
          executes a body of code with one or more variables bound to
          stack-allocated MACPTRs which encapsulate the addresses of
          stack-allocated blocks of foreign memory. Using
          %STACK-BLOCK, the idiomatic code is:</para>
          <programlisting>
(%stack-block ((p size))
              (use-foreign-memory p))
        </programlisting>
          <para>which is a bit more efficient and a bit more concise
          than the version presented earlier.</para>
          <para>          %STACK-BLOCK is used as the basis for slightly
          higher-level things like RLET. (See FIXTHIS for more information
          about RLET.)</para>
        </section>
        <section id="caveats">
          <title>Caveats</title>
          <para>Reading from, writing to, allocating, and freeing
          foreign memory are all potentially dangerous operations;
          this is no less true when these operations are performed in
          Clozure CL than when they're done in C or some other
          lower-level language. In addition, destructive operations on
          Lisp objects be dangerous, as can stack allocation if it's
          abused (if DYNAMIC-EXTENT declarations are violated.)
          Correct use of the constructs and primitives described here
          is reliable and safe; slightly incorrect use of these
          constructs and primitives can crash Clozure CL.</para>
        </section>
      </section>
      <section id="foreign-memory-addresses-dictionary">
        <title>Foreign-Memory-Addresses Dictionary</title>
        <para>Unless otherwise noted, all of the symbols mentioned
        below are exported from the CCL package.</para>
        <section id="scalar-memory-reference">
          <title>Scalar memory reference</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%get-signed-byte ptr &amp;optional (offset 0)</para><para>%get-unsigned-byte ptr &amp;optional (offset 0)</para><para>%get-signed-word ptr &amp;optional (offset 0)</para><para>%get-unsigned-word ptr &amp;optional (offset 0)</para><para>%get-signed-long ptr &amp;optional (offset 0)</para><para>%get-unsigned-long ptr &amp;optional (offset 0)</para><para>%%get-signed-longlong ptr &amp;optional (offset 0)</para><para>%%get-unsigned-longlong ptr &amp;optional (offset 0)</para><para>%get-ptr ptr &amp;optional (offset 0)</para><para>%get-single-float ptr &amp;optional (offset 0)</para><para>%get-double-float ptr &amp;optional (offset 0)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>References and returns the signed or unsigned 8-bit byte,
		        signed or unsigned 16-bit word, signed or unsigned 32-bit long
		        word, signed or unsigned 64-bit long long word, 32-bit address,
		        32-bit single-float, or 64-bit double-float at the effective byte
		        address formed by adding offset to the address encapsulated by
		        ptr.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry><varlistentry><term><parameter>offset</parameter></term><listitem><para>A fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <para>All of the memory reference primitives described above can be</para>
          <para>used with SETF.</para>
        </section>
        <section id="get-bit-function">
          <title>%get-bit [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%get-bit ptr bit-offset</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>References and returns the bit-offsetth bit at the address
		        encapsulated by ptr. (Bit 0 at a given address is the most
		        significant bit of the byte at that address.) Can be used with
		        SETF.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry><varlistentry><term><parameter>bit-offset</parameter></term><listitem><para>A fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="get-bitfield-function">
          <title>%get-bitfield [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%get-bitfield ptr bit-offset width</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>References and returns an unsigned integer composed from the
		        width bits found bit-offset bits from the address encapsulated by
		        ptr. (The least significant bit of the result is the value of
		        (%get-bit ptr (1- (+ bit-offset width))). Can be used with SETF.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>ptr</parameter></term>
                <listitem><para>A MACPTR</para><blockquote><variablelist><varlistentry><term><parameter>bit-offset</parameter></term><listitem><para>A fixnum</para></listitem></varlistentry><varlistentry><term><parameter>width</parameter></term><listitem><para>A positive fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="int-to-ptr-function">
          <title>%int-to-ptr [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%int-to-ptr int</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Creates and returns a MACPTR whose address matches int.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>int</parameter></term><listitem><para>An (unsigned-byte 32)</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="inc-ptr-function">
          <title>%inc-ptr [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%inc-ptr ptr &amp;optional (delta 1)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Creates and returns a MACPTR whose address is the address of
		        ptr plus delta. The idiom (%inc-ptr ptr 0) is sometimes used to
		        copy a MACPTR, e.g., to create a new MACPTR encapsulating the same
		        address as ptr.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry><varlistentry><term><parameter>delta</parameter></term><listitem><para>A fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="ptr-to-int-function">
          <title>%ptr-to-int [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%ptr-to-int ptr</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Returns the address encapsulated by ptr, as an
		        (unsigned-byte 32).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="null-ptr-macro">
          <title>%null-ptr [Macro]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%null-ptr</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Equivalent to (%int-to-ptr 0).</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="null-ptr-p-function">
          <title>%null-ptr-p [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%null-ptr-p ptr</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Returns T If ptr is a MACPTR encapsulating the address 0,
		        NIL if ptr encapsulates some other address.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="setf-macptr-function">
          <title>%setf-macptr [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%setf-macptr dest-ptr src-ptr</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Causes dest-ptr to encapsulate the same address that src-ptr
		        does, then returns dest-ptr.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>dest-ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry><varlistentry><term><parameter>src-ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="incf-ptr-macro">
          <title>%incf-ptr [Macro]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%incf-ptr ptr &amp;optional (delta 1)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Destructively modifies ptr, by adding delta to the address
		        it encapsulates. Returns ptr.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry><varlistentry><term><parameter>delta</parameter></term><listitem><para>A fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="with-macptrs-macro">
          <title>with-macptrs [Macro]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>with-macptrs (var expr)* &amp;body body</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Executes body in an environment in which each var is bound
		        to a stack-allocated macptr which encapsulates the foreign address
		        yielded by the corresponding expr. Returns whatever value(s) body
		        returns.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>var</parameter></term><listitem><para>A symbol (variable name)</para></listitem></varlistentry><varlistentry><term><parameter>expr</parameter></term><listitem><para>A MACPTR-valued expression</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="stack-block-macro">
          <title>%stack-block [Macro]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%stack-block (var expr)* &amp;body body</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Executes body in an environment in which each var is bound
		        to a stack-allocated macptr which encapsulates the address of a
		        stack-allocated region of size expr bytes. Returns whatever
		        value(s) body returns.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>var</parameter></term><listitem><para>A symbol (variable name)</para></listitem></varlistentry><varlistentry><term><parameter>expr</parameter></term><listitem><para>An expression which should evaluate to a non-negative
		              fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="make-cstring-function">
          <title>make-cstring [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>make-cstring string</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Allocates a block of memory (via malloc) of length (1+
		        (length string)). Copies the string to this block and appends a
		        trailing NUL byte; returns a MACPTR to the block.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>string</parameter></term><listitem><para>A lisp string</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="with-cstrs-macro">
          <title>with-cstrs [Macro]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>with-cstrs (var string)* &amp;body body</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Executes body in an environment in which each var is bound
		        to a stack-allocated macptr which encapsulates the %address of a
		        stack-allocated region of into which each string (and a trailing
		        NUL byte) has been copied. Returns whatever value(s) body returns.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>var</parameter></term><listitem><para>A symbol (variable name)</para></listitem></varlistentry><varlistentry><term><parameter>string</parameter></term><listitem><para>An expression which should evaluate to a lisp string</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="with-encoded-cstrs-macro">
          <title>with-encoded-cstrs [Macro]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>with-encoded-cstrs ENCODING-NAME (varI stringI)* &amp;body body</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Executes body in an environment in which each varI is
		        bound to a macptr which encapsulates the %address of a
		        stack-allocated region of into which each stringI (and a
		        trailing NUL character) has been copied. Returns whatever
		        value(s) body returns.</para><para>                ENCODING-NAME is a keyword constant that names a
                character encoding. Each foreign string is encoded in the
                named encoding. Each foreign string has dynamic
                extent.</para><para>                WITH-ENCODED-CSTRS does not automatically prepend
                byte-order marks to its output; the size of the terminating
                #\NUL character depends on the number of octets per code unit
                in the encoding.</para><para>The expression</para><programlisting>(ccl:with-cstrs ((x &quot;x&quot;)) (#_puts x))</programlisting><para>is functionally equivalent to</para><programlisting>(ccl:with-encoded-cstrs :iso-8859-1 ((x &quot;x&quot;)) (#_puts x))</programlisting></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para>&#xA0;</para><blockquote><variablelist><varlistentry><term><parameter>varI</parameter></term><listitem><para>A symbol (variable name)</para></listitem></varlistentry><varlistentry><term><parameter>stringI</parameter></term><listitem><para>An expression which should evaluate to a lisp string</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="get-cstring-function">
          <title>%get-cstring [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%get-cstring ptr</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Interprets ptr as a pointer to a (NUL -terminated) C string;
		        returns an equivalent lisp string.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><para/><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A MACPTR</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
        <section id="str-from-ptr-function">
          <title>%str-from-ptr [Function]</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term>Syntax</term>
                <listitem><para>%str-from-ptr ptr length</para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Description</term>
                <listitem><para>Returns a lisp string of length <parameter>length</parameter>,
		        whose contents are initialized from the bytes at<parameter>ptr.</parameter></para></listitem>
              </varlistentry>
              <varlistentry>
                <term>Arguments</term>
                <listitem><blockquote><variablelist><varlistentry><term><parameter>ptr</parameter></term><listitem><para>A
		                MACPTR</para></listitem></varlistentry><varlistentry><term><parameter>length</parameter></term><listitem><para>a
		                non-negative fixnum</para></listitem></varlistentry></variablelist></blockquote></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </section>
      </section>
    </section>
    <section id="the-interface-database">
      <title>The Interface Database</title>
      <section id="overview_in_the-interface-database">
        <title>Overview</title>
        <para>Clozure CL uses a set of database files which contain
        foreign type, record, constant, and function definitions
        derived from the operating system's header files, be that
        Linux or Darwin.  An archive containing these database files
        (and the shell scripts which were used in their creation) is
        available; see the Distributions page for information about
        obtaining current interface database files.</para>
        <para>Not surprisingly, different platforms use different database files.</para>
        <para>Clozure CL defines reader macros that consult these databases:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>#$foo looks up the value of the constant definition of foo</para></listitem>
            <listitem><para>#_foo looks up the foreign function definition for foo</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>In both cases, the symbol foo is interned in the &quot;OS&quot;
        package. The #$ reader macro has the side-effect of defining
        foo as a constant (as if via DEFCONSTANT); the #_ reader macro
        has the side effect of defining foo as a macro which will
        expand into an (EXTERNAL-CALL form.)</para>
        <para>        It's important to remember that the side-effect happens
        when the form containing the reader macro is
        read. Macroexpansion functions that expand into forms which
        contain instances of those reader macros don't do what one
        might think that they do, unless the macros are expanded in
        the same lisp session as the reader macro was read in.</para>
        <para>        In addition, references to foreign type,
        structure/union, and field names (when used in the RREF/PREF
        and RLET macros) will cause these database files to be
        consulted.</para>
        <para>        Since the Clozure CL sources contain instances of these
        reader macros (and references to foreign record types and
        fields), compiling Clozure CL from those sources depends on the
        ability to find and use (see <xref linkend="building-the-heap-image"/>).</para>
      </section>
      <section id="other-issues">
        <title>Other issues:</title>
        <blockquote>
          <itemizedlist>
            <listitem><para>Clozure CL now preserves the case of external symbols in
	        its database
	        files. See <xref linkend="case-sensitivity-of-foreign-names-in-clozure-cl"/> for information about
	        case in foreign symbol names.</para></listitem>
            <listitem><para>The Linux databases are derived from a somewhat
	        arbitrary set of Linux header files. Linux is enough of a
	        moving target that it may be difficult to define a standard,
	        reference set of interfaces from which to derive a standard,
	        reference set of database files.This seems to be less of
	        an issue with Darwin and FreeBSD.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>For information about building the database files,
	    see <xref linkend="the-interface-translator"/>.</para>
      </section>
    </section>
    <section id="using-interface-directories">
      <title>Using Interface Directories</title>
      <section id="overview_in_using-interface-directories">
        <title>Overview</title>
        <para>As distributed, the &quot;ccl:headers;&quot; (for LinuxPPC)
        directory is organized like:</para>
        <programlisting>
        headers/
        headers/gl/
        headers/gl/C/
        headers/gl/C/populate.sh
        headers/gl/constants.cdb
        headers/gl/functions.cdb
        headers/gl/records.cdb
        headers/gl/objc-classes.cdb
        headers/gl/objc-methods.cdb
        headers/gl/types.cdb
        headers/gnome/
        headers/gnome/C/
        headers/gnome/C/populate.sh
        headers/gnome/constants.cdb
        headers/gnome/functions.cdb
        headers/gnome/records.cdb
        headers/gnome/objc-classes.cdb
        headers/gnome/objc-methods.cdb
        headers/gnome/types.cdb
        headers/gtk/
        headers/gtk/C/
        headers/gtk/C/populate.sh
        headers/gtk/constants.cdb
        headers/gtk/functions.cdb
        headers/gtk/records.cdb
        headers/gtk/objc-classes.cdb
        headers/gtk/objc-methods.cdb
        headers/gtk/types.cdb
        headers/libc/
        headers/libc/C/
        headers/libc/C/populate.sh
        headers/libc/constants.cdb
        headers/libc/functions.cdb
        headers/libc/records.cdb
        headers/libc/objc-classes.cdb
        headers/libc/objc-methods.cdb
        headers/libc/types.cdb
      </programlisting>
        <para>e.g, as a set of parallel subdirectories, each with a
        lowercase name and each of which contains a set of 6 database
        files and a &quot;C&quot; subdirectory which contains a shell script
        used in the database creation process.</para>
        <para>        As one might assume, the database files in each of these
        subdirectories contain foreign type, constant, and function
        definitions - as well as Objective-C class and method info -that
        correspond (roughly) to the information contained in the
        header files associated with a &quot;-dev&quot; package in a Linux
        distribution.  &quot;libc&quot; corresponds pretty closely to the
        interfaces associated with &quot;glibc/libc6&quot; header files, &quot;gl&quot;
        corresponds to an &quot;openGL+GLUT&quot; development package, &quot;gtk&quot;
        and &quot;gnome&quot; contain interface information from the GTK+1.2 and
        GNOME libraries, respectively.</para>
        <para>        For Darwin, the &quot;ccl:darwin-headers&quot; directory contains
        a &quot;libc&quot; subdirectory, whose contents roughly correspond to
        those of &quot;/usr/include&quot; under Darwin, as well as
        subdirectories corresponding to the MacOSX Carbon and Cocoa
        frameworks.</para>
        <para>        To see the precise set of .h files used to generate the
        database files in a given interface directory, consult the
        corresponding &quot;populate.sh&quot; shell script (in the interface
        directory's &quot;C&quot; subdirectory.)</para>
        <para>        The intent is that this initial set can be augmented to
        meet local needs, and that this can be done in a fairly
        incremental fashion: one needn't have unrelated header files
        installed in order to generate interface databases for a
        package of interest.</para>
        <para>        Hopefully, this scheme will also make it easier to
        distribute patches and bug fixes.</para>
        <para>        Clozure CL maintains a list of directories; when looking
        for a foreign type, constant, function, or record definition,
        it'll consult the database files in each directory on that
        list. Initially, the list contains an entry for the &quot;libc&quot;
        interface directory. Clozure CL needs to be explicitly told to
        look in other interface directories should it need to do
        so.</para>
      </section>
      <section id="creating-new-interface-directories">
        <title>Creating new interface directories</title>
        <para>This example refers to &quot;ccl:headers;&quot;, which is
        appropriate for LinuxPPC. The procedure's analogous under
        Darwin, where the &quot;ccl:darwin-headers;&quot; directory would be
        used instead.</para>
        <para>        To create a new interface directory, &quot;foo&quot;, and a set of
        database files in that directory:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>Create a subdirectory of &quot;ccl:headers;&quot; named
	        &quot;foo&quot;.</para></listitem>
            <listitem><para>Create a subdirectory of &quot;ccl:headers;foo;&quot; named
	        &quot;C&quot;.</para></listitem>
            <listitem><para>Create a file in &quot;ccl:headers;foo;C;&quot; named
	        &quot;populate.sh&quot;.</para><para>One way of accomplishing the above steps is:</para><programlisting>
            ? (close (open &quot;ccl:headers;foo;C;populate.sh&quot; :direction :output :
                           if-does-not-exist :create :if-exists :overwrite))
          </programlisting></listitem>
            <listitem><para>Edit the file created above, using the &quot;populate.sh&quot;
	        files in the distribution as guidelines.</para><para>The file might wind up looking something like:</para><programlisting>#/bin/sh
            h-to-ffi.sh `foo-config -cflags` /usr/include/foo/foo.h</programlisting></listitem>
          </orderedlist>
        </blockquote>
        <para>Refer to <xref linkend="the-interface-translator"/> for
        information about running the interface translator and .ffi
        parser.</para>
        <para>Assuming that all went well, there should now be .cdb
        files in &quot;ccl:headers;foo;&quot;. You can then do
        <programlisting>
          ? (use-interface-dir :foo)
	    </programlisting> 
	    whenever you need to
        access the foreign type information in those database
        files.</para>
      </section>
    </section>
    <section id="using-shared-libraries">
      <title>Using Shared Libraries</title>
      <section id="overview_in_using-shared-libraries">
        <title>Overview</title>
        <para>Clozure CL provides facilities to open and close shared
        libraries.</para>
        <para>&quot;Opening&quot; a shared library, which is done with <indexterm><primary><literal>OPEN-SHARED-LIBRARY</literal></primary></indexterm><link linkend="f_open-shared-library"><literal>OPEN-SHARED-LIBRARY</literal></link>, maps the library's code and
        data into Clozure CL's address space and makes its exported
        symbols accessible to Clozure CL.</para>
        <para>&quot;Closing&quot; a shared library, which is done with <indexterm><primary><literal>CLOSE-SHARED-LIBRARY</literal></primary></indexterm><link linkend="f_close-shared-library"><literal>CLOSE-SHARED-LIBRARY</literal></link>, unmaps the library's code
        and and removes the library's symbols from the global
        namespace.</para>
        <para>A small number of shared libraries (including libc,
        libm, libdl under Linux, and the &quot;system&quot; library under
        Darwin) are opened by the lisp kernel and can't be
        closed.</para>
        <para>        Clozure CL uses data structures of type
        EXTERNAL-ENTRY-POINT to map a foreign function name (string)
        to that foreign function's <emphasis>current</emphasis>
        address. (A function's address may vary from session to
        session as different versions of shared libraries may load at
        different addresses; it may vary within a session for similar
        reasons.)</para>
        <para>        An EXTERNAL-ENTRY-POINT whose address is known is said
        to be <emphasis>resolved</emphasis>. When an external entry
        point is resolved, the shared library which defines that entry
        point is noted; when a shared library is closed, the entry
        points that it defines are made unresolved.  An
        EXTERNAL-ENTRY-POINT must be in the resolved state in order to
        be FF-CALLed; calling an unresolved entry point causes a &quot;last
        chance&quot; attempt to resolve it. Attempting to resolve an
        entrypoint that was defined in a closed library will cause an
        attempt to reopen that library.</para>
        <para>        Clozure CL keeps track of all libraries that have been
        opened in a lisp session. When a saved application is first
        started, an attempt is made to reopen all libraries that were
        open when the image was saved, and an attempt is made to
        resolve all entry points that had been referenced when the
        image was saved. Either of these attempts can fail &quot;quietly&quot;,
        leaving some entry points in an unresolved state.</para>
        <para>        Linux shared libraries can be referred to either by a
        string which describes their full pathname or by their
        <emphasis>soname</emphasis>, a shorter string that can be
        defined when the library is created. The dynamic linker
        mechanisms used in Linux make it possible (through a series of
        filesystem links and other means) to refer to a library via
        several names; the library's soname is often the most
        appropriate identifier.</para>
        <para>        so names are often less version-specific than other names
        for libraries; a program that refers to a library by the name
        &quot;libc.so.6&quot; is more portable than one which refers to
        &quot;libc-2.1.3.so&quot; or to &quot;libc-2.2.3.so&quot;, even though the latter
        two names might each be platform-specific aliases of the
        first.</para>
        <para>        All of the global symbols described below are exported
        from the CCL package.</para>
      </section>
      <section id="limitations-and-known-bugs_in_using-shared-libraries">
        <title>Limitations and known bugs</title>
        <blockquote>
          <itemizedlist>
            <listitem><para>Don't get me started.</para></listitem>
            <listitem><para>The underlying functionality has a poor notion of
	        dependency;it's not always possible to open libraries that
	        depend on unopened libraries, but it's possible to close
	        libraries on which other libraries depend. It
	        <emphasis>may</emphasis> be possible to generate
	        more explicit dependency information by parsing the output
	        of the Linux ldd and ldconfig programs.</para></listitem>
          </itemizedlist>
        </blockquote>
      </section>
      <section id="darwin-notes">
        <title>&gt;Darwin Notes</title>
        <para>Darwin shared libraries come in two (basic) flavors:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>&quot;dylibs&quot; (which often have the extension&quot;.dylib&quot;) are
	        primarily intended to be linked against at compile/link
	        time. They can be loaded dynamically,<emphasis>but can't
	        be unloaded</emphasis>. Accordingly,OPEN-SHARED-LIBRARY
	        can be used to open a .dylib-style library;calling
	        CLOSE-SHARED-LIBRARY on the result of such a call produces
	        a warning, and has no other effect. It appears that (due
	        to an OS bug) attempts to open .dylib shared-libraries
	        that are already open can cause memory corruption unless
	        the full pathname of the .dylib file is specified on the
	        first and all subsequent calls.</para></listitem>
            <listitem><para>&quot;bundles&quot; are intended to serve as application
	        extensions; they can be opened multiple times (creating
	        multiple instances of the library!) and closed
	        properly.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>Thanks to Michael Klingbeil for getting both kinds of
        Darwin shared libraries working in Clozure CL.</para>
      </section>
    </section>
    <section id="the-interface-translator">
      <title>The Interface Translator</title>
      <section id="overview_in_the-interface-translator">
        <title>Overview</title>
        <para>Clozure CL uses an interface translation system based on the FFIGEN
	    system, which is described at
	    <ulink url="http://www.ccs.neu.edu/home/lth/ffigen/">this page</ulink>
	    The interface translator makes
	    the constant, type, structure, and function definitions in a set of
	    C-language header files available to lisp code.</para>
        <para>        The basic idea of the FFIGEN scheme is to use the C
        compiler's frontend and parser to translate .h files into
        semantically equivalent .ffi files, which represent the
        definitions from the headers using a syntax based on
        S-expressions.  Lisp code can then concentrate on the .ffi
        representation, without having to concern itself with the
        semantics of header file inclusion or the arcana of C
        parsing.</para>
        <para>        The original FFIGEN system used a modified version of
        the LCC C compiler to produce .ffi files. Since many OS
        header files contain GCC-specific constructs, Clozure CL's
        translation system uses a modified version of GCC (called,
        somewhat confusingly, ffigen.)</para>
        <para>	See <ulink url="http://trac.clozure.com/openmcl/wiki/BuildFFIGEN">here</ulink> for information on building and installing ffigen.</para>
        <para>        A component shell script called h-to-ffi.sh reads a
        specified .h file (and optional preprocessor arguments) and writes
         a (hopefully) equivalent .ffi file to standard output, calling 
        the ffigen program with appropriate  arguments.</para>
        <para>        For each interface directory (see FIXTHIS)
        <emphasis>subdir</emphasis> distributed with Clozure CL, a shell
        script (distributed with Clozure CL as
        &quot;ccl:headers;<emphasis>subdir</emphasis>;C;populate.sh&quot;
        (or some other platform-specific headers directory)
        calls h-to-ffi.sh on a large number of the header
        files in /usr/include (or some other <emphasis>system header
          path</emphasis>) and creates a parallel directory tree in
        &quot;ccl:headers;<emphasis>subdir</emphasis>;C;<emphasis>system</emphasis>;<emphasis>header</emphasis>;<emphasis>path</emphasis>;&quot;
        (or
        &quot;ccl:darwin-headers;<emphasis>subdir</emphasis>;C;<emphasis>system</emphasis>;<emphasis>header</emphasis>;<emphasis>path</emphasis>;&quot;, etc.),
        populating that directory with .ffi files.</para>
        <para>        A lisp function defined in &quot;ccl:library;parse-ffi.lisp&quot;
        reads the .ffi files in a specified interface directory
        <emphasis>subdir</emphasis> and generates new versions of the
        databases (files with the extension .cdb).</para>
        <para>        The CDB databases are used by the #$ and #_ reader
        macros and are used in the expansion of RREF, RLET, and
        related macros.</para>
      </section>
      <section id="details-rebuilding-the-cdb-databases-step-by-step">
        <title>Details: rebuilding the CDB databases, step by step</title>
        <blockquote>
          <orderedlist>
            <listitem><para>Ensure that the FFIGEN program is installed. See
	        the&quot;README&quot; file generated during the FFIGEN build process for
	        specific installation instructions.This example assumes
	        LinuxPPC; for other platforms, substitute the appropriate
		headers directory. </para></listitem>
            <listitem><para>Edit the
	        &quot;ccl:headers;<emphasis>subdir</emphasis>;C;populate.sh&quot;shell
	        script. When you're confident that the files
	        and preprocessor options match your environment, cd to
	        the&quot;ccl:headers;<emphasis>subdir</emphasis>;C;&quot; directory
	        and invoke ./populate.sh. Repeat this step until you're
	        able to cleanly translate all files referenced in the shell
	        script.</para></listitem>
            <listitem><para>Run Clozure CL:
            <programlisting><para>
              ? (require &quot;PARSE-FFI&quot;)
              PARSE-FFI</para><para>              ? (ccl::parse-standard-ffi-files :SUBDIR)
              ;;; lots of output ... after a while, shiny new .cdb files should
              ;;; appear in &quot;ccl:headers;subdir;&quot;
          </para></programlisting></para><para>It may be necessary to call CCL::PARSE-STANDARD-FFI-FILES
                  twice, to ensure that forward-references are resolved </para></listitem>
          </orderedlist>
        </blockquote>
      </section>
    </section>
    <section id="case-sensitivity-of-foreign-names-in-clozure-cl">
      <title>Case-sensitivity of foreign names in Clozure CL</title>
      <section id="overview_in_case-sensitivity-of-foreign-names-in-clozure-cl">
        <title>Overview</title>
        <para>As of release 0.11, Clozure CL addresses the fact that
	    foreign type, constant, record, field, and function nams are
	    case-sensitive and provides mechanisms to refer to these names
	    via lisp symbols.</para>
        <para>        Previous versions of Clozure CL have tried to ignore that
        fact, under the belief that case conflicts were rare and that
        many users (and implementors) would prefer not to deal with
        case-related issues. The fact that some information in the
        interface databases was incomplete or inaccessible because of
        this policy made it clearer that the policy was untenable. I
        can't claim that the approach described here is aesthetically
        pleasing, but I can honestly say that it's less unpleasant
        than other approaches that I'd thought of. I'd be interested
        to hear alternate proposals.</para>
        <para>        The issues described here have to do with how lisp
        symbols are used to denote foreign functions, constants,
        types, records, and fields. It doesn't affect how other lisp
        objects are sometimes used to denote foreign objects. For
        instance, the first argument to the EXTERNAL-CALL macros is
        now and has always been a case-sensitive string.</para>
      </section>
      <section id="foreign-constant-and-function-names">
        <title>Foreign constant and function names</title>
        <para>The primary way of referring to foreign constant and
        function names in Clozure CL is via the #$ and #_ reader
        macros. These reader macro functions each read a symbol into
        the &quot;OS&quot; package, look up its constant or function definition
        in the interface database, and assign the value of the
        constant to the symbol or install a macroexpansion function on
        the symbol.</para>
        <para>        In order to observe case-sensitivity, the reader-macros
        now read the symbol with (READTABLE-CASE :PRESERVE) in
        effect.</para>
        <para>        This means that it's necessary to type the foreign
        constant or function name in correct case, but it isn't
        necessary to use any special escaping constructs when writing
        the variable name. For instance:</para>
        <programlisting>
        (#_read fd buf n) ; refers to foreign symbol &quot;read&quot;
        (#_READ fd buf n) ; refers to foreign symbol &quot;READ&quot;, which may
        ; not exist ...
        #$o_rdonly ; Probably doesn't exist
        #$O_RDONLY ; Exists on most platforms
      </programlisting>
      </section>
      <section id="foreign-type-record-and-field-names">
        <title>Foreign type, record, and field names</title>
        <para>Constructs like RLET expect a foreign type or record
	    name to be denoted by a symbol (typically a keyword); RREF
	    (and PREF) expect an &quot;accessor&quot; form, typically a keyword
	    formed by concatenating a foreign type or record name with a
	    sequence of one or more foreign field names, separated by
	    dots. These names are interned by the reader as other lisp
	    symbols are, with an arbitrary value of READTABLE-CASE in
	    effect (typically :UPCASE.) It seems like it would be very
	    tedious to force users to manually escape (via vertical bar or
	    backslash syntax) all lowercase characters in symbols used to
	    specify foreign type, record, and field names (especially
	    given that many traditional POSIX structure, type, and field
	    names are entirely lowercase.)</para>
        <para>        The approach taken by Clozure CL is to allow the symbols
        (keywords) used to denote foreign type, record, and field
        names to contain angle brackets (<literal>&lt;</literal> and
        <literal>&gt;</literal>). Such symbols are translated to
	    foreign names via the following set of conventions:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>All instances of &lt; and &gt; in the symbol's pname
	        are balanced and don't nest.</para></listitem>
            <listitem><para>Any alphabetic characters in the symbol's pname
	        that aren't enclosed in angle brackets are treated as
	        lower-case,regardless of the value of READTABLE-CASE and
	        regardless of the case in which they were written.</para></listitem>
            <listitem><para>Alphabetic characters that appear within angle
	        brackets are mapped to upper-case, again regardless of how
	        they were written or interned.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>There may be many ways of &quot;escaping&quot; (with angle
	    brackets) sequences of upper-case and non-lower-case
	    characters in a symbol used to denote a foreign name. When
	    translating in the other direction, Clozure CL always escapes the
	    longest sequence that starts with an upper-case character and
	    doesn't contain a lower-case character.</para>
        <para>        It's often preferable to use this canonical form of a
        foreign type name.</para>
        <para>        The accessor forms used by PREF/RREF should be viewed as
        a series of foreign type/record and field names; upper-case
        sequences in the component names should be escaped with angle
        brackets, but those sequences shouldn't span components. (More
        simply, the separating dots shouldn't be enclosed, even if
        both surrounding characters need to be.)</para>
        <para>        Older POSIX code tends to use lower-case exclusively for
        type, record, and field names; there are only a few cases in
        the Clozure CL sources where mixed-case names need to be
        escaped.</para>
      </section>
      <section id="examples_in_case-sensitivity-of-foreign-names-in-clozure-cl">
        <title>Examples</title>
        <programlisting>
        ;;; Allocate a record of type &quot;window&quot;.
        (rlet ((w :window)) ...)
        ;;; Allocate a record of type &quot;Window&quot;, which is probably a
        ;;;  different type
        (rlet ((w :&lt;w&gt;indow)) ...)
        ;;; This is equivalent to the last example
        (rlet ((w :&lt;w&gt;INDOW)))
      </programlisting>
      </section>
    </section>
    <section id="reading-foreign-names">
      <title>Reading Foreign Names</title>
      <para>Clozure CL
      provides several reader macros to make it more convenient to
      handle foreign type, function, variable, and constant
      names. Each of these reader macros reads symbols preserving the
      case of the source text, and selects an appropriate package in
      which to intern the resulting symbol. These reader macros are
      especially useful when your Lisp code interacts extensively with
      a foreign library-for example, when using Mac OS X's Cocoa
      frameworks.</para>
      <para>      These reader macros include &quot;#_&quot; to read foreign function
      names, &quot;#&amp;&quot; to read foreign variable names (note that in
      earlier versions of OpenMCL the reader macro &quot;#?&quot; was used for
      this same purpose), &quot;#$&quot; to read foreign constant names, &quot;#/&quot; to
      read the names of foreign Objective-C methods, and &quot;#&gt;&quot; to read
      keywords that can be used as the names of types, records, and
      accessors.</para>
      <para>      All of these reader macros preserve the case of the text
      that they read; beyond that similarity, each performs some
      additional work, unique to each reader macro, to create symbols
      suitable for a particular use. For example, the function,
      variable, and constant reader macros intern the resulting symbol
      in the &quot;OS&quot; package of the running platform, but the reader
      macro for Objective-C method names interns symbols in the
      &quot;NEXTSTEP-FUNCTIONS&quot; package.</para>
      <para>      You are likely to see these reader macros used extensively
      in Lisp code that works with foreign libraries; for example,
      Clozure CL IDE code, which defines numerous Objective-C classes
      and methods, uses these reader macros extensively.</para>
      <para>      For more detailed descriptions of each of these reader
      macros, see the Foreign-Function-Interface Dictionary
      section.</para>
    </section>
    <section id="tutorial-using-basic-calls-and-types">
      <title>Tutorial: Using Basic Calls and Types</title>
      <para>This tutorial is meant to cover the basics of Clozure CL for
      calling external C functions and passing data back and forth.
      These basics will provide the foundation for more advanced
      techniques which will allow access to the various external
      libraries and toolkits.</para>
      <para>      The first step is to start with a simple C dynamic library
      in order to actually observe what is actually passing between
      Clozure CL and C.  So, some C code is in order:</para>
      <para>      Create the file typetest.c, and put the following code
      into it:</para>
      <programlisting><para>
#include &lt;stdio.h&gt;</para><para>void
void_void_test(void)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
}</para><para>signed char
sc_sc_test(signed char data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %d\n&quot;, (signed int)data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}</para><para>unsigned char
uc_uc_test(unsigned char data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %d\n&quot;, (signed int)data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}
    </para></programlisting>
      <para>This defines three functions.  If you're familiar with C,
      notice that there's no <literal>main()</literal>, because we're
      just building a library, not an executable.</para>
      <para>      The function <literal>void_void_test()</literal> doesn't
      take any parameters, and doesn't return anything, but it prints
      two lines to let us know it was called.
      <literal>sc_sc_test()</literal> takes a signed char as a
      parameter, prints it, and returns it.
      <literal>uc_uc_test()</literal> does the same thing, but with an
      unsigned char.  Their purpose is just to prove to us that we
      really can call C functions, pass them values, and get values
      back from them.</para>
      <para>      This code is compiled into a dynamic library on OS X
      10.3.4 with the command:</para>
      <programlisting><para/><para>      gcc -dynamiclib -Wall -o libtypetest.dylib typetest.c \
      -install_name ./libtypetest.dylib
    </para></programlisting>
      <blockquote>
        <title>Tip</title>
        <para>Users of 64-bit platforms may need to pass options such
        as &quot;-m64&quot; to gcc, may need to give the output library a different
        extension (such as &quot;.so&quot;), and may need to user slightly different
        values for other options in order to create an equivalent test
        library.</para>
      </blockquote>
      <para>The -dynamiclib tells gcc that we will be compiling this
      into a dynamic library and not an executable binary program.
      The output filename is &quot;libtypetest.dylib&quot;.  Notice that we
      chose a name which follows the normal OS X convention, being in
      the form &quot;libXXXXX.dylib&quot;, so that other programs can link to
      the library.  Clozure CL doesn't need it to be this way, but it is
      a good idea to adhere to existing conventions.</para>
      <para>      The -install_name flag is primarily used when building OS
      X &quot;bundles&quot;.  In this case, we are not using it, so we put a
      placeholder into it, &quot;./libtypetest.dylib&quot;.  If we wanted to use
      typetest in a bundle, the -install_name argument would be a
      relative path from some &quot;current&quot; directory.</para>
      <para>      After creating this library, the first step is to tell
      Clozure CL to open the dynamic library.  This is done by calling
      .</para>
      <programlisting><para/><para>      Welcome to Clozure CL Version (Beta: Darwin) 0.14.2-040506!</para><para>      ? (open-shared-library &quot;/Users/andewl/openmcl/libtypetest.dylib&quot;)
      #&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;
    </para></programlisting>
      <para>You should use an absolute path here; using a relative
      one, such as just &quot;libtypetest.dylib&quot;, would appear to work, but
      there are subtle problems which occur after reloading it.  See
      the Darwin notes on for details.  It would be a bad idea anyway,
      because software should never rely on its starting directory
      being anything in particular.</para>
      <para>      This command returns a reference to the opened shared library, and
      Clozure CL also adds one to the global variable
      <literal>ccl::*shared-libraries*</literal>:</para>
      <programlisting><para/><para>      ? ccl::*shared-libraries*
      (#&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;
       #&lt;SHLIB /usr/lib/libSystem.B.dylib #x606179E&gt;)
    </para></programlisting>
      <para>Before we call anything, let's check that the individual
      functions can actually be found by the system.  We don't have to
      do this, but it helps to know how to find out whether this is
      the problem, when something goes wrong.  We use <indexterm><primary><literal>EXTERNAL-CALL</literal></primary></indexterm><link linkend="m_external-call"><literal>EXTERNAL-CALL</literal></link>:</para>
      <programlisting><para/><para>      ? (external &quot;_void_void_test&quot;)
      #&lt;EXTERNAL-ENTRY-POINT &quot;_void_void_test&quot; (#x000CFDF8) /Users/andewl/openmcl/libtypetest.dylib #x638EDF6&gt;</para><para>      ? (external &quot;_sc_sc_test&quot;)
      #&lt;EXTERNAL-ENTRY-POINT &quot;_sc_sc_test&quot; (#x000CFE50) /Users/andewl/openmcl/libtypetest.dylib #x638EB3E&gt;</para><para>      ? (external &quot;_uc_uc_test&quot;)
      #&lt;EXTERNAL-ENTRY-POINT &quot;_uc_uc_test&quot; (#x000CFED4) /Users/andewl/openmcl/libtypetest.dylib #x638E626&gt;
    </para></programlisting>
      <para>Notice that the actual function names have been &quot;mangled&quot;
      by the C linker.  The first function was named &quot;void_void_test&quot;
      in typetest.c, but in libtypetest.dylib, it has an underscore (a
      &quot;_&quot; symbol) before it: &quot;_void_void_test&quot;.  So, this is the name
      which you have to use.  The mangling - the way the name is
      changed - may be different for other operating systems or other
      versions, so you need to &quot;just know&quot; how it's done...</para>
      <para>      Also, pay particular attention to the fact that a
      hexadecimal value appears in the EXTERNAL-ENTRY-POINT.
      (#x000CFDF8, for example - but what it is doesn't matter.)
      These hex numbers mean that the function can be dereferenced.
      Functions which aren't found will not have a hex number.  For
      example:</para>
      <programlisting><para/><para>      ? (external &quot;functiondoesnotexist&quot;)
      #&lt;EXTERNAL-ENTRY-POINT &quot;functiondoesnotexist&quot; {unresolved}  #x638E3F6&gt;
    </para></programlisting>
      <para>The &quot;unresolved&quot; tells us that Clozure CL wasn't able to find this
      function, which means you would get an error, &quot;Can't resolve foreign
      symbol,&quot; if you tried to call it.</para>
      <para>      These external function references also are stored in a
      hash table which is accessible through a global variable,
      <literal>ccl::*eeps*</literal>.</para>
      <para>      At this point, we are ready to try our first external
      function call:</para>
      <programlisting><para/><para>      ? (external-call &quot;_void_void_test&quot; :void)
      Entered void_void_test:
      Exited  void_void_test:
      NIL
    </para></programlisting>
      <para>We used , which is is the normal mechanism for accessing
      externally linked code.  The &quot;_void_void_test&quot; is the mangled
      name of the external function.  The :void refers to the return
      type of the function.</para>
      <para>      The next step is to try passing a value to C, and getting one
      back:</para>
      <programlisting><para/><para>      ? (external-call &quot;_sc_sc_test&quot; :signed-byte -128 :signed-byte)
      Entered sc_sc_test:
      Data In: -128
      Exited  sc_sc_test:
      -128
    </para></programlisting>
      <para>The first :signed-byte gives the type of the first
      argument, and then -128 gives the value to pass for it.  The
      second :signed-byte gives the return type.  The return type is
      always given by the last argument to .</para>
      <para>      Everything looks good.  Now, let's try a number outside
      the range which fits in one byte:</para>
      <programlisting><para/><para>      ? (external-call &quot;_sc_sc_test&quot; :signed-byte -567 :signed-byte)
      Entered sc_sc_test:
      Data In: -55
      Exited  sc_sc_test:
      -55
    </para></programlisting>
      <para>Hmmmm.  A little odd.  Let's look at the unsigned stuff to
      see how it reacts:</para>
      <programlisting><para/><para>      ? (external-call &quot;_uc_uc_test&quot; :unsigned-byte 255 :unsigned-byte)
      Entered uc_uc_test:
      Data In: 255
      Exited  uc_uc_test:
      255
    </para></programlisting>
      <para>That looks okay.  Now, let's go outside the valid range again:</para>
      <programlisting><para/><para>      ? (external-call &quot;_uc_uc_test&quot; :unsigned-byte 567 :unsigned-byte)
      Entered uc_uc_test:
      Data In: 55
      Exited  uc_uc_test:
      55</para><para>      ? (external-call &quot;_uc_uc_test&quot; :unsigned-byte -567 :unsigned-byte)
      Entered uc_uc_test:
      Data In: 201
      Exited  uc_uc_test:
      201
    </para></programlisting>
      <para>Since a signed byte can only hold values from -128 through 127, and
      an unsigned one can only hold values from 0 through 255, any number
      outside that range gets &quot;clipped&quot;: only the low eight bits of it
      are used.</para>
      <para>        What is important to remember is that <emphasis>external
        function calls have
        very few safety checks.</emphasis>
      Data outside the valid range for its type will silently do
      very strange things; pointers outside the valid range can very well
      crash the system.</para>
      <para>      That's it for our first example library.  If you're still
      following along, let's add some more C code to look at the rest
      of the primitive types.  Then we'll need to recompile the
      dynamic library, load it again, and then we can see what
      happens.</para>
      <para>Add the following code to typetest.c:</para>
      <programlisting><para>
int
si_si_test(int data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %d\n&quot;, data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}</para><para>long
sl_sl_test(long data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %ld\n&quot;, data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}</para><para>long long
sll_sll_test(long long data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %lld\n&quot;, data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}</para><para>float
f_f_test(float data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %e\n&quot;, data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}</para><para>double
d_d_test(double data)
{
    printf(&quot;Entered %s:\n&quot;, __FUNCTION__);
    printf(&quot;Data In: %e\n&quot;, data);
    printf(&quot;Exited  %s:\n&quot;, __FUNCTION__);
    fflush(stdout);
    return data;
}
    </para></programlisting>
      <para>The command line to compile the dynamic library is the same as before:</para>
      <programlisting><para/><para>      gcc -dynamiclib -Wall -o libtypetest.dylib typetest.c \
      -install_name ./libtypetest.dylib
    </para></programlisting>
      <para>Now, restart Clozure CL.  This step is required because
      Clozure CL cannot close and reload a dynamic library on OS
      X.</para>
      <para>Have you restarted?  Okay, try out the new code:</para>
      <programlisting><para/><para>      Welcome to Clozure CL Version (Beta: Darwin) 0.14.2-040506!</para><para>      ? (open-shared-library &quot;/Users/andewl/openmcl/libtypetest.dylib&quot;)
      #&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;</para><para>      ? (external-call &quot;_si_si_test&quot; :signed-fullword -178965 :signed-fullword)
      Entered si_si_test:
      Data In: -178965
      Exited  si_si_test:
      -178965</para><para>      ? ;; long is the same size as int on 32-bit machines.
      (external-call &quot;_sl_sl_test&quot; :signed-fullword -178965 :signed-fullword)
      Entered sl_sl_test:
      Data In: -178965
      Exited  sl_sl_test:
      -178965</para><para>      ? (external-call &quot;_sll_sll_test&quot;
      :signed-doubleword -973891578912 :signed-doubleword)
      Entered sll_sll_test:
      Data In: -973891578912
      Exited  sll_sll_test:
      -973891578912
    </para></programlisting>
      <para>Okay, everything seems to be acting as expected.  However,
      just to remind you that most of this stuff has no safety net,
      here's what happens if somebody mistakes
      <literal>sl_sl_test()</literal> for
      <literal>sll_sll_test()</literal>, thinking that a long is
      actually a doubleword:</para>
      <programlisting><para/><para>      ? (external-call &quot;_sl_sl_test&quot;
      :signed-doubleword -973891578912 :signed-doubleword)
      Entered sl_sl_test:
      Data In: -227
      Exited  sl_sl_test:
      -974957576192
    </para></programlisting>
      <para>Ouch.  The C function changes the value with no warning
      that something is wrong.  Even worse, it manages to pass the
      original value back to Clozure CL, which hides the fact that
      something is wrong.</para>
      <para>      Finally, let's take a look at doing this with
      floating-point numbers.</para>
      <programlisting><para/><para>      Welcome to Clozure CL Version (Beta: Darwin) 0.14.2-040506!</para><para>      ? (open-shared-library &quot;/Users/andewl/openmcl/libtypetest.dylib&quot;)
      #&lt;SHLIB /Users/andewl/openmcl/libtypetest.dylib #x638EF3E&gt;</para><para>      ? (external-call &quot;_f_f_test&quot; :single-float -1.256791e+11 :single-float)
      Entered f_f_test:
      Data In: -1.256791e+11
      Exited  f_f_test:
      -1.256791E+11</para><para>      ? (external-call &quot;_d_d_test&quot; :double-float -1.256791d+290 :double-float)
      Entered d_d_test:
      Data In: -1.256791e+290
      Exited  d_d_test:
      -1.256791D+290
    </para></programlisting>
      <para>Notice that the number ends with &quot;...e+11&quot; for the single-float,
      and &quot;...d+290&quot; for the
      double-float.  Lisp has both of these float types itself, and the
      d instead of the e is how you specify which to create.  If
      you tried to pass :double-float 1.0e2 to external-call, Lisp would
      be nice enough to notice and give you a type error.  Don't get the
      :double-float wrong, though, because then there's no protection.</para>
      <para>      Congratulations!  You now know how to call external C functions from
      within Clozure CL, and pass numbers back and forth.  Now that the basic
      mechanics of calling and passing work, the next step is to examine how
      to pass more complex data structures around.</para>
      <section id="acknowledgement_in_tutorial-using-basic-calls-and-types">
        <title>Acknowledgement</title>
        <para>This chapter was generously contributed by Andrew
	    P. Lentvorski Jr.</para>
      </section>
    </section>
    <section id="tutorial-allocating-foreign-data-on-the-lisp-heap">
      <title>Tutorial: Allocating Foreign Data on the Lisp Heap </title>
      <para>Not every foreign function is so marvelously easy to use
      as the ones we saw in the last section.  Some functions require
      you to allocate a C struct, fill it with your own
      information, and pass in a pointer to that struct.  Some of them
      require you to allocate an empty struct that they will fill in
      so that you can read the information out of it.</para>
      <para>    There are generally two ways to allocate foreign data.  The
    first way is to allocate it on the stack; the RLET macro is one way to do this.
    This is analogous to using automatic variables in C.  In the
    jargon of Common Lisp, data allocated this way is said to have
    dynamic extent.</para>
      <para>    The other way to heap-allocate the foreign data.  This is
    analogous to calling malloc in C.  Again in the jargon of Common
    Lisp, heap-allocated data is said to have indefinite extent. If a
    function heap-allocates some data, that data remains valid even
    after the function itself exits.  This is useful for data which
    may need to be passed between multiple C calls or multiple
    threads. Also, some data may be too large to copy multiple times
    or may be too large to allocate on the stack.</para>
      <para>      The big disadvantage to allocating data on the heap is
      that it must be explicitly deallocated-you need to &quot;free&quot; it
      when you're done with it.  Normal Lisp objects, even those with indefinite
      extent, are deallocated by the garbage collector when it can prove
      that they're no longer referenced.  Foreign data, though, is outside the
      GC's ken:  it has no way to know whether a blob of foreign data is still
      referenced by foreign code or not. It is thus up to the programmer
      to manage it manually, just as one
      does in C with malloc and free.</para>
      <para>      What that means is that, if you allocate something and
      then lose track of the pointer to it, there's no way to ever
      free that memory.  That's what's called a memory leak, and if
      your program leaks enough memory it will eventually use up all
      of it!  So, you need to be careful to not lose your
      pointers.</para>
      <para>      That disadvantage, though, is also an advantage for using
      foreign functions.  Since the garbage collector doesn't know
      about this memory, it will never move it around.  External C
      code needs this, because it doesn't know how to follow it to
      where it moved, the way that Lisp code does.  If you allocate
      data manually, you can pass it to foreign code and know that no
      matter what that code needs to do with it, it will be able to,
      until you deallocate it.  Of course, you'd better be sure it's
      done before you do.  Otherwise, your program will be unstable
      and might crash sometime in the future, and you'll have trouble
      figuring out what caused the trouble, because there won't be
      anything pointing back and saying &quot;you deallocated this too
      soon.&quot;</para>
      <para>And, so, on to the code...</para>
      <para>      As in the last tutorial, our first step
      is to create a local dynamic library in order to help show
      what is actually going on between Clozure CL and C.  So, create the file
      ptrtest.c, with the following code:</para>
      <programlisting><para>
#include &lt;stdio.h&gt;</para><para>void reverse_int_array(int * data, unsigned int dataobjs)
{
    int i, t;</para><para>    for(i=0; i&lt;dataobjs/2; i++)
        {
            t = *(data+i);
            *(data+i) = *(data+dataobjs-1-i);
            *(data+dataobjs-1-i) = t;
        }
}</para><para>void reverse_int_ptr_array(int **ptrs, unsigned int ptrobjs)
{
    int *t;
    int i;</para><para>    for(i=0; i&lt;ptrobjs/2; i++)
        {
            t = *(ptrs+i);
            *(ptrs+i) = *(ptrs+ptrobjs-1-i);
            *(ptrs+ptrobjs-1-i) = t;
        }
}</para><para>void
reverse_int_ptr_ptrtest(int **ptrs)
{
    reverse_int_ptr_array(ptrs, 2);</para><para>    reverse_int_array(*(ptrs+0), 4);
    reverse_int_array(*(ptrs+1), 4);
}
    </para></programlisting>
      <para>This defines three functions.
      <literal>reverse_int_array</literal> takes a pointer to an array
      of <literal>int</literal>s, and a count telling how many items
      are in the array, and loops through it putting the elements in
      reverse.  <literal>reverse_int_ptr_array</literal> does the same
      thing, but with an array of pointers to <literal>int</literal>s.
      It only reverses the order the pointers are in; each pointer
      still points to the same thing.
      <literal>reverse_int_ptr_ptrtest</literal> takes an array of
      pointers to arrays of <literal>int</literal>s.  (With me?)  It
      doesn't need to be told their sizes; it just assumes that the
      array of pointers has two items, and that both of those are
      arrays which have four items.  It reverses the array of
      pointers, then it reverses each of the two arrays of
      <literal>int</literal>s.</para>
      <para>      Now, compile ptrtest.c into a dynamic library using the
      command:</para>
      <programlisting>
      gcc -dynamiclib -Wall -o libptrtest.dylib ptrtest.c -install_name ./libptrtest.dylib
    </programlisting>
      <para>The function <literal>make-heap-ivector</literal> is the
      primary tool for allocating objects in heap memory.  It
      allocates a fixed-size Clozure CL object in heap memory.  It
      returns both an array reference, which can be used directly from
      Clozure CL, and a <literal>macptr</literal>, which can be used to
      access the underlying memory directly.  For example:</para>
      <programlisting><para>
      ? ;; Create an array of 3 4-byte-long integers
      (multiple-value-bind (la lap)
          (make-heap-ivector 3 '(unsigned-byte 32))
        (setq a la)
        (setq ap lap))
      ;Compiler warnings :
      ;   Undeclared free variable A, in an anonymous lambda form.
      ;   Undeclared free variable AP, in an anonymous lambda form.
      #&lt;A Mac Pointer #x10217C&gt;</para><para>      ? a
      #(1396 2578 97862649)</para><para>      ? ap
      #&lt;A Mac Pointer #x10217C&gt;
    </para></programlisting>
      <para>It's important to realize that the contents of the
      <literal>ivector</literal> we've just created haven't been
      initialized, so their values are unpredictable, and you should
      be sure not to read from them before you set them, to avoid
      confusing results.</para>
      <para>      At this point, <literal>a</literal> references an object
      which works just like a normal array.  You can refer to any item
      of it with the standard <literal>aref</literal> function, and
      set them by combining that with <literal>setf</literal>.  As
      noted above, the <literal>ivector</literal>'s contents haven't
      been initialized, so that's the next order of business:</para>
      <programlisting><para>
      ? a
      #(1396 2578 97862649)</para><para>      ? (aref a 2)
      97862649</para><para>      ? (setf (aref a 0) 3)
      3</para><para>      ? (setf (aref a 1) 4)
      4</para><para>      ? (setf (aref a 2) 5)
      5</para><para>      ? a
      #(3 4 5)
    </para></programlisting>
      <para>In addition, the <literal>macptr</literal> allows direct
      access to the same memory:</para>
      <programlisting><para>
      ? (setq *byte-length-of-long* 4)
      4</para><para>      ? (%get-signed-long ap (* 2 *byte-length-of-long*))
      5</para><para>      ? (%get-signed-long ap (* 0 *byte-length-of-long*))
      3</para><para>      ? (setf (%get-signed-long ap (* 0 *byte-length-of-long*)) 6)
      6</para><para>      ? (setf (%get-signed-long ap (* 2 *byte-length-of-long*)) 7)
      7</para><para>      ? ;; Show that a actually got changed through ap
      a
      #(6 4 7)
    </para></programlisting>
      <para>So far, there is nothing about this object that could not
      be done much better with standard Lisp.  However, the
      <literal>macptr</literal> can be used to pass this chunk of
      memory off to a C function.  Let's use the C code to reverse the
      elements in the array:</para>
      <programlisting><para>
      ? ;; Insert the full path to your copy of libptrtest.dylib
      (open-shared-library &quot;/Users/andrewl/openmcl/openmcl/gtk/libptrtest.dylib&quot;)
      #&lt;SHLIB /Users/andrewl/openmcl/openmcl/gtk/libptrtest.dylib #x639D1E6&gt;</para><para>      ? a
      #(6 4 7)</para><para>      ? ap
      #&lt;A Mac Pointer #x10217C&gt;</para><para>      ? (external-call &quot;_reverse_int_array&quot; :address ap :unsigned-int (length a) :address)
      #&lt;A Mac Pointer #x10217C&gt;</para><para>      ? a
      #(7 4 6)</para><para>      ? ap
      #&lt;A Mac Pointer #x10217C&gt;
    </para></programlisting>
      <para>The array gets passed correctly to the C function,
      <literal>reverse_int_array</literal>.  The C function reverses
      the contents of the array in-place; that is, it doesn't make a
      new array, just keeps the same one and reverses what's in it.
      Finally, the C function passes control back to Clozure CL.  Since
      the allocated array memory has been directly modified, Clozure CL
      reflects those changes directly in the array as well.</para>
      <para>      There is one final bit of housekeeping to deal with.
      Before moving on, the memory needs to be deallocated:</para>
      <programlisting>
      ? (dispose-heap-ivector a ap)
      NIL
    </programlisting>
      <para>The <literal>dispose-heap-ivector</literal> macro actually
      deallocates the ivector, releasing its memory into the heap for
      something else to use.  Both <literal>a</literal> and <literal>ap</literal>
      now have undefined values.</para>
      <para>      When do you call <literal>dispose-heap-ivector</literal>?
      Anytime after you know the ivector will never be used again, but
      no sooner.  If you have a lot of ivectors, say, in a hash table,
      you need to make sure that when whatever you were doing with the
      hash table is done, those ivectors all get freed.  Unless
      there's still something somewhere else which refers to them, of
      course!  Exactly what strategy to take depends on the situation,
      so just try to keep things simple unless you know better.</para>
      <para>      The simplest situation is when you have things set up so
      that a Lisp object &quot;encapsulates&quot; a pointer to foreign data,
      taking care of all the details of using it.  In this case, you
      don't want those two things to have different lifetimes: You
      want to make sure your Lisp object exists as long as the foreign
      data does, and no longer; and you want to make sure the foreign
      data doesn't get deallocated while your Lisp object still refers
      to it.</para>
      <para>      If you're willing to accept a few limitations, you can
      make this easy.  First, you can't let foreign code keep a
      permanent pointer to the memory; it has to always finish what
      it's doing, then return, and not refer to that memory again.
      Second, you can't let any Lisp code that isn't part of your
      encapsulating &quot;wrapper&quot; refer to the pointer directly.  Third,
      nothing, either foreign code or Lisp code, should explicitly
      deallocate the memory.</para>
      <para>      If you can make sure all of these are true, you can at
      least ensure that the foreign pointer is deallocated when the
      encapsulating object is about to become garbage, by using
      Clozure CL's nonstandard &quot;termination&quot; mechanism, which is
      essentially the same as what Java and other languages call
      &quot;finalization&quot;.</para>
      <para>      Termination is a way of asking the garbage collector to
      let you know when it's about to destroy an object which isn't
      used anymore.  Before destroying the object, it calls a function
      which you write, called a terminator.</para>
      <para>      So, you can use termination to find out when a particular
      <literal>macptr</literal> is about to become garbage.  That's
      not quite as helpful as it might seem: It's not exactly the same
      thing as knowing that the block of memory it points to is
      unreferenced.  For example, there could be another
      <literal>macptr</literal> somewhere to the same block; or, if
      it's a struct, there could be a <literal>macptr</literal> to one
      of its fields.  Most problematically, if the address of that
      memory has been passed to foreign code, it's sometimes hard to
      know whether that code has kept the pointer.  Most foreign
      functions don't, but it's not hard to think of
      exceptions.</para>
      <para>You can use code such as this to make all this happen:</para>
      <programlisting><para>
      (defclass wrapper (whatever)
        ((element-type :initarg :element-type)
         (element-count :initarg :element-count)
         (ivector)
         (macptr)))</para><para>      (defmethod initialize-instance ((wrapper wrapper) <literal>&amp;rest</literal> initargs)
        (declare (ignore initargs))
        (call-next-method)
        (ccl:terminate-when-unreachable wrapper)
        (with-slots (ivector macptr element-type element-count) wrapper
          (multiple-value-bind (new-ivector new-macptr)
              (make-heap-ivector element-count element-type)
            (setq ivector new-ivector
                  macptr new-macptr))))</para><para>      (defmethod ccl:terminate ((wrapper wrapper))
        (with-slots (ivector macptr) wrapper
          (when ivector
            (dispose-heap-ivector ivector macptr)
            (setq ivector nil
                  macptr nil))))
    </para></programlisting>
      <para>The <literal>ccl:terminate</literal> method will be called
      on some arbitrary thread sometime (hopefully soon) after the GC
      has decided that there are no strong references to an object
      which has been the argument of a
      <literal>ccl:terminate-when-unreachable</literal> call.</para>
      <para>      If it makes sense to say that the foreign object should
      live as long as there's Lisp code that references it (through
      the encapsulating object) and no longer, this is one way of doing
      that.</para>
      <para>      Now we've covered passing basic types back and forth with
      C, and we've done the same with pointers.  You may think this is
      all...  but we've only done pointers to basic types.  Join us
      next time for pointers... to pointers.</para>
      <section id="acknowledgement_in_tutorial-allocating-foreign-data-on-the-lisp-heap">
        <title>Acknowledgement</title>
        <para>Much of this chapter was generously contributed by
	    Andrew P. Lentvorski Jr.</para>
      </section>
    </section>
    <section id="the-foreign-function-interface-dictionary">
      <title>The Foreign-Function-Interface Dictionary</title>
      <refentry id="r_sharp">
        <indexterm zone="r_sharp"><primary><literal>&quot;#_&quot;</literal></primary></indexterm>
        <refnamediv>
          <refname>&quot;#_&quot;</refname>
          <refpurpose/>
          <refclass>Reader Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>#_</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_r_sharp">
          <title>Description</title>
          <para>Reads a symbol from the current input stream, with *PACKAGE*
	      bound to the &quot;OS&quot; package and with readtable-case preserved.</para>
          <para>Does a lookup on that symbol in <link linkend="the-interface-database">the Clozure CL interface database</link>, signalling an error if no foreign function
	      information can be found for the symbol in any active <link linkend="using-interface-directories">interface directory</link>.</para>
          <para>Notes the foreign function information, including the foreign
	      function's return type, the number and type of the foreign
	      function's required arguments, and an indication of whether or
	      not the function accepts additional arguments (via e.g., the
	      &quot;varargs&quot; mechanism in C).</para>
          <para>	      Defines a macroexpansion function on the symbol, which expand
	      macro calls involving the symbol into EXTERNAL-CALL forms where
	      foreign argument type specifiers for required arguments and the
	      return value specifer are provided from the information in the
	      database.</para>
          <para>Returns the symbol.</para>
          <para>	      The effect of these steps is that it's possible to call
	      foreign functions that take fixed numbers of arguments by simply
	      providing argument values, as in:</para>
          <programlisting>(#_isatty fd)
          (#_read fd buf n)</programlisting>
          <para>and to call foreign functions that take variable numbers of
	      arguments by specifying the types of non-required args, as in:</para>
          <programlisting>(with-cstrs ((format-string &quot;the answer is: %d&quot;))
          (#_printf format-string :int answer))</programlisting>
          <para>You can query whether a given name is defined in the
          interface databases by appending the '?' character to the reader
          macro; for example:</para>
          <programlisting>
          CL-USER&gt; #_?printf
          T
          CL-USER&gt; #_?foo
          NIL
        </programlisting>
        </refsect1>
      </refentry>
      <refentry id="r_sharp_amp">
        <indexterm zone="r_sharp_amp"><primary><literal>&quot;#&amp;&quot;</literal></primary></indexterm>
        <refnamediv>
          <refname>&quot;#&amp;&quot;</refname>
          <refpurpose/>
          <refclass>Reader Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>#&amp;</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_r_sharp_amp">
          <title>Description</title>
          <para>In Clozure CL 1.2 and later, the #&amp; reader macro can be used to
	      access foreign variables; this functionality depends on the presence of
	      &quot;vars.cdb&quot; files in the interface database. The current behavior
	      of the #&amp; reader macro is to:</para>
          <para>	      Read a symbol from the current input stream, with *PACKAGE*
	      bound to the &quot;OS&quot; package and with readtable-case preserved.</para>
          <para>	      Use that symbol's pname to access the Clozure CL interface
	      database, signalling an error if no appropriate foreign variable
	      information can be found with that name in any active interface
	      directory.</para>
          <para>	      Use type information recorded in the database to construct a
	      form which can be used to access the foreign variable, and return
	      that form.</para>
          <para>	      Please note that the set of foreign variables declared in header files
	      may or may not match the set of foreign variables exported from
	      libraries (we're generally talking about C and Unix here ...). When
	      they do match, the form constructed by the #&amp; reader macro manages the
	      details of resolving and tracking changes to the foreign variable's
	      address.</para>
          <para>	      Future extensions (via prefix arguments to the reader macro) may
	      offer additional behavior; it might be convenient (for instance) to be
	      able to access the address of a foreign variable without dereferencing
	      that address.</para>
          <para>	      Foreign variables in C code tend to be platform- and
	      package-specific (the canonical example - &quot;errno&quot; - is typically
	      not a variable when threads are involved. )</para>
          <para>In LinuxPPC, </para>
          <programlisting>? #&amp;stderr</programlisting>
          <para>returns a pointer to the stdio error stream (&quot;stderr&quot; is a
	      macro under OSX/Darwin).</para>
          <para>On both LinuxPPC and DarwinPPC, </para>
          <programlisting>? #&amp;sys_errlist</programlisting>
          <para>returns a pointer to a C array of C error message strings.</para>
          <para>          You can query whether a given name is defined in the
          interface databases by appending the '?' character to the reader
          macro; for example:</para>
          <programlisting>
          CL-USER&gt; #&amp;?sys_errlist
          T
          CL-USER&gt; #&amp;?foo
          NIL
        </programlisting>
        </refsect1>
      </refentry>
      <refentry id="r_sharp_dollar">
        <indexterm zone="r_sharp_dollar"><primary><literal>&quot;#$&quot;</literal></primary></indexterm>
        <refnamediv>
          <refname>&quot;#$&quot;</refname>
          <refpurpose/>
          <refclass>Reader Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>#$</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_r_sharp_dollar">
          <title>Description</title>
          <para>In Clozure CL 0.14.2 and later, the #? reader macro can be used
	      to access foreign constants; this functionality depends on the
	      presence of &quot;constants.cdb&quot; files in the interface
	      database. The current behavior of the #$ reader macro is
	      to:</para>
          <para>	      Read a symbol from the current input stream, with
	      *PACKAGE* bound to the &quot;OS&quot; package and with
	      readtable-case preserved.</para>
          <para>	      Use that symbol's pname to access the Clozure CL interface
	      database, signalling an error if no appropriate foreign constant
	      information can be found with that name in any active interface
	      directory.</para>
          <para>	      Use type information recorded in the database to construct a
	      form which can be used to access the foreign constant, and return
	      that form.</para>
          <para>	      Please note that the set of foreign constants declared in
	      header files may or may not match the set of foreign constants
	      exported from libraries. When they do match, the form
	      constructed by the #$ reader macro manages the details of
	      resolving and tracking changes to the foreign constant's
	      address.</para>
          <para>          You can query whether a given name is defined in the
          interface databases by appending the '?' character to the reader
          macro; for example:</para>
          <programlisting>
          CL-USER&gt; #$?SO_KEEPALIVE
          T
          CL-USER&gt; #$?foo
          NIL
        </programlisting>
        </refsect1>
      </refentry>
      <refentry id="r_sharp_slash">
        <indexterm zone="r_sharp_slash"><primary><literal>&quot;#/&quot;</literal></primary></indexterm>
        <refnamediv>
          <refname>&quot;#/&quot;</refname>
          <refpurpose/>
          <refclass>Reader Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>#/</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_r_sharp_slash">
          <title>Description</title>
          <para>In Clozure CL 1.2 and later, the #/ reader macro can be used to
	      access foreign functions on the Darwin platform. The current
	      behavior of the #/ reader macro is to:</para>
          <para>	      Read a symbol from the current input stream, with
	      *PACKAGE* bound to the &quot;NEXTSTEP-FUNCTIONS&quot; package, with
	      readtable-case preserved, and with any colons included.</para>
          <para>          Do limited sanity-checking on the resulting symbol; for
          example, any name that contains at least one colon is required
          also to end with a colon, to conform to Objective-C
          method-naming conventions.</para>
          <para>          Export the resulting symbol from the &quot;NEXTSTEP-FUNCTIONS&quot;
          package and return it.</para>
          <para>          For example, reading &quot;#/alloc&quot; interns and returns
          NEXTSTEP-FUNCTIONS:|alloc|. Reading &quot;#/initWithFrame:&quot; interns
          and returns NEXTSTEP-FUNCTIONS:|initWithFrame:|.</para>
          <para>          A symbol read using this macro can be used as an operand
          in most places where an Objective-C message name can be used, such as
          in the (OBJ:@SELECTOR ...) construct.</para>
          <para>          Please note: the reader macro is not rigorous about
          enforcing Objective-C method-naming conventions. Despite the
          simple checking done by the reader macro, it may still be
          possible to use it to construct invalid names.</para>
          <para>          The act of interning a new symbol in the
          NEXTSTEP-FUNCTIONS package triggers an interface database lookup
          of Objective-C methods with the corresponding message name.  If any
          such information is found, a special type of dispatching
          function is created and initialized and the new symbol is given
          the newly-created dispatching function as its function
          definition.</para>
          <para>          The dispatching knows how to call declared Objective-C methods
          defined on the message. In many cases, all methods have the same
          foreign type signature, and the dispatching function merely
          passes any arguments that it receives to a function that does an
          Objective-C message send with the indicated foreign argument and return
          types. In other cases, where different Objective-C messages have
          different type signatures, the dispatching function tries to
          choose a function that handles the right type signature based on
          the class of the dispatching function's first argument.</para>
          <para>          If new information about Objective-C methods is introduced
          (e.g., by using additional interface files or as Objective-C
          methods are defined from lisp), the dispatch function is
          reinitialized to recognize newly-introduced foreign type
          signatures.</para>
          <para>          The argument and result coercion that the bridge has
          traditionally supported is supported by the new mechanism (e.g.,
          :&lt;BOOL&gt; arguments can be specified as lisp booleans and :&lt;BOOL&gt;
          results are returned as lisp boolean values, and an argument
          value of NIL is coerced to a null pointer if the corresponding
          argument type is :ID.</para>
          <para>          Some Objective-C methods accept variable numbers of
          arguments; the foreign types of non-required arguments are
          determined by the lisp types of those arguments (e.g., integers
          are passed as integers, floats as floats, pointers as pointers,
          record types by reference.)</para>
          <para>Examples:</para>
          <programlisting><para>
          ;;; #/alloc is a known message.
          ? #'#/alloc
          #&lt;OBJC-DISPATCH-FUNCTION NEXTSTEP-FUNCTIONS:|alloc| #x300040E94EBF&gt;
          ;;; Sadly, #/foo is not ...
          ? #'#/foo
          &gt; Error: Undefined function: NEXTSTEP-FUNCTIONS:|foo|</para><para>          ;;; We can send an &quot;init&quot; message to a newly-allocated instance of
          ;;; &quot;NSObject&quot; by:</para><para>          (send (send ns:ns-object 'alloc) 'init)</para><para>          ;;; or by</para><para>          (#/init (#/alloc ns:ns-object))
        </para></programlisting>
          <para>Objective-C methods that &quot;return&quot; structures return them
          as garbage-collectable pointers when called via dispatch
          functions.  For example, if &quot;my-window&quot; is an NS:NS-WINDOW
          instance, then</para>
          <programlisting>
          (#/frame my-window)
        </programlisting>
          <para>returns a garbage-collectable pointer to a structure that
          describes that window's frame rectangle. This convention means
          that there's no need to use SLET or special structure-returning
          message send syntax; keep in mind, though, that #_malloc,
          #_free, and the GC are all involved in the creation and eventual
          destruction of structure-typed return values. In some programs
          these operations may have an impact on performance.</para>
        </refsect1>
      </refentry>
      <refentry id="r_sharp_gt">
        <indexterm zone="r_sharp_gt"><primary><literal>&quot;#&gt;&quot;</literal></primary></indexterm>
        <refnamediv>
          <refname>&quot;#&gt;&quot;</refname>
          <refpurpose/>
          <refclass>Reader Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>#&gt;</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_r_sharp_gt">
          <title>Description</title>
          <para>In Clozure CL 1.2 and later, the #&gt; reader macro reads
          the following text as a keyword, preserving the case of the
          text. For example:</para>
          <programlisting>
          CL-USER&gt; #&gt;FooBar
          :&lt;F&gt;OO&lt;B&gt;AR
        </programlisting>
          <para>The resulting keyword can be used as the name of foreign
          types, records, and accessors.</para>
        </refsect1>
      </refentry>
      <refentry id="f_close-shared-library">
        <indexterm zone="f_close-shared-library"><primary><literal>CLOSE-SHARED-LIBRARY</literal></primary></indexterm>
        <refnamediv>
          <refname>CLOSE-SHARED-LIBRARY</refname>
          <refpurpose>Stops using a shared library, informing the operating
	      system that it can be unloaded if appropriate.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>close-shared-library library <literal>&amp;key</literal> completely</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_close-shared-library">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>library</parameter></term>
                <listitem><para>either an object of type SHLIB, or a string which
		        designates one by its so-name.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>completely</parameter></term>
                <listitem><para>a boolean.  The default is T.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_close-shared-library">
          <title>Description</title>
          <para>If <parameter>completely</parameter> is T, sets the
	      reference count of <parameter>library</parameter> to 0.  Otherwise,
	      decrements it by 1.  In either case, if the reference count
	      becomes 0, <indexterm><primary><literal>CLOSE-SHARED-LIBRARY</literal></primary></indexterm><link linkend="f_close-shared-library"><literal>CLOSE-SHARED-LIBRARY</literal></link>
	      frees all memory resources consumed <parameter>library</parameter>
	      and
	      causes any EXTERNAL-ENTRY-POINTs known to be defined by it to
	      become unresolved.</para>
        </refsect1>
      </refentry>
      <refentry id="m_defcallback">
        <indexterm zone="m_defcallback"><primary><literal>DEFCALLBACK</literal></primary></indexterm>
        <refnamediv>
          <refname>DEFCALLBACK</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>defcallback name ({arg-type-specifier var}* <literal>&amp;optional</literal> result-type-specifier) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_defcallback">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>A symbol which can be made into a special variable</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg-type-specifer</parameter></term>
                <listitem><para>One of the foreign argument-type keywords,
		        described above, or an equivalent <link linkend="specifying-and-using-foreign-types">foreign type specifier</link>.  In addition, if the keyword
		        :WITHOUT-INTERRUPTS is specified, the callback will be
		        executed with lisp interrupts disabled if the
		        corresponding var is non-NIL. If :WITHOUT-INTERRUPTS
		        is specified more than once, the rightmost instance
		        wins.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>var</parameter></term>
                <listitem><para>A symbol (lisp variable), which will be bound to a
		        value of the specified type.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>A sequence of lisp forms, which should return a value
		        which can be coerced to the specified result-type.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_defcallback">
          <title>Description</title>
          <para>Proclaims <parameter>name</parameter>
	      to be a special variable; sets its value to a
	      MACPTR which, when called by foreign code, calls a lisp function
	      which expects foreign arguments of the specified types and which
	      returns a foreign value of the specified result type. Any argument
	      variables which correspond to foreign arguments of type :ADDRESS
	      are bound to stack-allocated MACPTRs.</para>
          <para>	      If <parameter>name</parameter>
	      is already a callback function pointer, its value is
	      not changed; instead, it's arranged
	      that an
	      updated version of the lisp callback function will be called.
	      This feature allows for callback functions to be redefined
	      incrementally, just like Lisp functions are.</para>
          <para>	      <indexterm><primary><literal>DEFCALLBACK</literal></primary></indexterm><link linkend="m_defcallback"><literal>DEFCALLBACK</literal></link>
	      returns the callback pointer, e.g., the
	      value of <parameter>name</parameter>.</para>
        </refsect1>
      </refentry>
      <refentry id="m_def-foreign-type">
        <indexterm zone="m_def-foreign-type"><primary><literal>DEF-FOREIGN-TYPE</literal></primary></indexterm>
        <refnamediv>
          <refname>DEF-FOREIGN-TYPE</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>def-foreign-type name foreign-type-spec</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_def-foreign-type">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>NIL or a keyword; the keyword may contain
		        <link linkend="case-sensitivity-of-foreign-names-in-clozure-cl">escaping constructs</link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>foreign-type-spec</parameter></term>
                <listitem><para>A foreign type specifier, whose syntax is (loosely)
		        defined above.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_def-foreign-type">
          <title>Description</title>
          <para>If name is non-NIL, defines name to be an alias for the
	      foreign type specified by foreign-type-spec. If foreign-type-spec
	      is a named structure or union type, additionally defines that
	      structure or union type.</para>
          <para>	      If name is NIL, foreign-type-spec must be a named foreign
	      struct or union definition, in which case the foreign structure
	      or
	      union definition is put in effect.</para>
          <para>	      Note that there are two separate namespaces for foreign
	      type names, one for the names of ordinary types and one for
	      the names of structs and unions.  Which one
	      <parameter>name</parameter> refers to depends on
	      <parameter>foreign-type-spec</parameter> in the obvious manner.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="m_external">
        <indexterm zone="m_external"><primary><literal>EXTERNAL</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL</refname>
          <refpurpose>Resolves a reference to an external symbol which
	      is defined in a shared library.</refpurpose>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external name =&gt; entry</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_external">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>
		        a simple-string which names an external symbol.
		        Case-sensitive.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>entry</parameter></term>
                <listitem><para>
		        an object of type EXTERNAL-ENTRY-POINT which maintains
		        the address of the foreign symbol named by
		        <parameter>name</parameter>.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_external">
          <title>Description</title>
          <para>If there is already an EXTERNAL-ENTRY-POINT for
	      the symbol named by <parameter>name</parameter>, finds it and
	      returns it.  If not, creates one and returns it.</para>
          <para>	      Tries to resolve the entry point to a memory address,
	      and identify the containing library.</para>
          <para>	      Be aware that under Darwin, external functions which
	      are callable from C have underscores prepended to their names,
	      as in &quot;_fopen&quot;.</para>
        </refsect1>
      </refentry>
      <refentry id="m_external-call">
        <indexterm zone="m_external-call"><primary><literal>EXTERNAL-CALL</literal></primary></indexterm>
        <refnamediv>
          <refname>EXTERNAL-CALL</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>external-call name {arg-type-specifier arg}* <literal>&amp;optional</literal> result-type-specifier</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_external-call">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>A lisp string. See external, above.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg-type-specifer</parameter></term>
                <listitem><para>One of the foreign argument-type keywords, described
		        above, or an equivalent <link linkend="specifying-and-using-foreign-types">foreign type specifier</link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg</parameter></term>
                <listitem><para>A lisp value of type indicated by the corresponding
		        arg-type-specifier</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result-type-specifier</parameter></term>
                <listitem><para>One of the foreign argument-type keywords, described
		        above, or an equivalent <link linkend="specifying-and-using-foreign-types">foreign type specifier</link>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_external-call">
          <title>Description</title>
          <para>Calls the foreign function at the address obtained by
	      resolving the external-entry-point associated with name, passing
	      the values of each arg as a foreign argument of type indicated by
	      the corresponding arg-type-specifier. Returns the foreign function
	      result (coerced to a Lisp object of type indicated by
	      result-type-specifier), or NIL if result-type-specifer is :VOID or
	      NIL</para>
        </refsect1>
      </refentry>
      <refentry id="f_._ff-call">
        <indexterm zone="f_._ff-call"><primary><literal>%FF-CALL</literal></primary></indexterm>
        <refnamediv>
          <refname>%FF-CALL</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>%ff-call entrypoint {arg-type-keyword arg}* <literal>&amp;optional</literal> result-type-keyword</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_._ff-call">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>entrypoint</parameter></term>
                <listitem><para>A fixnum or MACPTR</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg-type-keyword</parameter></term>
                <listitem><para>One of the foreign argument-type keywords, described
		        above</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg</parameter></term>
                <listitem><para>A lisp value of type indicated by the corresponding
		        arg-type-keyword</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result-type-keyword</parameter></term>
                <listitem><para>One of the foreign argument-type keywords, described
		        above</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_._ff-call">
          <title>Description</title>
          <para>Calls the foreign function at address entrypoint passing the
	      values of each arg as a foreign argument of type indicated by the
	      corresponding arg-type-keyword. Returns the foreign function
	      result (coerced to a Lisp object of type indicated by
	      result-type-keyword), or NIL if result-type-keyword is :VOID or
	      NIL</para>
        </refsect1>
      </refentry>
      <refentry id="m_ff-call">
        <indexterm zone="m_ff-call"><primary><literal>FF-CALL</literal></primary></indexterm>
        <refnamediv>
          <refname>FF-CALL</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>ff-call entrypoint {arg-type-specifier arg}* <literal>&amp;optional</literal> result-type-specifier</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_ff-call">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>entrypoint</parameter></term>
                <listitem><para>A fixnum or MACPTR</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg-type-specifer</parameter></term>
                <listitem><para>One of the foreign argument-type keywords, described
		        above, or an equivalent <link linkend="specifying-and-using-foreign-types">foreign type specifier</link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>arg</parameter></term>
                <listitem><para>A lisp value of type indicated by the corresponding
		        arg-type-specifier</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result-type-specifier</parameter></term>
                <listitem><para>One of the foreign argument-type keywords, described
		        above, or an equivalent <link linkend="specifying-and-using-foreign-types">foreign type specifier</link>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_ff-call">
          <title>Description</title>
          <para>Calls the foreign function at address entrypoint passing the
	      values of each arg as a foreign argument of type indicated by the
	      corresponding arg-type-specifier. Returns the foreign function
	      result (coerced to a Lisp object of type indicated by
	      result-type-specifier), or NIL if result-type-specifer is :VOID or
	      NIL</para>
        </refsect1>
      </refentry>
      <refentry id="f_foreign-symbol-address">
        <indexterm zone="f_foreign-symbol-address"><primary><literal>FOREIGN-SYMBOL-ADDRESS</literal></primary></indexterm>
        <refnamediv>
          <refname>FOREIGN-SYMBOL-ADDRESS</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>foreign-symbol-address name</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_foreign-symbol-address">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>A lisp string.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_foreign-symbol-address">
          <title>Description</title>
          <para>Tries to resolve the address of the foreign symbol
	      name. If successful, returns that address encapsulated in
	      <link linkend="referencing-and-using-foreign-memory-addresses">a MACPTR</link>, else returns NIL.</para>
        </refsect1>
      </refentry>
      <refentry id="f_foreign-symbol-entry">
        <indexterm zone="f_foreign-symbol-entry"><primary><literal>FOREIGN-SYMBOL-ENTRY</literal></primary></indexterm>
        <refnamediv>
          <refname>FOREIGN-SYMBOL-ENTRY</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>foreign-symbol-entry name</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_foreign-symbol-entry">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>A lisp string.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_foreign-symbol-entry">
          <title>Description</title>
          <para>Tries to resolve the address of the foreign symbol name. If
	      successful, returns a fixnum representation of that address, else
	      returns NIL.</para>
        </refsect1>
      </refentry>
      <refentry id="f_free">
        <indexterm zone="f_free"><primary><literal>FREE</literal></primary></indexterm>
        <refnamediv>
          <refname>FREE</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>free ptr</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_free">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>ptr</parameter></term>
                <listitem><para>A <literal>MACPTR</literal> that points to a block of
		      foreign, heap-allocated memory.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_free">
          <title>Description</title>
          <para>In Clozure CL 1.2 and later, the <literal>CCL:FREE</literal>
          function invokes the foreign <literal>free</literal> function from
          the platform's standard C library to deallocate a block of
          foreign memory.</para>
          <para>          Previous versions of Clozure CL implemented this function,
          but it was not exported.</para>
          <para>        If the argument to <literal>CCL:FREE</literal> is a gcable
        pointer (for example, an object returned
        by <literal>MAKE-GCABLE-RECORD</literal>)
        then <literal>CCL:FREE</literal> informs the garbage collector that
        the foreign memory has been deallocated before calling the
        foreign <literal>free</literal> function.</para>
        </refsect1>
      </refentry>
      <refentry id="f_make-heap-ivector">
        <indexterm zone="f_make-heap-ivector"><primary><literal>MAKE-HEAP-IVECTOR</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-HEAP-IVECTOR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-heap-ivector element-count element-type =&gt; vector macptr size</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_make-heap-ivector">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>element-count</parameter></term>
                <listitem><para>A positive integer.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>element-type</parameter></term>
                <listitem><para>A type specifier.</para><para>		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>vector</parameter></term>
                <listitem><para>A lisp vector.  The initial contents are
		      undefined.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>mactpr</parameter></term>
                <listitem><para>A pointer to the first byte of data stored
		      in the vector.
		      </para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>size</parameter></term>
                <listitem><para>The size of the returned vector in octets.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-heap-ivector">
          <title>Description</title>
          <para>
	An &quot;ivector&quot; is a one-dimensional array that's specialized to
	a numeric or character element type.</para>
          <para>	  <literal>MAKE-HEAP-IVECTOR</literal> allocates an ivector in
	  foreign memory.  The GC will never move this vector, and
	  will in fact not pay any attention to it at all.  The
	  returned pointer to it can therefore be passed safely to
	  foreign code.</para>
          <para>	  The vector must be explicitly deallocated with
	  <literal>DISPOSE-HEAP-IVECTOR</literal>.
	</para>
        </refsect1>
      </refentry>
      <refentry id="m_make-gcable-record">
        <indexterm zone="m_make-gcable-record"><primary><literal>CCL::MAKE-GCABLE-RECORD</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::MAKE-GCABLE-RECORD</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-gcable-record typespec <literal>&amp;rest</literal> initforms =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_make-gcable-record">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>typespec</parameter></term>
                <listitem><para>A foreign type specifier, or a keyword which is used
		        as the name of a foreign struct or union.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initforms</parameter></term>
                <listitem><para>If the type denoted by <parameter>typespec</parameter>
		        is scalar, a single value appropriate for that type;
		        otherwise, a list of alternating field names and
		        values appropriate for the types of those fields.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>
		        A <indexterm><primary><literal>MACPTR</literal></primary></indexterm><literal>MACPTR</literal> which encapsulates the address of a
		        newly-allocated record on the foreign heap. The foreign
		        object returned by <indexterm><primary><literal>CCL::MAKE-GCABLE-RECORD</literal></primary></indexterm><link linkend="m_make-gcable-record"><literal>CCL::MAKE-GCABLE-RECORD</literal></link>
		        is freed when the garbage collector determines that
		        the <literal>MACPTR</literal> object that describes it is
		        unreachable.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_make-gcable-record">
          <title>Description</title>
          <para>
	      Allocates a block of foreign memory suitable to hold the foreign
	      type described by <literal>typespec</literal>, in the same manner
	      as <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link>. In
	      addition, <literal>MAKE-GCABLE-RECORD</literal> marks the
	      returned object gcable; in other words, it informs the garbage
	      collector that it may reclaim the object when it becomes
	      unreachable.
	    </para>
          <para>In all other respects, <literal>MAKE-GCABLE-RECORD</literal> works
          the same way
          as <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link></para>
          <para> When using gcable pointers, it's important to remember the
          distinction between a <literal>MACPTR</literal> object (which is a
          lisp object, more or less like any other) and the block of
          foreign memory that the <literal>MACPTR</literal> object points to.
          If a gcable <literal>MACPTR</literal> object is the only thing in the
          world (lisp world or foreign world) that references the
          underlying block of foreign memory, then freeing the foreign
          memory when it becomes impossible to reference it is convenient
          and sane.  If other lisp <literal>MACPTR</literal>s reference the
          underlying block of foreign memory or if the address of that
          foreign memory is passed to and retained by foreign code, having
          the GC free the memory may have unpleasant consequences if those
          other references are used.</para>
          <para>          Take care, therefore, not to create a gcable record unless
          you are sure that the returned <literal>MACPTR</literal> will be the
          only reference to the allocated memory that will ever be
          used.</para>
        </refsect1>
      </refentry>
      <refentry id="m_make-record">
        <indexterm zone="m_make-record"><primary><literal>MAKE-RECORD</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-RECORD</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-record typespec <literal>&amp;rest</literal> initforms =&gt; result</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_make-record">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>typespec</parameter></term>
                <listitem><para>A foreign type specifier, or a keyword which is used
		        as the name of a foreign struct or union.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initforms</parameter></term>
                <listitem><para>If the type denoted by <parameter>typespec</parameter>
		        is scalar, a single value appropriate for that type;
		        otherwise, a list of alternating field names and
		        values appropriate for the types of those fields.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>result</parameter></term>
                <listitem><para>
		        A <indexterm><primary><literal>MACPTR</literal></primary></indexterm><literal>MACPTR</literal> which encapsulates the address of a
		        newly-allocated record on the foreign heap.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_make-record">
          <title>Description</title>
          <para>
	      Expands into code which allocates and initializes
	      an instance of the type 
	      denoted by <parameter>typespec</parameter>, on the foreign
	      heap.  The record is allocated using the C function
	      <indexterm><primary><literal>CCL::MALLOC</literal></primary></indexterm><literal>CCL::MALLOC</literal>, and the user of
	      <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link> must explicitly call
	      the function <indexterm><primary><literal>FREE</literal></primary></indexterm><link linkend="f_free"><literal>FREE</literal></link> to deallocate the
	      record, when it is no longer needed.</para>
          <para>	      If <parameter>initforms</parameter> is provided, its value
	      or values are used in the initialization.  When the type
	      is a scalar, <parameter>initforms</parameter> is either a single
	      value which can be coerced to that type, or no value, in which
	      case binary 0 is used.  When the type is a <literal>struct</literal>,
	      <parameter>initforms</parameter> is a list, giving field names
	      and the values for each.  Each field is treated in the same way
	      as a scalar is: If a value for it is given, it must be
	      coerceable to the field's type; if not, binary 0 is used.</para>
          <para>	      When the type is an array, <parameter>initforms</parameter> may
	      not be provided, because <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link>
	      cannot initialize its values.  <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link>
	      is also unable to initialize fields of a <literal>struct</literal>
	      which are themselves
	      <literal>struct</literal>s.  The user of
	      <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link> should set these values
	      by another means.</para>
          <para>	      A possibly-significant limitation is that it must be possible to
	      find the foreign type at the time the macro is expanded;
	      <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link> signals an error if this is
	      not the case.
	    </para>
        </refsect1>
        <refsect1 id="notes_in_m_make-record">
          <title>Notes</title>
          <para>
	      It is inconvenient that <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link> is a
	      macro, because this means that <parameter>typespec</parameter>
	      cannot be a variable; it must be an immediate value.</para>
          <para>	      If it weren't for this requirement,
	      <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link> could be a function.  However,
	      that would mean that any stand-alone application using it would
	      have to include a copy of the interface database
	      (see <xref linkend="the-interface-database"/>), which is undesirable
	      because it's large.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_open-shared-library">
        <indexterm zone="f_open-shared-library"><primary><literal>OPEN-SHARED-LIBRARY</literal></primary></indexterm>
        <refnamediv>
          <refname>OPEN-SHARED-LIBRARY</refname>
          <refpurpose>Asks the operating system to load a shared library
	      for Clozure CL to use.</refpurpose>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>open-shared-library name =&gt; library</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_open-shared-library">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>A SIMPLE-STRING which is presumed to be the so-name of
		        or a filesystem path to the library.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>library</parameter></term>
                <listitem><para>An object of type SHLIB which describes the
		        library denoted by <parameter>name</parameter>.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_open-shared-library">
          <title>Description</title>
          <para>If the library denoted by <parameter>name</parameter> can
	      be loaded by the
	      operating system, returns an object of type SHLIB that describes
	      the library; if the library is already open, increments a
	      reference count. If the library can't be loaded, signals a
	      SIMPLE-ERROR which contains an often-cryptic message from the
	      operating system.</para>
        </refsect1>
        <refsect1 id="examples_in_f_open-shared-library">
          <title>Examples</title>
          <programlisting><para>;;; Try to do something simple.
          ? (open-shared-library &quot;libgtk.so&quot;)
          &gt; Error: Error opening shared library &quot;libgtk.so&quot;: /usr/lib/libgtk.so: undefined symbol: gdk_threads_mutex
          &gt; While executing: OPEN-SHARED-LIBRARY</para><para>          ;;; Grovel around, curse, and try to find out where &quot;gdk_threads_mutex&quot;
          ;;; might be defined. Then try again:</para><para>          ? (open-shared-library &quot;libgdk.so&quot;)
          #&lt;SHLIB libgdk.so #x3046DBB6&gt;</para><para>          ? (open-shared-library &quot;libgtk.so&quot;)
          #&lt;SHLIB libgtk.so #x3046DC86&gt;</para><para>          ;;; Reference an external symbol defined in one of those libraries.</para><para>          ? (external &quot;gtk_main&quot;)
          #&lt;EXTERNAL-ENTRY-POINT &quot;gtk_main&quot; (#x012C3004) libgtk.so #x3046FE46&gt;</para><para>          ;;; Close those libraries.</para><para>          ? (close-shared-library &quot;libgtk.so&quot;)
          T</para><para>          ? (close-shared-library &quot;libgdk.so&quot;)
          T</para><para>          ;;; Reference the external symbol again.</para><para>          ? (external &quot;gtk_main&quot;)
          #&lt;EXTERNAL-ENTRY-POINT &quot;gtk_main&quot; {unresolved} libgtk.so #x3046FE46&gt;</para></programlisting>
        </refsect1>
        <refsect1 id="notes_in_f_open-shared-library">
          <title>Notes</title>
          <para>It would be helpful to describe what an soname is and give
	      examples of one.</para>
          <para>	      Does the SHLIB still get returned if the library is
	      already open?</para>
        </refsect1>
      </refentry>
      <refentry id="m_pref">
        <indexterm zone="m_pref"><primary><literal>PREF</literal></primary></indexterm>
        <refnamediv>
          <refname>PREF</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>pref ptr accessor-form</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_pref">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>ptr</parameter></term>
                <listitem><para><link linkend="referencing-and-using-foreign-memory-addresses">a MACPTR</link>.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>accessor-form</parameter></term>
                <listitem><para>a keyword which names a foreign type or record, as
		        described in <xref linkend="foreign-type-record-and-field-names"/>.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_pref">
          <title>Description</title>
          <para>References an instance of a foreign type (or a component of
	      a foreign type) accessible via ptr.</para>
          <para>	      Expands into code which references the indicated scalar type
	      or component, or returns a pointer to a composite type.</para>
          <para>PREF can be used with SETF.</para>
          <para>	      RREF is a deprecated alternative to PREF. It accepts a
	      :STORAGE keyword and rather loudly ignores it.</para>
        </refsect1>
      </refentry>
      <refentry id="f_._reference-external-entry-point">
        <indexterm zone="f_._reference-external-entry-point"><primary><literal>%REFERENCE-EXTERNAL-ENTRY-POINT</literal></primary></indexterm>
        <refnamediv>
          <refname>%REFERENCE-EXTERNAL-ENTRY-POINT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>%reference-external-entry-point eep</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_._reference-external-entry-point">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>eep</parameter></term>
                <listitem><para>An EXTERNAL-ENTRY-POINT, as obtained by the EXTERNAL
		        macro.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_._reference-external-entry-point">
          <title>Description</title>
          <para>Tries to resolve the address of the EXTERNAL-ENTRY-POINT
	      eep; returns a fixnum representation of that address if
	      successful, else signals an error.</para>
        </refsect1>
      </refentry>
      <refentry id="m_rlet">
        <indexterm zone="m_rlet"><primary><literal>RLET</literal></primary></indexterm>
        <refnamediv>
          <refname>RLET</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>rlet (var typespec <literal>&amp;rest</literal> initforms)* <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_rlet">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>var</parameter></term>
                <listitem><para>A symbol (a lisp variable)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>typespec</parameter></term>
                <listitem><para>A foreign type specifier or foreign record name.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initforms</parameter></term>
                <listitem><para>As described above, for
		        <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link></para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_rlet">
          <title>Description</title>
          <para>Executes <parameter>body</parameter>
	      in an environment in which each var is bound
	      to <link linkend="referencing-and-using-foreign-memory-addresses">a MACPTR</link> encapsulating the
	      address of a stack-allocated foreign memory block, allocated and
	      initialized from typespec and initforms as per
	      <indexterm><primary><literal>MAKE-RECORD</literal></primary></indexterm><link linkend="m_make-record"><literal>MAKE-RECORD</literal></link>.
	      Returns whatever value(s) <parameter>body</parameter>
	      returns.</para>
          <para>Record fields that aren't explicitly initialized have
	      unspecified contents.</para>
        </refsect1>
      </refentry>
      <refentry id="m_rletz">
        <indexterm zone="m_rletz"><primary><literal>RLETZ</literal></primary></indexterm>
        <refnamediv>
          <refname>RLETZ</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>rletz (var typespec <literal>&amp;rest</literal> initforms)* <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_m_rletz">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>var</parameter></term>
                <listitem><para>A symbol (a lisp variable)</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>typespec</parameter></term>
                <listitem><para>A foreign type specifier or foreign record name.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initforms</parameter></term>
                <listitem><para>As described above, for ccl:make-record</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_rletz">
          <title>Description</title>
          <para>Executes body in an environment in which each var is
	      bound to <link linkend="referencing-and-using-foreign-memory-addresses">a MACPTR</link> encapsulating the address of a stack-allocated
	      foreign memory block, allocated and initialized from
	      typespec and initforms as ccl:make-record.</para>
          <para>Returns whatever value(s) body returns.</para>
          <para>	      Unlike rlet, record fields that aren't explicitly
	      initialized are set to binary 0.</para>
        </refsect1>
      </refentry>
      <refentry id="f_terminate-when-unreachable">
        <indexterm zone="f_terminate-when-unreachable"><primary><literal>TERMINATE-WHEN-UNREACHABLE</literal></primary></indexterm>
        <refnamediv>
          <refname>TERMINATE-WHEN-UNREACHABLE</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>terminate-when-unreachable object</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_terminate-when-unreachable">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>object</parameter></term>
                <listitem><para>A CLOS object of a class for which there exists
		        a method of the generic function
		        <indexterm><primary><literal>TERMINATE</literal></primary></indexterm><literal>TERMINATE</literal>.
		      </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_terminate-when-unreachable">
          <title>Description</title>
          <para>
	      The &quot;termination&quot; mechanism is a way to have the garbage
	      collector run a function right before an object is about to
	      become garbage.  It is very similar to the &quot;finalization&quot;
	      mechanism which Java has.  It is not standard Common Lisp,
	      although other Lisp implementations have similar features.
	      It is useful when there is some sort of special cleanup,
	      deallocation, or releasing of resources which needs to happen
	      when a certain object is no longer being used.</para>
          <para>	      When the garbage collector discovers that an object is no
	      longer referred to anywhere in the program, it deallocates
	      that object, freeing its memory.  However, if
	      <indexterm><primary><literal>TERMINATE-WHEN-UNREACHABLE</literal></primary></indexterm><link linkend="f_terminate-when-unreachable"><literal>TERMINATE-WHEN-UNREACHABLE</literal></link> has been
	      called on the object at any time, the garbage collector first
	      invokes the generic function <indexterm><primary><literal>TERMINATE</literal></primary></indexterm><literal>TERMINATE</literal>,
	      passing it the object as a parameter.</para>
          <para>	      Therefore, to make termination do something useful, you need to
	      define a method on <indexterm><primary><literal>TERMINATE</literal></primary></indexterm><literal>TERMINATE</literal>.</para>
          <para>	      Because calling
	      <indexterm><primary><literal>TERMINATE-WHEN-UNREACHABLE</literal></primary></indexterm><link linkend="f_terminate-when-unreachable"><literal>TERMINATE-WHEN-UNREACHABLE</literal></link> only
	      affects a single object, rather than all objects of its
	      class, you
	      may wish to put a call to it in the
	      <indexterm><primary><literal>INITIALIZE-INSTANCE</literal></primary></indexterm><literal>INITIALIZE-INSTANCE</literal> method of a
	      class.  Of course, this is only appropriate if you do in fact
	      want to use termination for all objects of a given class.
	    </para>
        </refsect1>
        <refsect1 id="example_in_f_terminate-when-unreachable">
          <title>Example</title>
          <programlisting><para>
          (defclass resource-wrapper ()
            ((resource :accessor resource)))</para><para>          (defmethod initialize-instance :after ((x resource-wrapper) &amp;rest initargs)
             (ccl:terminate-when-unreachable x))</para><para>          (defmethod ccl:terminate ((x resource-wrapper))
             (when (resource x)
                (deallocate (resource x))))</para></programlisting>
        </refsect1>
        <refsect1 id="see-also_in_f_terminate-when-unreachable">
          <title>See Also</title>
          <para><xref linkend="tutorial-allocating-foreign-data-on-the-lisp-heap"/></para>
        </refsect1>
      </refentry>
      <refentry id="f_unuse-interface-dir">
        <indexterm zone="f_unuse-interface-dir"><primary><literal>UNUSE-INTERFACE-DIR</literal></primary></indexterm>
        <refnamediv>
          <refname>UNUSE-INTERFACE-DIR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>unuse-interface-dir dir-id</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_unuse-interface-dir">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>dir-id</parameter></term>
                <listitem><para>A keyword whose pname, mapped to lower case, names a
		        subdirectory of &quot;ccl:headers;&quot; (or
		        &quot;ccl:darwin-headers;&quot;)</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_unuse-interface-dir">
          <title>Description</title>
          <para>Tells Clozure CL to remove the interface directory denoted by
	      dir-id from the list of interface directories which are
	      consulted for
	      foreign type and function information. Returns T if the directory
	      was on the search list, NIL otherwise.</para>
        </refsect1>
      </refentry>
      <refentry id="f_use-interface-dir">
        <indexterm zone="f_use-interface-dir"><primary><literal>USE-INTERFACE-DIR</literal></primary></indexterm>
        <refnamediv>
          <refname>USE-INTERFACE-DIR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>use-interface-dir dir-id</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_use-interface-dir">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>dir-id</parameter></term>
                <listitem><para>A keyword whose pname, mapped to lower case, names a
		        subdirectory of &quot;ccl:headers;&quot; (or
		        &quot;ccl:darwin-headers;&quot;)</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_use-interface-dir">
          <title>Description</title>
          <para>Tells Clozure CL to add the interface directory denoted by
	      dir-id to the list of interface directories which it consults for
	      foreign type and function information. Arranges that that
	      directory is searched before any others.</para>
          <para>Note that <indexterm><primary><literal>USE-INTERFACE-DIR</literal></primary></indexterm><link linkend="f_use-interface-dir"><literal>USE-INTERFACE-DIR</literal></link>
	      merely adds an entry
	      to a search list.
	      If the named directory doesn't exist in the file system
	      or doesn't
	      contain a set of database files, a runtime error may occur
	      when Clozure CL
	      tries to open some database file in that directory, and it
	      will try to
	      open such a database file whenever it needs to find any
	      foreign type or
	      function information. <indexterm><primary><literal>UNUSE-INTERFACE-DIR</literal></primary></indexterm><link linkend="f_unuse-interface-dir"><literal>UNUSE-INTERFACE-DIR</literal></link>
	      may come in
	      handy in that case.</para>
        </refsect1>
        <refsect1 id="examples_in_f_use-interface-dir">
          <title>Examples</title>
          <para>One typically wants interface information to be
	      available at compile-time (or, in many cases, at read-time).
	      A typical idiom would be:</para>
          <programlisting>(eval-when (:compile-toplevel :execute)
          (use-interface-dir :GTK))</programlisting>
          <para>Using the :GTK interface directory makes available
	      information on
	      foreign types, functions, and constants.  It's generally
	      necessary to
	      load foreign libraries before actually calling the
	      foreign code, which for GTK can be done like this:</para>
          <programlisting>(load-gtk-libraries)</programlisting>
          <para>It should now be possible to do things like:</para>
          <programlisting>(#_gtk_widget_destroy w)</programlisting>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="the-objective-c-bridge">
    <title>The Objective-C Bridge</title>
    <para>Mac OS X APIs use a language called Objective-C, which is
    approximately C with some object-oriented extensions modeled on
    Smalltalk.  The Objective-C bridge makes it possible to work with
    Objective-C objects and classes from Lisp, and to define classes
    in Lisp which can be used by Objective-C.</para>
    <para>    The ultimate purpose of the Objective-C and Cocoa bridges is
    to make Cocoa (the standard user-interface framework on Mac OS X)
    as easy as possible to use from Clozure CL, in order to support the
    development of GUI applications and IDEs on Mac OS X (and on any
    platform that supports Objective-C, such as GNUStep).  The
    eventual goal, which is much closer than it used to be, is
    complete integration of Cocoa into CLOS.</para>
    <para>    The current release provides Lisp-like syntax and naming
    conventions for the basic Objective-C operations, with automatic type
    processing and messages checked for validity at compile-time.  It
    also provides some convenience facilities for working with
    Cocoa.</para>
    <section id="changes-in-1.2">
      <title>Changes in 1.2</title>
      <para>Version 1.2 of Clozure CL exports most of the useful symbols
    described in this chapter; in previous releases, most of them were
    private in the <literal>CCL</literal> package.</para>
      <para>There are several new reader macros that make it much more
    convenient than before to refer to several classes of symbols used
    with the Objective-C bridge. For a full description of these
    reader-macros, see
    the <link linkend="the-foreign-function-interface-dictionary">Foreign-Function-Interface Dictionary</link>, especially the entries at the beginning,
    describing reader macros.</para>
      <para>As in previous releases, 32-bit versions of Clozure CL use 32-bit
    floats and integers in data structures that describe geometry,
    font sizes and metrics, and so on. 64-bit versions of Clozure CL use
    64-bit values where appropriate.</para>
      <para>      The Objective-C bridge defines the
      type <literal>NS:CGFLOAT</literal> as the Lisp type of the preferred
      floating-point type on the current platform, and defines the
      constant <literal>NS:+CGFLOAT+</literal>.  On DarwinPPC32, the foreign
      types <literal>:cgfloat</literal>, <literal>:&lt;NSUI&gt;nteger</literal>,
      and
      <literal>:&lt;NSI&gt;nteger</literal> are defined by the Objective-C
      bridge (as 32-bit float, 32-bit unsigned integer, and 32-bit
      signed integer, respectively); these types are defined as 64-bit
      variants in the 64-bit interfaces.</para>
      <para>Every Objective-C class is now properly named, either with a
      name exported from the <literal>NS</literal> package (in the case of a
      predefined class declared in the interface files) or with the
      name provided in the <literal>DEFCLASS</literal> form (with <literal>:METACLASS</literal><literal>NS:+NS-OBJECT</literal>) which defines the class from Lisp.
      The class's Lisp name is now proclaimed to be a &quot;static&quot;
      variable (as if by <literal>DEFSTATIC</literal>, as described in the
      <link linkend="static-variables">&quot;Static Variables&quot; section</link>) and given the class object as its value.  In
      other words:</para>
      <programlisting>
(send (find-class 'ns:ns-application) 'shared-application)
    </programlisting>
      <para>and</para>
      <programlisting>
(send ns:ns-application 'shared-application)
    </programlisting>
      <para>are equivalent.  (Since it's not legal to bind a &quot;static&quot;
  variable, it may be necessary to rename some things so that
  unrelated variables whose names coincidentally conflict with
  Objective-C class names don't do so.)</para>
    </section>
    <section id="using-objective-c-classes">
      <title>Using Objective-C Classes</title>
      <para>The class of most standard CLOS classes is named
      STANDARD-CLASS. In the Objective-C object model, each class is
      an instance of a (usually unique) metaclass, which is itself an
      instance of a &quot;base&quot; metaclass (often the metaclass of the class
      named &quot;NSObject&quot;.) So, the Objective-C class named &quot;NSWindow&quot;
      and the Objective-C class &quot;NSArray&quot; are (sole) instances of
      their distinct metaclasses whose names are also &quot;NSWindow&quot; and
      &quot;NSArray&quot;, respectively. (In the Objective-C world, it's much
      more common and useful to specialize class behavior such as
      instance allocation.)</para>
      <para>      When Clozure CL first loads foreign libraries containing
      Objective-C classes, it identifies the classes they contain. The
      foreign class name, such as &quot;NSWindow&quot;, is mapped to an external
      symbol in the &quot;NS&quot; package via the bridge's translation rules,
      such as NS:NS-WINDOW.  A similar transformation happens to the
      metaclass name, with a &quot;+&quot; prepended, yielding something like
      NS:+NS-WINDOW.</para>
      <para>      These classes are integrated into CLOS such that the
      metaclass is an instance of the class OBJC:OBJC-METACLASS and
      the class
      is an instance of the metaclass. SLOT-DESCRIPTION metaobjects are
      created for each instance variable, and the class and metaclass go
      through something very similar to the &quot;standard&quot; CLOS class
      initialization protocol (with a difference being that these classes
      have already been allocated.)</para>
      <para>      Performing all this initialization, which is done when you
      (require &quot;COCOA&quot;), currently takes several
      seconds; it could conceivably be sped up some, but it's never likely
      to be fast.</para>
      <para>      When the process is complete, CLOS is aware of several hundred
      new Objective-C classes and their metaclasses. Clozure CL's runtime system can
      reliably recognize MACPTRs to Objective-C classes as being CLASS objects, and
      can (fairly reliably but heuristically) recognize instances of those
      classes (though there are complicating factors here; see below.)
      SLOT-VALUE can be used to access (and, with care, set) instance
      variables in Objective-C instances. To see this, do:</para>
      <programlisting>
      ? (require &quot;COCOA&quot;)
    </programlisting>
      <para>and, after waiting a bit longer for a Cocoa listener window to
      appear, activate that Cocoa listener and do:</para>
      <programlisting>? (describe (ccl::send ccl::*NSApp* 'key-window))
    </programlisting>
      <para>This sends a message asking for the key window, which is the window
      that has the input focus (often the frontmost), and then describes
      it. As we can see, NS:NS-WINDOWs have lots of interesting slots.</para>
    </section>
    <section id="instantiating-objective-c-objects">
      <title>Instantiating Objective-C Objects</title>
      <para>Making an instance of an Objective-C class (whether the class in
      question is predefined or defined by the application) involves
      calling MAKE-INSTANCE with the class and a set of initargs as
      arguments.  As with STANDARD-CLASS, making an instance involves
      initializing (with INITIALIZE-INSTANCE) an object allocated with
      ALLOCATE-INSTANCE.</para>
      <para>For example, you can create an ns:ns-number like this:</para>
      <programlisting>
      ? (make-instance 'ns:ns-number :init-with-int 42)
      #&lt;NS-CF-NUMBER 42 (#x85962210)&gt;
    </programlisting>
      <para>It's worth looking at how this would be done if you were
      writing in Objective C:</para>
      <programlisting>
      [[NSNumber alloc] initWithInt: 42]
    </programlisting>
      <para>Allocating an instance of an Objective-C class involves sending the
      class an &quot;alloc&quot; message, and then using those initargs that
      <emphasis>don't</emphasis> correspond to slot initargs as the
      &quot;init&quot; message to be sent to the newly-allocated instance.  So, the
      example above could have been done more verbosely as:</para>
      <programlisting><para>
      ? (defvar *n* (ccl::send (find-class 'ns:ns-number) 'alloc))
      *N*</para><para>      ? (setq *n* (ccl::send *n* :init-with-int 42))
      #&lt;NS-CF-NUMBER 42 (#x16D340)&gt;
    </para></programlisting>
      <para>That setq is important; this is a case where init
      decides to replace the object and return the new one, instead
      of modifying the existing one.
      In fact, if you leave out the setq and
      then try to view the value of *N*, Clozure CL will freeze.  There's
      little reason to ever do it this way; this is just to show
      what's going on.</para>
      <para>      You've seen that an Objective-C initialization method doesn't have to
      return the same object it was passed.  In fact, it doesn't have
      to return any object at all; in this case, the initialization fails
      and make-instance returns nil.</para>
      <para>      In some special cases, such as loading an ns:ns-window-controller
      from a .nib file, it may be necessary for you to pass the
      instance itself as one of the parameters to the initialization
      method.  It goes like this:</para>
      <programlisting><para>
      ? (defvar *controller*
      (make-instance 'ns:ns-window-controller))
      *CONTROLLER*</para><para>      ? (setq *controller*
      (ccl::send *controller*
      :init-with-window-nib-name #@&quot;DataWindow&quot;
      :owner *controller*))
      #&lt;NS-WINDOW-CONTROLLER &lt;NSWindowController: 0x1fb520&gt; (#x1FB520)&gt;
    </para></programlisting>
      <para>This example calls (make-instance) with no initargs.  When you
      do this, the object is only allocated, and not initialized.  It
      then sends the &quot;init&quot; message to do the initialization by hand.</para>
      <para>      There is an alternative API for instantiating Objective-C
      classes. You can
      call <literal>OBJC:MAKE-OBJC-INSTANCE</literal>, passing it the
      name of the Objective-C class as a string. In previous
      releases, <literal>OBJC:MAKE-OBJC-INSTANCE</literal> could be
      more efficient than <literal>OBJC:MAKE-INSTANCE</literal> in
      cases where the class did not define any Lisp slots; this is no
      longer the case. You can now
      regard <literal>OBJC:MAKE-OBJC-INSTANCE</literal> as completely
      equivalent to <literal>OBJC:MAKE-INSTANCE</literal>, except that
      you can pass a string for the classname, which may be convenient
      in the case that the classname is in some way unusual.</para>
    </section>
    <section id="calling-objective-c-methods">
      <title>Calling Objective-C Methods</title>
      <para>In Objective-C, methods are called &quot;messages&quot;, and there's
      a special syntax to send a message to an object:</para>
      <programlisting>
      [w alphaValue]
      [w setAlphaValue: 0.5]
      [v mouse: p inRect: r]
    </programlisting>
      <para>The first line sends the method &quot;alphaValue&quot; to the object
      <literal>w</literal>, with no parameters.  The second line sends
      the method &quot;setAlphaValue&quot;, with the parameter 0.5.  The third
      line sends the method &quot;mouse:inRect:&quot; - yes, all one long word -
      with the parameters <literal>p</literal> and
      <literal>r</literal>.</para>
      <para>In Lisp, these same three lines are:</para>
      <programlisting>
      (send w 'alpha-value)
      (send w :set-alpha-value 0.5)
      (send v :mouse p :in-rect r)
    </programlisting>
      <para>Notice that when a method has no parameters, its name is an ordinary
      symbol (it doesn't matter what package the symbol is in, as
      only its name is checked).  When a method has parameters,
      each part of its name is a keyword, and the keywords alternate
      with the values.</para>
      <para>      These two lines break those rules, and both  will
      result in error messages:</para>
      <programlisting>
      (send w :alpha-value)
      (send w 'set-alpha-value 0.5)
    </programlisting>
      <para>Instead of (send), you can also invoke (send-super), with the
      same interface.  It has roughly the same purpose as CLOS's
      (call-next-method); when you use (send-super), the message is
      handled by the superclass.  This can be used to get at the
      original implementation of a method when it is shadowed by a
      method in your subclass.</para>
      <section id="type-coercion-for-objective-c-method-calls">
        <title>Type Coercion for Objective-C Method Calls</title>
        <para>Clozure CL's FFI handles many common conversions between
        Lisp and foreign data, such as unboxing floating-point args
        and boxing floating-point results.  The bridge adds a few more
        automatic conversions:</para>
        <para>        NIL is equivalent to (%NULL-PTR) for any message
        argument that requires a pointer.</para>
        <para>T/NIL are equivalent to #$YES/#$NO for any boolean argument.</para>
        <para>        A #$YES/#$NO returned by any method that returns BOOL
        will be automatically converted to T/NIL.</para>
      </section>
      <section id="methods-which-return-structures">
        <title>Methods which Return Structures</title>
        <para>Some Cocoa methods return small structures, such as
        those used to represent points, rects, sizes and ranges. When
        writing in Objective C, the compiler hides the implementation
        details.  Unfortunately, in Lisp we must be slightly more
        aware of them.</para>
        <para>        Methods which return structures are called in a special
        way; the caller allocates space for the result, and passes a
        pointer to it as an extra argument to the method.  This is
        called a Structure Return, or STRET.  Don't look at me; I
        don't name these things.</para>
        <para>	    Here's a simple use of this in Objective C.  The first line
	    sends the &quot;bounds&quot; message to v1, which returns a rectangle.
	    The second line sends the &quot;setBounds&quot; message to v2, passing
	    that same rectangle as a parameter.</para>
        <programlisting>
        NSRect r = [v1 bounds];
        [v2 setBounds r];
	  </programlisting>
        <para>In Lisp, we must explicitly allocate the memory, which
        is done most easily and safely with <indexterm><primary><literal>RLET</literal></primary></indexterm><link linkend="m_rlet"><literal>RLET</literal></link>.
        We do it like this:</para>
        <programlisting>
(rlet ((r :&lt;NSR&gt;ect))
          (send/stret r v1 'bounds)
          (send v2 :set-bounds r))
      </programlisting>
        <para>The rlet allocates the storage (but doesn't initialize
        it), and makes sure that it will be deallocated when we're
        done.  It binds the variable r to refer to it.  The call to
        <literal>send/stret</literal> is just like an ordinary call to
        <literal>send</literal>, except that r is passed as an extra,
        first parameter.  The third line, which calls
        <literal>send</literal>, does not need to do anything special,
        because there's nothing complicated about passing a structure
        as a parameter.</para>
        <para>	    In order to make STRETs easier to use, the bridge
	    provides two conveniences.</para>
        <para>        First, you can use the macros <literal>slet</literal>
        and <literal>slet*</literal> to allocate and initialize local
        variables to foreign structures in one step.  The example
        above could have been written more tersely as:</para>
        <programlisting>
(slet ((r (send v1 'bounds)))
      (send v2 :set-bounds r))
	  </programlisting>
        <para>Second, when one call to <literal>send</literal> is made
        inside another, the inner one has an implicit
        <literal>slet</literal> around it.  So, one could in fact
        just write:</para>
        <programlisting>
(send v1 :set-bounds (send v2 'bounds))
      </programlisting>
        <para>There are also several pseudo-functions provided for convenience
        by the Objective-C compiler, to make objects of specific types. The
        following are currently supported by the bridge: NS-MAKE-POINT,
        NS-MAKE-RANGE, NS-MAKE-RECT, and NS-MAKE-SIZE.</para>
        <para>These pseudo-functions can be used within an SLET initform:</para>
        <programlisting>
(slet ((p (ns-make-point 100.0 200.0)))
      (send w :set-frame-origin p))
      </programlisting>
        <para>Or within a call to <literal>send</literal>:</para>
        <programlisting>
(send w :set-origin (ns-make-point 100.0 200.0))
      </programlisting>
        <para>However, since these aren't real functions, a call like the
        following won't work:</para>
        <programlisting>
(setq p (ns-make-point 100.0 200.0))
      </programlisting>
        <para>To extract fields from these objects, there are also some
        convenience macros: NS-MAX-RANGE, NS-MIN-X,
        NS-MIN-Y, NS-MAX-X, NS-MAX-Y, NS-MID-X, NS-MID-Y,
        NS-HEIGHT, and NS-WIDTH.</para>
        <para>        Note that there is also a <literal>send-super/stret</literal>
        for use within methods.  Like <literal>send-super</literal>,
        it ignores any shadowing methods in a subclass, and calls the
        version of a method which belongs to its superclass.</para>
      </section>
      <section id="variable-arity-messages">
        <title>Variable-Arity Messages</title>
        <para>
        There are a few messages in Cocoa which take variable numbers
        of arguments. Perhaps the most common examples involve
        formatted strings:</para>
        <programlisting>
[NSClass stringWithFormat: &quot;%f %f&quot; x y]
      </programlisting>
        <para>In Lisp, this would be written:</para>
        <programlisting>
(send (find-class 'ns:ns-string)
      :string-with-format #@&quot;%f %f&quot;
      (:double-float x :double-float y))
      </programlisting>
        <para>Note that it's necessary to specify the foreign types of the
        variables (in this example, :double-float), because the
        compiler has no general way of knowing these types.  (You
        might think that it could parse the format string, but this
        would only work for format strings which are not determined
        at runtime.)</para>
        <para>        Because the Objective-C runtime system does not provide any information
        on which messages are variable arity, they must be explicitly
        declared. The standard variable arity messages in Cocoa are
        predeclared by the bridge.  If you need to declare a new
        variable arity message, use
        (DEFINE-VARIABLE-ARITY-MESSAGE &quot;myVariableArityMessage:&quot;).</para>
      </section>
      <section id="optimization">
        <title>Optimization</title>
        <para>The bridge works fairly hard to optimize message sends,
        when it has enough information to do so.  There are two cases
        when it does.  In either, a message send should be nearly as
        efficient as when writing in Objective C.</para>
        <para>        The first case is when both the message and the
        receiver's class are known at compile-time. In general, the
        only way the receiver's class is known is if you declare it,
        which you can do with either a DECLARE or a THE form.  For
        example:</para>
        <programlisting>
(send (the ns:ns-window w) 'center)
	  </programlisting>
        <para>Note that there is no way in Objective-C to name the class of a
        class.  Thus the bridge provides a declaration, @METACLASS.
        The type of an instance of &quot;NSColor&quot; is ns:ns-color.  The type
        of the <emphasis>class</emphasis> &quot;NSColor&quot; is (@metaclass
        ns:ns-color):</para>
        <programlisting>
(let ((c (find-class 'ns:ns-color)))
  (declare ((ccl::@metaclass ns:ns-color) c))
  (send c 'white-color))
      </programlisting>
        <para>The other case that allows optimization is when only
        the message is known at compile-time, but its type signature
        is unique. Of the more-than-6000 messages currently provided
        by Cocoa, only about 50 of them have nonunique type
        signatures.</para>
        <para>        An example of a message with a type signature that is
        not unique is SET.  It returns VOID for NSColor, but ID for
        NSSet.  In order to optimize sends of messages with nonunique
        type signatures, the class of the receiver must be declared at
        compile-time.</para>
        <para>        If the type signature is nonunique or the message is
        unknown at compile-time, then a slower runtime call must be
        used.</para>
        <para>        When the receiver's class is unknown, the bridge's
        ability to optimize relies on a type-signature table which it
        maintains.  When first loaded, the bridge initializes this
        table by scanning every method of every Objective-C class.  When new
        methods are defined later, the table must be updated.  This
        happens automatically when you define methods in Lisp.  After
        any other major change, such as loading an external framework,
        you should rebuild the table:</para>
        <programlisting>
? (update-type-signatures)
      </programlisting>
        <para>Because <literal>send</literal> and its relatives
        <literal>send-super</literal>, <literal>send/stret</literal>,
        and <literal>send-super/stret</literal> are macros, they
        cannot be <literal>funcall</literal>ed,
        <literal>apply</literal>ed, or passed as arguments to
        functions.</para>
        <para>        To work around this, there are function equivalents to
        them: <literal>%send</literal>,
        <literal>%send-super</literal>,
        <literal>%send/stret</literal>, and
        <literal>%send-super/stret</literal>.  However, these
        functions should be used only when the macros will not do,
        because they are unable to optimize.</para>
      </section>
    </section>
    <section id="defining-objective-c-classes">
      <title>Defining Objective-C Classes</title>
      <para>You can define your own foreign classes, which can then be
      passed to foreign functions; the methods which you implement in
      Lisp will be made available to the foreign code as
      callbacks.</para>
      <para>      You can also define subclasses of existing classes,
      implementing your subclass in Lisp even though the parent class
      was in Objective C.  One such subclass is CCL::NS-LISP-STRING.
      It is also particularly useful to make subclasses of
      NS-WINDOW-CONTROLLER.</para>
      <para>      We can use the MOP to define new Objective-C classes, but
      we have to do something a little funny: the :METACLASS that we'd
      want to use in a DEFCLASS option generally doesn't exist until
      we've created the class (recall that Objective-C classes have, for the
      sake of argument, unique and private metaclasses.) We can sort
      of sleaze our way around this by specifying a known Objective-C
      metaclass object name as the value of the DEFCLASS :METACLASS
      object; the metaclass of the root class NS:NS-OBJECT,
      NS:+NS-OBJECT, makes a good choice. To make a subclass of
      NS:NS-WINDOW (that, for simplicity's sake, doesn't define any
      new slots), we could do:</para>
      <programlisting>
(defclass example-window (ns:ns-window)
  ()
  (:metaclass ns:+ns-object))
    </programlisting>
      <para>That'll create a new Objective-C class named EXAMPLE-WINDOW whose
      metaclass is the class named +EXAMPLE-WINDOW. The class will be
      an object of type OBJC:OBJC-CLASS, and the metaclass will be of
      type OBJC:OBJC-METACLASS.  EXAMPLE-WINDOW will be a subclass of
      NS-WINDOW.</para>
      <section id="defining-classes-with-foreign-slots">
        <title>Defining classes with foreign slots</title>
        <para>If a slot specification in an Objective-C class
        definition contains the keyword :FOREIGN-TYPE, the slot will
        be a &quot;foreign slot&quot; (i.e. an Objective-C instance variable). Be aware
        that it is an error to redefine an Objective-C class so that its
        foreign slots change in any way, and Clozure CL doesn't do
        anything consistent when you try to.</para>
        <para>        The value of the :FOREIGN-TYPE initarg should be a
        foreign type specifier. For example, if we wanted (for some
        reason) to define a subclass of NS:NS-WINDOW that kept track
        of the number of key events it had received (and needed an
        instance variable to keep that information in), we could
        say:</para>
        <programlisting>
(defclass key-event-counting-window (ns:ns-window)
  ((key-event-count :foreign-type :int
                    :initform 0
                    :accessor window-key-event-count))
  (:metaclass ns:+ns-object))
      </programlisting>
        <para>Foreign slots are always SLOT-BOUNDP, and the initform
        above is redundant: foreign slots are initialized to binary
        0.</para>
      </section>
      <section id="defining-classes-with-lisp-slots">
        <title>Defining classes with Lisp slots</title>
        <para>A slot specification in an Objective-C class definition that
        doesn't contain the :FOREIGN-TYPE initarg defines a
        pretty-much normal lisp slot that'll happen to be associated
        with &quot;an instance of a foreign class&quot;. For instance:</para>
        <programlisting>
(defclass hemlock-buffer-string (ns:ns-string)
  ((hemlock-buffer :type hi::hemlock-buffer
                   :initform hi::%make-hemlock-buffer
                   :accessor string-hemlock-buffer))
  (:metaclass ns:+ns-object))
	  </programlisting>
        <para>As one might expect, this has memory-management
        implications: we have to maintain an association between a
        MACPTR and a set of lisp objects (its slots) as long as the
        Objective-C instance exists, and we have to ensure that the Objective-C
        instance exists (does not have its -dealloc method called)
        while lisp is trying to think of it as a first-class object
        that can't be &quot;deallocated&quot; while it's still possible to
        reference it. Associating one or more lisp objects with a
        foreign instance is something that's often very useful; if you
        were to do this &quot;by hand&quot;, you'd have to face many of the same
        memory-management issues.</para>
      </section>
    </section>
    <section id="defining-objective-c-methods">
      <title>Defining Objective-C Methods</title>
      <para>In Objective-C, unlike in CLOS, every method belongs to some
      particular class.  This is probably not a strange concept to
      you, because C++ and Java do the same thing.  When you use Lisp
      to define Objective-C methods, it is only possible to define methods
      belonging to Objective-C classes which have been defined in
      Lisp.</para>
      <para>      You can use either of two different macros to define methods
      on Objective-C classes. <literal>define-objc-method</literal>
      accepts a two-element list containing a message selector name
      and a class name, and a body. <literal>objc:defmethod</literal>
      superficially resembles the normal
      CLOS <literal>defmethod</literal>, but creates methods on
      Objective-C classes with the same restrictions as those created
      by <literal>define-objc-method</literal>.</para>
      <section id="using-define-objc-method">
        <title>Using define-objc-method</title>
        <para>As described in the
        section <xref linkend="calling-objective-c-methods"/>, the names of Objective-C methods
        are broken into pieces, each piece followed by a parameter.
        The types of all parameters must be explicitly
        declared.</para>
        <para>        Consider a few examples, meant to illustrate the use
        of <literal>define-objc-method</literal>. Let us define a
        class to use in them:</para>
        <programlisting>
(defclass data-window-controller (ns:ns-window-controller)
  ((window :foreign-type :id :accessor window)
   (data :initform nil :accessor data))
  (:metaclass ns:+ns-object))
      </programlisting>
        <para>There's nothing special about this class.  It inherits from
        <literal>ns:ns-window-controller</literal>.  It has two slots:
        <literal>window</literal> is a foreign slot, stored in the Objective-C
        world; and <literal>data</literal> is an ordinary slot, stored
        in the Lisp world.</para>
        <para>        Here is an example of how to define a method which takes no
        arguments:</para>
        <programlisting>
(define-objc-method ((:id get-window)
                     data-window-controller)
    (window self))
      </programlisting>
        <para>The return type of this method is the foreign type :id,
        which is used for all Objective-C objects.  The name of the
        method is
        <literal>get-window</literal>.  The body of the method is the
        single line <literal>(window self)</literal>.  The
        variable <literal>self</literal> is bound, within the body, to
        the instance that is receiving the message.  The call
        to <literal>window</literal> uses the CLOS accessor to get the
        value of the window field.</para>
        <para>        Here's an example that takes a parameter.  Notice that the
        name of the method without a parameter was an ordinary symbol,
        but with a parameter, it's a keyword:</para>
        <programlisting>
(define-objc-method ((:id :init-with-multiplier (:int multiplier))
                     data-window-controller)
  (setf (data self) (make-array 100))
  (dotimes (i 100)
    (setf (aref (data self) i)
          (* i multiplier)))
  self)
      </programlisting>
        <para>To Objective-C code that uses the class, the name of this
        method is <literal>initWithMultiplier:</literal>.  The name of
        the parameter is
        <literal>multiplier</literal>, and its type
        is <literal>:int</literal>.  The body of the method does some
        meaningless things.  Then it returns
        <literal>self</literal>, because this is an initialization
        method.</para>
        <para>Here's an example with more than one parameter:</para>
        <programlisting>
(define-objc-method ((:id :init-with-multiplier (:int multiplier)
                          :and-addend (:int addend))
                     data-window-controller)
  (setf (data self) (make-array size))
  (dotimes (i 100)
    (setf (aref (data self) i)
          (+ (* i multiplier)
             addend)))
  self)
      </programlisting>
        <para>To Objective-C, the name of this method is
        <literal>initWithMultiplier:andAddend:</literal>.  Both
        parameters are of type <literal>:int</literal>; the first is
        named <literal>multiplier</literal>, and the second
        is <literal>addend</literal>.  Again, the method returns
        <literal>self</literal>.</para>
        <para>        Here is a method that does not return any value, a so-called
        &quot;void method&quot;.  Where our other methods
        said <literal>:id</literal>, this one
        says <literal>:void</literal> for the return type:</para>
        <programlisting>
(define-objc-method ((:void :take-action (:id sender))
                     data-window-controller)
  (declare (ignore sender))
  (dotimes (i 100)
    (setf (aref (data self) i)
          (- (aref (data self) i)))))
      </programlisting>
        <para>This method would be called <literal>takeAction:</literal>
        in Objective-C.  The convention for methods that are going to be
        used as Cocoa actions is that they take one parameter, which is
        the object responsible for triggering the action.  However, this
        method doesn't actually need to use that parameter, so it
        explicitly ignores it to avoid a compiler warning.  As promised,
        the method doesn't return any value.</para>
        <para>        There is also an alternate syntax, illustrated here.  The
        following two method definitions are equivalent:</para>
        <programlisting><para>
(define-objc-method (&quot;applicationShouldTerminate:&quot;
                     &quot;LispApplicationDelegate&quot;)
    (:id sender :&lt;BOOL&gt;)
    (declare (ignore sender))
    nil)</para><para>(define-objc-method ((:&lt;BOOL&gt;
                        :application-should-terminate sender)
                       lisp-application-delegate)
    (declare (ignore sender))
    nil)
      </para></programlisting>
      </section>
      <section id="using-objc-defmethod">
        <title>Using objc:defmethod</title>
        <para>The macro <literal>OBJC:DEFMETHOD</literal> can be used to
        define Objective-C methods.  It looks superficially like
        <literal>CL:DEFMETHOD</literal> in some respects.</para>
        <para>Its syntax is</para>
        <programlisting>
(OBC:DEFMETHOD name-and-result-type 
               ((receiver-arg-and-class) <literal>&amp;rest</literal> other-args) 
      <literal>&amp;body</literal> body)
      </programlisting>
        <para><literal>name-and-result-type</literal> is either an
        Objective-C message name, for methods that return a value of
        type <literal>:ID</literal>, or a list containing an
        Objective-C message name and a foreign type specifier for
        methods with a different foreign result type.</para>
        <para>        <literal>receiver-arg-and-class</literal> is a two-element
        list whose first element is a variable name and whose second
        element is the Lisp name of an Objective-C class or metaclass.
        The receiver variable name can be any bindable lisp variable
        name, but <literal>SELF</literal> might be a reasonable
        choice.  The receiver variable is declared to be &quot;unsettable&quot;;
        i.e., it is an error to try to change the value of the
        receiver in the body of the method definition.</para>
        <para>            <literal>other-args</literal> are either variable names
            (denoting parameters of type <literal>:ID</literal>) or
            2-element lists whose first element is a variable name and
            whose second element is a foreign type specifier.</para>
        <para>Consider this example:</para>
        <programlisting>
(objc:defmethod (#/characterAtIndex: :unichar)
    ((self hemlock-buffer-string) (index :&lt;NSUI&gt;nteger))
  ...)
      </programlisting>
        <para>The method <literal>characterAtIndex:</literal>, when
        invoked on an object of
        class <literal>HEMLOCK-BUFFER-STRING</literal> with an
        additional argument of
        type <literal>:&lt;NSU&gt;integer</literal> returns a value of
        type
        <literal>:unichar</literal>.</para>
        <para>        Arguments that wind up as some pointer type other
        than <literal>:ID</literal> (e.g. pointers, records passed by
        value) are represented as typed foreign pointers, so that the
        higher-level, type-checking accessors can be used on arguments
        of
        type <literal>:ns-rect</literal>, <literal>:ns-point</literal>,
        and so on.</para>
        <para>        Within the body of methods defined
        via <literal>OBJC:DEFMETHOD</literal>, the local function
        <literal>CL:CALL-NEXT-METHOD</literal> is defined.  It isn't
        quite as general as <literal>CL:CALL-NEXT-METHOD</literal> is
        when used in a CLOS method, but it has some of the same
        semantics.  It accepts as many arguments as are present in the
        containing method's <literal>other-args</literal> list and
        invokes version of the containing method that would have been
        invoked on instances of the receiver's class's superclass with
        the receiver and other provided arguments.  (The idiom of
        passing the current method's arguments to the next method is
        common enough that the <literal>CALL-NEXT-METHOD</literal> in
        <literal>OBJC:DEFMETHODs</literal> should probably do this if
        it receives no arguments.)</para>
        <para>        A method defined via <literal>OBJC:DEFMETHOD</literal>
        that returns a structure &quot;by value&quot; can do so by returning a
        record created via <literal>MAKE-GCABLE-RECORD</literal>, by
        returning the value returned
        via <literal>CALL-NEXT-METHOD</literal>, or by other similar
        means. Behind the scenes, there may be a pre-allocated
        instance of the record type (used to support native
        structure-return conventions), and any value returned by the
        method body will be copied to this internal record instance.
        Within the body of a method defined
        with <literal>OBJC:DEFMETHOD</literal> that's declared to
        return a structure type, the local macro
        <literal>OBJC:RETURNING-FOREIGN-STRUCT</literal> can be used
        to access the internal structure. For example:</para>
        <programlisting>
(objc:defmethod (#/reallyTinyRectangleAtPoint: :ns-rect) 
  ((self really-tiny-view) (where :ns-point))
  (objc:returning-foreign-struct (r)
    (ns:init-ns-rect r (ns:ns-point-x where) (ns:ns-point-y where)
                        single-float-epsilon single-float-epsilon)
    r))
       </programlisting>
        <para>If the <literal>OBJC:DEFMETHOD</literal> creates a new
       method, then it displays a message to that effect. These
       messages may be helpful in catching errors in the names of
       method definitions. In addition, if
       a <literal>OBJC:DEFMETHOD</literal> form redefines a method in
       a way that changes its type signature, Clozure CL signals a
       continuable error.</para>
      </section>
      <section id="method-redefinition-constraints">
        <title>Method Redefinition Constraints</title>
        <para>Objective C was not designed, as Lisp was, with runtime
        redefinition in mind.  So, there are a few constraints about
        how and when you can replace the definition of an Objective C
        method.  Currently, if you break these rules, nothing will
        collapse, but the behavior will be confusing; so
        don't.</para>
        <para>        Objective C methods can be redefined at runtime, but
        their signatures shouldn't change.  That is, the types of the
        arguments and the return type have to stay the same.  The
        reason for this is that changing the signature changes the
        selector which is used to call the method.</para>
        <para>        When a method has already been defined in one class, and
        you define it in a subclass, shadowing the original method,
        they must both have the same type signature.  There is no such
        constraint, though, if the two classes aren't related and the
        methods just happen to have the same name.</para>
      </section>
    </section>
    <section id="loading-frameworks">
      <title>Loading Frameworks</title>
      <para>On Mac OS X, a framework is a structured directory
      containing one or more shared libraries along with metadata such
      as C and Objective-C header files. In some cases, frameworks may
      also contain additional items such as executables.</para>
      <para>      Loading a framework means opening the shared libraries and
      processing any declarations so that Clozure CL can subsequently call
      its entry points and use its data structures. Clozure CL provides the
      function <literal>OBJC:LOAD-FRAMEWORK</literal> for this
      purpose.</para>
      <programlisting>
(OBJC:LOAD-FRAMEWORK framework-name interface-dir)
    </programlisting>
      <para><literal>framework-name</literal> is a string that names the
    framework (for example, &quot;Foundation&quot;, or &quot;Cocoa&quot;),
    and <literal>interface-dir</literal> is a keyword that names the
    set of interface databases associated with the named framework
    (for example, <literal>:foundation</literal>,
    or <literal>:cocoa</literal>).</para>
      <para>    Assuming that interface databases for the named frameworks
    exist on the standard search
    path, <literal>OBJC:LOAD-FRAMEWORK</literal> finds and initializes
    the framework bundle by searching OS X's standard framework search
    paths. Loading the named framework may create new Objective-C
    classes and methods, add foreign type descriptions and entry
    points, and adjust Clozure CL's dispatch functions.</para>
      <para>    If interface databases don't exist for a framework you want
    to use, you will need to create them. For more information about
    creating interface databases,
    see <xref linkend="creating-new-interface-directories"/>.</para>
    </section>
    <section id="how-objective-c-names-are-mapped-to-lisp-symbols">
      <title>How Objective-C Names are Mapped to Lisp Symbols</title>
      <para>There is a standard set of naming conventions for Cocoa
      classes, messages, etc.  As long as they are followed, the
      bridge is fairly good at automatically translating between Objective-C
      and Lisp names.</para>
      <para>      For example, &quot;NSOpenGLView&quot; becomes ns:ns-opengl-view;
      &quot;NSURLHandleClient&quot; becomes ns:ns-url-handle-client; and
      &quot;nextEventMatchingMask:untilDate:inMode:dequeue:&quot; becomes
      (:next-event-matching-mask :until-date :in-mode :dequeue).  What
      a mouthful.</para>
      <para>      To see how a given Objective-C or Lisp name will be translated by
      the bridge, you can use the following functions:</para>
      <blockquote>
        <simplelist>
          <member>(ccl::objc-to-lisp-classname string)</member>
          <member>(ccl::lisp-to-objc-classname symbol)</member>
          <member>(ccl::objc-to-lisp-message string)</member>
          <member>(ccl::lisp-to-objc-message string)</member>
          <member>(ccl::objc-to-lisp-init string)</member>
          <member>(ccl::lisp-to-objc-init keyword-list)</member>
        </simplelist>
      </blockquote>
      <para>Of course, there will always be exceptions to any naming
      convention.  Please tell us on the mailing lists if you come
      across any name translation problems that seem to be bugs.
      Otherwise, the bridge provides two ways of dealing with
      exceptions:</para>
      <para>      First, you can pass a string as the class name of
      MAKE-OBJC-INSTANCE and as the message to SEND.  These strings
      will be directly interpreted as Objective-C names, with no
      translation. This is useful for a one-time exception.  For
      example:</para>
      <programlisting>
(ccl::make-objc-instance &quot;WiErDclass&quot;)
(ccl::send o &quot;WiErDmEsSaGe:WithARG:&quot; x y)
    </programlisting>
      <para>Alternatively, you can define a special translation rule
      for your exception.  This is useful for an exceptional name that
      you need to use throughout your code.  Some examples:</para>
      <programlisting>
(ccl::define-classname-translation &quot;WiErDclass&quot; wierd-class)
(ccl::define-message-translation &quot;WiErDmEsSaGe:WithARG:&quot; (:weird-message :with-arg))
(ccl::define-init-translation &quot;WiErDiNiT:WITHOPTION:&quot; (:weird-init :option))
    </programlisting>
      <para>The normal rule in Objective-C names is that each word begins with a
      capital letter (except possibly the first).  Using this rule
      literally, &quot;NSWindow&quot; would be translated as N-S-WINDOW, which
      seems wrong.  &quot;NS&quot; is a special word in Objective-C that should not be
      broken at each capital letter. Likewise &quot;URL&quot;, &quot;PDF&quot;, &quot;OpenGL&quot;,
      etc. Most common special words used in Cocoa are already defined
      in the bridge, but you can define new ones as follows:</para>
      <programlisting>
(ccl::define-special-objc-word &quot;QuickDraw&quot;)
    </programlisting>
      <para>Note that message keywords in a SEND such as (SEND V
      :MOUSE P :IN-RECT R) may look like the keyword arguments in a
      Lisp function call, but they really aren't. All keywords must be
      present and the order is significant. Neither (:IN-RECT :MOUSE)
      nor (:MOUSE) translate to &quot;mouse:inRect:&quot;</para>
      <para>      Also, as a special exception, an &quot;init&quot; prefix is optional
      in the initializer keywords, so (MAKE-OBJC-INSTANCE 'NS-NUMBER
      :INIT-WITH-FLOAT 2.7) can also be expressed as
      (MAKE-OBJC-INSTANCE 'NS-NUMBER :WITH-FLOAT 2.7)</para>
    </section>
  </chapter>
  <chapter id="platform-specific-notes">
    <title>Platform-specific notes</title>
    <section id="overview_in_platform-specific-notes">
      <title>Overview</title>
      <para> The documentation and whatever experience you may have in
      using Clozure CL under Linux should also apply to using it under
      Darwin/MacOS X and FreeBSD. There are some differences between
      the platforms, and these differences are sometimes exposed in
      the implementation.</para>
      <section id="differences-between-32-bit-and-64-bit-implementations">
        <title>Differences Between 32-bit and 64-bit implementations</title>
        <para>Fixnums on 32-bit systems are 30 bits long, and are in the
	  range -536870912 through 536870911.  Fixnums on 64-bit
	  systems are 61 bits long, and are in the range
	  -1152921504606846976 through 1152921504606846975. (see <xref linkend="tagging-scheme"/>)</para>
        <para>	    Since we have much larger fixnums on 64-bit systems,
	    <indexterm><primary><literal>INTERNAL-TIME-UNITS-PER-SECOND</literal></primary></indexterm><literal>INTERNAL-TIME-UNITS-PER-SECOND</literal> is 1000000
	    on 64-bit systems but remains 1000 on 32-bit systems.  This
	    enables much finer grained timing on 64-bit systems.</para>
      </section>
      <section id="file-system-case">
        <title>File-system case</title>
        <para>Darwin and MacOS X use HFS+ file systems by default;
	    HFS+ file systems are usually case-insensitive. Most of
	    Clozure CL's filesystem and pathname code assumes that the
	    underlying filesystem is case-sensitive; this assumption
	    extends to functions like EQUAL, which assumes that #p&quot;FOO&quot;
	    and #p&quot;foo&quot; denote different, un-EQUAL filenames. Since
	    Darwin/MacOS X can also use UFS and NFS filesystems, the
	    opposite assumption would be no more correct than the one
	    that's currently made.</para>
        <para>        Whatever the best solution to this problem turns out to
        be, there are some practical considerations. Doing:</para>
        <programlisting>
? (save-application &quot;DPPCCL&quot;)
	  </programlisting>
        <para>on 32-bit DarwinPPC has the unfortunate side-effect of
        trying to overwrite the Darwin Clozure CL kernel, &quot;dppccl&quot;, on a
        case-insensitive filesystem.</para>
        <para>        To work around this, the Darwin Clozure CL kernel expects
        the default heap image file name to be the kernel's own
        filename with the string &quot;.image&quot; appended, so the idiom would
        be:</para>
        <programlisting>
? (save-application &quot;dppccl.image&quot;)
	  </programlisting>
      </section>
      <section id="line-termination-characters">
        <title>Line Termination Characters</title>
        <para>MacOSX effectively supports two distinct line-termination
	    conventions. Programs in its Darwin substrate follow the Unix
	    convention of recognizing #\LineFeed as a line terminator; traditional
	    MacOS programs use #\Return for this purpose.  Many modern
	    GUI programs try to support several different line-termination
	    conventions (on the theory that the user shouldn't be too concerned
	    about what conventions are used an that it probably doesn't matter.
	    Sometimes this is true, other times ... not so much.</para>
        <para>        Clozure CL follows the Unix convention on both Darwin and
        LinuxPPC, but offers some support for reading and writing
        files that use other conventions (including traditional MacOS
        conventions) as well.</para>
        <para>	    This support (and anything like it) is by nature
	    heuristic: it can successfully hide the distinction between
	    newline conventions much of the time, but could mistakenly
	    change the meaning of otherwise correct programs (typically
	    when files contain both #\Return and #\Linefeed characters or
	    when files contain mixtures of text and binary data.) Because
	    of this concern, the default settings of some of the variables
	    that control newline translation and interpretation are
	    somewhat conservative.</para>
        <para>	    Although the issue of multiple newline conventions
	    primarily affects MacOSX users, the functionality described
	    here is available under LinuxPPC as well (and may occasionally
	    be useful there.)</para>
        <para>	    None of this addresses issues
	    related to the third newline convention (&quot;CRLF&quot;) in widespread
	    use (since that convention isn't native to any platform on
	    which Clozure CL currently runs). If Clozure CL is ever ported to
	    such a platform, that issue might be revisited.</para>
        <para>	    Note that some MacOS programs (including some versions
	    of commercial MCL) may use HFS file type information to
	    recognize TEXT and other file types and so may fail to
	    recognize files created with Clozure CL or other Darwin
	    applications (regardless of line termination issues.)</para>
        <para>	    Unless otherwise noted, the symbols mentioned in this
	    documentation are exported from the CCL package.</para>
      </section>
      <section id="single-precision-trig-transcendental-functions">
        <title>Single-precision trig &amp; transcendental functions</title>
        <para>
	    Despite what Darwin's man pages say, early versions of its math library
	    (up to and including at least OSX 10.2 (Jaguar) don't implement
	    single-precision variants of the transcendental and trig functions
	    (#_sinf, #_atanf, etc.) Clozure CL worked around this by coercing
	    single-precision args to double-precision, calling the
	    double-precision version of the math library function, and coercing
	    the result back to a SINGLE-FLOAT. These steps can introduce rounding
	    errors (and potentially overflow conditions) that might not be present
	    or as severe if true 32-bit variants were available.</para>
      </section>
      <section id="shared-libraries">
        <title>Shared libraries</title>
        <para>Darwin/MacOS X distinguishes between &quot;shared libraries&quot;
        and &quot;bundles&quot; or &quot;extensions&quot;; Linux and FreeBSD don't. In
        Darwin, &quot;shared libraries&quot; have the file type &quot;dylib&quot; : the
        expectation is that this class of file is linked against when
        executable files are created and loaded by the OS when the
        executable is launched. The latter class -
        &quot;bundles/extensions&quot; - are expected to be loaded into and
        unloaded from a running application, via a mechanism like the
        one used by Clozure CL's OPEN-SHARED-LIBRARY function.</para>
      </section>
    </section>
    <section id="unix-posix-darwin-features">
      <title>Unix/Posix/Darwin Features</title>
      <para>Clozure CL has several convenience functions which allow you
      to make Posix (portable Unix) calls without having to use the
      foreign-function interface.  Each of these corresponds directly
      to a single Posix function call, as it might be made in C.
      There is no attempt to make these calls correspond to Lisp
      idioms, such as <literal>setf</literal>.  This means that their
      behavior is simple and predictable.</para>
      <para>      For working with environment variables, there are
      CCL::GETENV and CCL::SETENV.</para>
      <para>      For working with user and group IDs, there are
      CCL::GETUID, CCL::SETUID, and CCL::SETGID.  To find the home
      directory of an arbitrary user, as set in the user database
      (/etc/passwd), there is CCL::GET-USER-HOME-DIR.</para>
      <para>For process IDs, there is CCL::GETPID.</para>
      <para>      For the <literal>system()</literal> function, there is
      CCL::OS-COMMAND.  Ordinarily, it is better - both more efficient
      and more predictable - to use the features described in <xref linkend="running-other-programs-as-subprocesses"/>.  However,
      sometimes you may want to specifically ask the shell to invoke a
      command for you.</para>
    </section>
    <section id="cocoa-programming-in-clozure-cl">
      <title>Cocoa Programming in Clozure CL</title>
      <para>Cocoa is one of Apple's APIs for GUI programming; for most
      purposes, development is considerably faster with Cocoa than
      with the alternatives.  You should have a little familiarity
      with it, to better understand this section.</para>
      <para>      A small sample Cocoa program can be invoked by evaluating
      (REQUIRE 'TINY) and then (CCL::TINY-SETUP). This program
      provides a simple example of using several of the bridge's
      capabilities.</para>
      <para>      The Tiny demo creates Cocoa objects dynamically, at
      runtime, which is always an option.  However, for large
      applications, it is usually more convenient to create your
      objects with Apple Interface Builder, and store them in .nib
      files to be loaded when needed.  Both approaches can be freely
      mixed in a single program.</para>
      <section id="the-command-line-and-the-window-system">
        <title>The Command Line and the Window System</title>
        <para>Clozure CL is ordinarily a command-line application (it
        doesn't have a connection to the OSX Window server, doesn't
        have its own menubar or dock icon, etc.) By opening some
        libraries and jumping through some hoops, it's able to sort of
        transform itself into a full-fledged GUI application (while
        retaining its original TTY-based listener.) The general idea
        is that this hybrid environment can be used to test and
        protoype UI ideas and the resulting application can eventually
        be fully transformed into a bundled, double-clickable
        application. This is to some degree possible, but there needs
        to be a bit more infrastructure in place before many people
        would find it easy.</para>
        <para>        Cocoa applications use the NSLog function to write
        informational/warning/error messages to the application's
        standard output stream. When launched by the Finder, a GUI
        application's standard output is diverted to a logging
        facility that can be monitored with the Console application
        (found in /Applications/Utilities/Console.app).  In the hybrid
        environment, the application's standard output stream is
        usually the initial listener's standard output stream. With
        two different buffered stream mechanisms trying to write to
        the same underlying Unix file descriptor, it's not uncommon to
        see NSLog output mixed with lisp output on the initial
        listener.</para>
      </section>
      <section id="writing-and-reading-cocoa-code">
        <title>Writing (and reading) Cocoa code</title>
        <para>The
	    syntax of the constructs used to define Cocoa classes and
	    methods has changed a bit (it was never documented outside of
	    the source code and never too well documented at all), largely
	    as the result of functionality offered by Randall Beer's
	    bridge; the &quot;standard name-mapping conventions&quot;
	    referenced below are described in his CocoaBridgeDoc.txt file,
	    as are the constructs used to invoke (&quot;send messages
	    to&quot;) Cocoa methods.</para>
        <para>        All of the symbols described below are currently internal to
        the CCL package.</para>
        <blockquote>
          <simplelist>
            <member><indexterm><primary><literal>OBJC:@CLASS</literal></primary></indexterm><link linkend="m_class"><literal>OBJC:@CLASS</literal></link></member>
            <member><indexterm><primary><literal>OBJC:@SELECTOR</literal></primary></indexterm><link linkend="m_selector"><literal>OBJC:@SELECTOR</literal></link></member>
            <member><indexterm><primary><literal>OBJC:DEFINE-OBJC-METHOD</literal></primary></indexterm><link linkend="m_define-objc-method"><literal>OBJC:DEFINE-OBJC-METHOD</literal></link></member>
            <member><indexterm><primary><literal>OBJC:DEFINE-OBJC-CLASS-METHOD</literal></primary></indexterm><link linkend="m_define-objc-class-method"><literal>OBJC:DEFINE-OBJC-CLASS-METHOD</literal></link></member>
          </simplelist>
        </blockquote>
      </section>
      <section id="the-application-kit-and-multiple-threads">
        <title>The Application Kit and Multiple Threads</title>
        <para>The Cocoa API is broken into several pieces.  The
        Application Kit, affectionately called AppKit, is the one
        which deals with window management, drawing, and handling
        events.  AppKit really wants all these things to be done by a
        &quot;distinguished thread&quot;.  creation, and drawing to take place
        on a distinguished thread.</para>
        <para>        Apple has published some guidelines which discuss these
        issues in some detail; see the Apple Multithreading
        Documentation, and in particular the guidelines on Using the
        Application Kit from Multiple Threads.  The upshot is that
        there can sometimes be unexpected behavior when objects are
        created in threads other than the distinguished event thread;
        eg, the event thread sometimes starts performing operations on
        objects that haven't been fully initialized.</para>
        <para>        It's
        certainly more convenient to do certain types of exploratory
        programming by typing things into a listener or evaluating a
        &quot;defun&quot; in an Emacs buffer; it may sometimes be
        necessary to be aware of this issue while doing so.</para>
        <para>        Each thread in the Cocoa runtime system is expected to
        maintain a current &quot;autorelease pool&quot; (an instance
        of the NSAutoreleasePool class); newly created objects are
        often added to the current autorelease pool (via the
        -autorelease method), and periodically the current autorelease
        pool is sent a &quot;-release&quot; message, which causes it
        to send &quot;-release&quot; messages to all of the objects
        that have been added to it.</para>
        <para>        If the current thread doesn't have a current autorelease
        pool, the attempt to autorelease any object will result in a
        severe-looking warning being written via NSLog. The event
        thread maintains an autorelease pool (it releases the current
        pool after each event is processed and creates a new one for
        the next event), so code that only runs in that thread should
        never provoke any of these severe-looking NSLog
        messages.</para>
        <para>        To try to suppress these messages (and
        still participate in the Cocoa memory management scheme), each
        listener thread (the initial listener and any created via the
        &quot;New Listener&quot; command in the IDE) is given a
        default autorelease pool; there are REPL colon-commands for
        manipulating the current listener's &quot;toplevel
        autorelease pool&quot;.</para>
        <para>        In the current scheme, every time that Cocoa calls lisp
        code, a lisp error handler is established which maps any lisp
        conditions to ObjC exceptions and arranges that this exception
        is raised when the callback to lisp returns. Whenever lisp
        code invokes a Cocoa method, it does so with an ObjC exception
        handler in place; this handler maps ObjC exceptions to lisp
        conditions and signals those conditions.</para>
        <para>        Any
        unhandled lisp error or ObjC exception that occurs during the
        execution of the distinguished event thread's event loop
        causes a message to be NSLog'ed and the event loop to (try to)
        continue execution. Any error that occurs in other threads is
        handled at the point of the outermost Cocoa method
        invocation. (Note that the error is not necessarily
        &quot;handled&quot; in the dynamic context in which it
        occurs.)</para>
        <para>        Both of these behaviors could possibly be improved; both of them
        seem to be substantial improvements over previous behaviors (where,
        for instance, a misspelled message name typically terminated the
        application.)</para>
      </section>
      <section id="acknowledgement_in_cocoa-programming-in-clozure-cl">
        <title>Acknowledgement</title>
        <para>The Cocoa bridge was originally developed, and
        generously contributed by, Randall Beer.</para>
      </section>
    </section>
    <section id="building-an-application-bundle">
      <title>Building an Application Bundle</title>
      <para>You may have noticed that (require &quot;COCOA&quot;) takes a long
      time to load.  It is possible to avoid this by saving a Lisp
      heap image which has everything already loaded.  There is an
      example file which allows you to do this,
      &quot;ccl/examples/cocoa-application.lisp&quot;, by producing a
      double-clickable application which runs your program.  First,
      load your own program.  Then, do:</para>
      <programlisting>
? (require &quot;COCOA-APPLICATION&quot;)
    </programlisting>
      <para>When it finishes, you should be able to double-click the Clozure CL icon
      in the ccl directory, to quickly start your program.</para>
      <para>      The OS may have already decided that Clozure CL.app isn't a valid
      executable bundle, and therefore won't let you double-click it.
      If this happens to you, to force it to reconsider, just update the
      last-modified time of the bundle.  In Terminal:</para>
      <programlisting>&gt; touch Clozure CL.app
    </programlisting>
      <para>When an image which had contained ObjC classes (which are also
      CLOS classes) is re-launched, those classes are &quot;revived&quot;: all
      preexisting classes have their addresses updated destructively, so that
      existing subclass/superclass/metaclass relationships are maintained.
      It's not possible (and may never be) to preserve foreign
      instances across SAVE-APPLICATION. (It may be the case that NSArchiver
      and NSCoder and related classes offer some approximation of that.)</para>
    </section>
    <section id="recommended-reading_in_platform-specific-notes">
      <title>Recommended Reading</title>
      <blockquote>
        <variablelist>
          <varlistentry>
            <term><ulink url="http://developer.apple.com/technologies/mac/cocoa.html">Mac OS X - Cocoa</ulink>, <ulink url="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/Cocoa.html">Cocoa Core Competencies
              </ulink>, <ulink url="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html">Cocoa Fundamentals Guide
              </ulink></term>
            <listitem><para>
	        These are top-level pages pertaining to Cocoa in Apple's Mac OS X Developer Library.
	        If you are unfamiliar with Cocoa, these links are good places to start.
	      </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><ulink url="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html">The Objective-C Programming Language
              </ulink>, <ulink url="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C Runtime Programming Guide
              </ulink></term>
            <listitem><para>These provide a conceptual overview and programming guide to Objective-C the language and runtime, respectively.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><ulink url="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html">Objective-C Runtime Reference
              </ulink></term>
            <listitem><para>
	        This is one of the two most important Cocoa references; it
	        covers all of the basics, except for GUI programming.  This is
	        a reference, not a tutorial.
	      </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><ulink url="http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/index.html">Application Kit Framework Reference</ulink></term>
            <listitem><para>
	        This is the other very important Cocoa reference; it covers GUI programming with Cocoa / Application Kit Framework
	        in considerable depth.  This is a reference, not a tutorial.
	      </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><ulink url="http://developer.apple.com/library/mac/navigation/">Mac OS X Developer Library</ulink></term>
            <listitem><para>
	        This is the top page for Mac OS X developer documentation.
	        Go here to find the documentation on any other Mac OS X API.
	        Also go here if you need general guidance about OS X, Carbon,
	        Cocoa, Core Foundation, or Objective-C.
	      </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><ulink url="http://developer.apple.com/">Resources for Apple Developers</ulink></term>
            <listitem><para>
                This is the top page for all Apple developer documentation.
              </para></listitem>
          </varlistentry>
        </variablelist>
      </blockquote>
    </section>
    <section id="operating-system-dictionary">
      <title>Operating-System Dictionary</title>
      <refentry id="f_getenv">
        <indexterm zone="f_getenv"><primary><literal>GETENV</literal></primary></indexterm>
        <refnamediv>
          <refname>GETENV</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>getenv name =&gt; value</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_getenv">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>a string which is the name of an existing
		        environment variable;
		        case-sensitive</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>value</parameter></term>
                <listitem><para>if there is an environment variable named
		        <parameter>name</parameter>, its value, as a string; if there
		        is not, NIL</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_getenv">
          <title>Description</title>
          <para>
	      Looks up the value of the environment variable named by
	      <parameter>name</parameter>, in the OS environment.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_setenv">
        <indexterm zone="f_setenv"><primary><literal>SETENV</literal></primary></indexterm>
        <refnamediv>
          <refname>SETENV</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>setenv name value =&gt; errno</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_setenv">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name</parameter></term>
                <listitem><para>a string which is the name of a new or existing
		        environment variable;
		        case-sensitive</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>value</parameter></term>
                <listitem><para>a string, to be the new value of the
		        environment variable
		        named by <parameter>name</parameter></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>errno</parameter></term>
                <listitem><para>zero if the function call completes successfully;
		        otherwise, a platform-dependent integer which describes
		        the problem</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_setenv">
          <title>Description</title>
          <para>
	      Sets the value of the environment variable named by
	      <parameter>name</parameter>, in the OS environment.  If there is
	      no such environment
	      variable, creates it.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_current-directory-name">
        <indexterm zone="f_current-directory-name"><primary><literal>CCL::CURRENT-DIRECTORY-NAME</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::CURRENT-DIRECTORY-NAME</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>current-directory-name =&gt; path</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_current-directory-name">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>path</parameter></term>
                <listitem><para>a string, an absolute pathname in Posix format - with
		        directory components separated by slashes</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_current-directory-name">
          <title>Description</title>
          <para>
	      Looks up the current working directory of the Clozure CL process;
	      unless it has been changed, this is the directory Clozure CL was
	      started in.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_getuid">
        <indexterm zone="f_getuid"><primary><literal>CCL::GETUID</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::GETUID</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>getuid =&gt; uid</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_getuid">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>uid</parameter></term>
                <listitem><para>a non-negative integer, identifying a specific user
		        account as defined in the OS user database</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_getuid">
          <title>Description</title>
          <para>
	      Returns the (&quot;real&quot;) user ID of the current user.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_setuid">
        <indexterm zone="f_setuid"><primary><literal>CCL::SETUID</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::SETUID</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>setuid uid =&gt; errno</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_setuid">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>uid</parameter></term>
                <listitem><para>a non-negative integer, identifying a specific user
		        account as defined in the OS user database</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>errno</parameter></term>
                <listitem><para>zero if the function call completes successfully;
		        otherwise, a platform-dependent integer which describes
		        the problem</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_setuid">
          <title>Description</title>
          <para>
	      Attempts to change the current user ID (both &quot;real&quot; and
	      &quot;effective&quot;); fails unless
	      the Clozure CL process has super-user privileges or the ID
	      given is that of the current user.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_setgid">
        <indexterm zone="f_setgid"><primary><literal>CCL::SETGID</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::SETGID</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>setgid gid =&gt; errno</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_setgid">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>gid</parameter></term>
                <listitem><para>a non-negative integer, identifying a specific
		        group as defined in the OS user database</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>errno</parameter></term>
                <listitem><para>zero if the function call completes successfully;
		        otherwise, a platform-dependent integer which describes
		        the problem</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_setgid">
          <title>Description</title>
          <para>
	      Attempts to change the current group ID (both &quot;real&quot; and
	      &quot;effective&quot;); fails unless
	      the Clozure CL process has super-user privileges or the ID
	      given is that of a group to which the current user belongs.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_getpid">
        <indexterm zone="f_getpid"><primary><literal>CCL::GETPID</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::GETPID</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>getpid =&gt; pid</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_getpid">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>pid</parameter></term>
                <listitem><para>a non-negative integer, identifying an OS process</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_getpid">
          <title>Description</title>
          <para>
	      Returns the ID of the Clozure CL OS process.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_get-user-home-dir">
        <indexterm zone="f_get-user-home-dir"><primary><literal>CCL::GET-USER-HOME-DIR</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::GET-USER-HOME-DIR</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>get-user-home-dir uid =&gt; path</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_get-user-home-dir">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>uid</parameter></term>
                <listitem><para>a non-negative integer, identifying a specific user
		        account as defined in the OS user database</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>path</parameter></term>
                <listitem><para>a string, an absolute pathname in Posix format - with
		        directory components separated by slashes; or NIL</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_get-user-home-dir">
          <title>Description</title>
          <para>
	      Looks up and returns the defined home directory of the user
	      identified by <parameter>uid</parameter>.  This value comes from the
	      OS user database, not from the <code>$HOME</code>
	      environment variable.  Returns NIL if there is no user with
	      the ID <parameter>uid</parameter>.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="f_os-command">
        <indexterm zone="f_os-command"><primary><literal>CCL::OS-COMMAND</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::OS-COMMAND</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>os-command command-line =&gt; exit-code</synopsis></refsynopsisdiv>
        <refsect1 id="values_in_f_os-command">
          <title>Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>command-line</parameter></term>
                <listitem><para>a string, obeying all the whitespace and
	            escaping
	            conventions required by the user's default system shell</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>exit-code</parameter></term>
                <listitem><para>a non-negative integer, returned as the exit
	            code of a subprocess; zero indicates success</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_os-command">
          <title>Description</title>
          <para>
	      Invokes the Posix function <literal>system()</literal>, which
	      invokes the user's default system shell (such as
	      sh or tcsh) as a new process, and has that shell execute
	      <parameter>command-line</parameter>.</para>
          <para>	      If the shell was able to find the command specified in
	      <parameter>command-line</parameter>, then <parameter>exit-code</parameter>
	      is the exit code of that command.  If not, it is the exit
	      code of the shell itself.
	    </para>
        </refsect1>
        <refsect1 id="notes_in_f_os-command">
          <title>Notes</title>
          <para>
	      By convention, an exit code of 0 indicates success.  There are
	      also other conventions; unfortunately, they are OS-specific, and
	      the portable macros to decode their meaning are implemented
	      by the system headers as C preprocessor macros.  This means
	      that there is no good, automated way to make them available
	      to Lisp.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="m_class">
        <indexterm zone="m_class"><primary><literal>OBJC:@CLASS</literal></primary></indexterm>
        <refnamediv>
          <refname>OBJC:@CLASS</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>@class class-name</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_class">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>class-name</parameter></term>
                <listitem><para>a string which denotes an existing class name, or a
		        symbol which can be mapped to such a string via the standard
		        name-mapping conventions for class names</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_class">
          <title>Description</title>
          <para>Used to refer to a known ObjC class by name. (Via the use
	      LOAD-TIME-VALUE, the results of a class-name -&gt; class lookup
	      are cached.)</para>
          <para>	      <indexterm><primary><literal>OBJC:@CLASS</literal></primary></indexterm><link linkend="m_class"><literal>OBJC:@CLASS</literal></link> is obsolete as of late 2004, because
	      find-class now works on ObjC classes.  It is described here
	      only because some old code still uses it.
	    </para>
        </refsect1>
      </refentry>
      <refentry id="m_selector">
        <indexterm zone="m_selector"><primary><literal>OBJC:@SELECTOR</literal></primary></indexterm>
        <refnamediv>
          <refname>OBJC:@SELECTOR</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>@selector string</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_selector">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>string</parameter></term>
                <listitem><para>a string constant, used to canonically refer to an
		        ObjC method selector</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_selector">
          <title>Description</title>
          <para>Used to refer to an ObjC method selector (method name). Uses
	      LOAD-TIME-VALUE to cache the result of a string -&gt; selector
	      lookup.</para>
        </refsect1>
      </refentry>
      <refentry id="m_defmethod">
        <indexterm zone="m_defmethod"><primary><literal>OBJC:DEFMETHOD</literal></primary></indexterm>
        <refnamediv>
          <refname>OBJC:DEFMETHOD</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>objc:defmethod name-and-result-type ((receiver-arg-and-class) <literal>&amp;rest</literal> other-args) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_defmethod">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>name-and-result-type</parameter></term>
                <listitem><para>either an Objective-C message name, for methods
                that return a value of type <literal>:ID</literal>, or
                a list containing an Objective-C message name and a
                foreign type specifier for methods with a different
                foreign result type.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>receiver-arg-and-class</parameter></term>
                <listitem><para>a two-element list whose first element is a
                variable name and whose second element is the Lisp
                name of an Objective-C class or metaclass.  The
                receiver variable name can be any bindable lisp
                variable name, but <literal>SELF</literal> might be a
                reasonable choice.  The receiver variable is declared
                to be &quot;unsettable&quot;; i.e., it is an error to try to
                change the value of the receiver in the body of the
                method definition.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>other-args</parameter></term>
                <listitem><para>either variable names (denoting parameters of
            type <literal>:ID</literal>) or 2-element lists whose
            first element is a variable name and whose second element
            is a foreign type specifier.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_defmethod">
          <title>Description</title>
          <para>Defines an Objective-C-callable method which implements
	        the specified message selector for instances of the existing
	        named Objective-C class.</para>
          <para>For a detailed description of the features and
          restrictions of the <literal>OBJC:DEFMETHOD</literal> macro,
          see the
          section <link linkend="using-objc-defmethod">Using <literal>objc:defmethod</literal></link>.</para>
        </refsect1>
      </refentry>
      <refentry id="m_define-objc-method">
        <indexterm zone="m_define-objc-method"><primary><literal>OBJC:DEFINE-OBJC-METHOD</literal></primary></indexterm>
        <refnamediv>
          <refname>OBJC:DEFINE-OBJC-METHOD</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>define-objc-method (selector class-name) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_define-objc-method">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>selector</parameter></term>
                <listitem><para>either a string which represents the name of the
		          selector or a list which describes the method's return
		          type, selector components, and argument types (see below.)
		          If the first form is used, then the first form in the body
		          must be a list which describes the selector's argument
		          types and return value type, as per DEFCALLBACK.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>class-name</parameter></term>
                <listitem><para>either a string which names an existing ObjC class
		          name or a list symbol which can map to such a string via the
		          standard name-mapping conventions for class names. (Note
		          that the &quot;canonical&quot; lisp class name is such a
		          symbol)</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_m_define-objc-method">
          <title>Description</title>
          <para>Defines an ObjC-callable method which implements the
	        specified message selector for instances of the existing ObjC
	        class class-name.</para>
        </refsect1>
      </refentry>
      <refentry id="m_define-objc-class-method">
        <indexterm zone="m_define-objc-class-method"><primary><literal>OBJC:DEFINE-OBJC-CLASS-METHOD</literal></primary></indexterm>
        <refnamediv>
          <refname>OBJC:DEFINE-OBJC-CLASS-METHOD</refname>
          <refpurpose/>
          <refclass>Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>define-objc-class-method (selector class-name) <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_m_define-objc-class-method">
          <title>Arguments and Values</title>
          <para>As per DEFINE-OBJC-METHOD</para>
        </refsect1>
        <refsect1 id="description_in_m_define-objc-class-method">
          <title>Description</title>
          <para>Like DEFINE-OBJC-METHOD, only used to define methods on the
	        <emphasis>class</emphasis> named by class-name and on its
	        subclasses.</para>
          <para>	        For both DEFINE-OBJC-METHOD and DEFINE-OBJC-CLASS-METHOD, the
	        &quot;selector&quot; argument can be a list whose first element is a
	        foreign type specifier for the method's return value type and whose
	        subsequent elements are either:</para>
          <blockquote>
            <itemizedlist>
              <listitem><para>a non-keyword symbol, which can be mapped to a selector string
		        for a parameterless method according to the standard name-mapping
		        conventions for method selectors.</para></listitem>
              <listitem><para>a list of alternating keywords and variable/type specifiers,
		        where the set of keywords can be mapped to a selector string for a
		        parameterized method according to the standard name-mapping
		        conventions for method selectors and each variable/type-specifier is
		        either a variable name (denoting a value of type :ID) or a list whose
		        CAR is a variable name and whose CADR is the corresponding
		        argument's foreign type specifier.</para></listitem>
            </itemizedlist>
          </blockquote>
        </refsect1>
      </refentry>
      <refentry id="v_alternate-line-terminator">
        <indexterm zone="v_alternate-line-terminator"><primary><literal>*ALTERNATE-LINE-TERMINATOR*</literal></primary></indexterm>
        <refnamediv>
          <refname>*ALTERNATE-LINE-TERMINATOR*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL:*ALTERNATE-LINE-TERMINATOR*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_alternate-line-terminator">
          <title>Description</title>
          <para>This variable is currently only used by the standard reader macro
	        function for #\; (single-line comments); that function reads successive
	        characters until EOF, a #\NewLine is read, or a character EQL to the
	        value of *alternate-line-terminator* is read. In Clozure CL for Darwin, the
	        value of this variable is initially #\Return ; in Clozure CL for other OSes,
	        it's initially NIL.</para>
          <para>	        Their default treatment by the #\; reader macro is the primary way
	        in which #\Return and #\Linefeed differ syntactically; by extending the
	        #\; reader macro to (conditionally) treat #\Return as a
	        comment-terminator, that distinction is eliminated. This seems to make
	        LOAD and COMPILE-FILE insensitive to line-termination issues in many
	        cases. It could fail in the (hopefully rare) case where a LF-terminated
	        (Unix) text file contains embedded #\Return characters, and this
	        mechanism isn't adequate to handle cases where newlines are embedded
	        in string constants or other tokens (and presumably should be translated
	        from an external convention to the external one) : it doesn't change
	        what READ-CHAR or READ-LINE &quot;see&quot;, and that may be necessary to
	        handle some more complicated cases.</para>
        </refsect1>
      </refentry>
      <refentry id="c_ns-lisp-string">
        <indexterm zone="c_ns-lisp-string"><primary><literal>CCL::NS-LISP-STRING</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::NS-LISP-STRING</refname>
          <refpurpose/>
          <refclass>Class</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>CCL::NS-LISP-STRING</synopsis></refsynopsisdiv>
        <refsect1 id="superclasses_in_c_ns-lisp-string">
          <title>Superclasses</title>
          <para>NS:NS-STRING</para>
        </refsect1>
        <refsect1 id="initargs">
          <title>Initargs</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>:string</parameter></term>
                <listitem><para>
		          a Lisp string which is to be the content of
		          the newly-created ns-lisp-string.
		        </para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_c_ns-lisp-string">
          <title>Description</title>
          <para>
	        This class
	        implements the interface of an NSString, which means that it can
	        be passed to any Cocoa or Core Foundation function which expects
	        one.</para>
          <para>	        The string itself is stored on the Lisp heap, which
	        means that its memory management is automatic.  However, the
	        ns-lisp-string object itself is a foreign
	        object (that is, it has an objc metaclass), and resides on the
	        foreign heap.  Therefore, it is necessary to explicitly free
	        it, by sending a dealloc message.
	      </para>
        </refsect1>
        <refsect1 id="examples_in_c_ns-lisp-string">
          <title>Examples</title>
          <para>
	        You can create an ns-lisp-string with
	        <indexterm><primary><literal>MAKE-INSTANCE</literal></primary></indexterm><literal>MAKE-INSTANCE</literal>, just like
	        any normal Lisp class:
	      </para>
          <programlisting>? (defvar *the-string*
     (make-instance 'ccl::ns-lisp-string
                    :string &quot;Hello, Cocoa.&quot;))
</programlisting>
          <para>
	        When you are done with the string, you must explicitly
	        deallocate it:
	      </para>
          <programlisting>? (ccl::send *the-string* 'dealloc)</programlisting>
          <para>
	        You may wish to use an <indexterm><primary><literal>UNWIND-PROTECT</literal></primary></indexterm><link linkend="m_unwind-protect"><literal>UNWIND-PROTECT</literal></link>
	        form to ensure that this happens:
	      </para>
          <programlisting>(let (*the-string*)
  (unwind-protect (progn (setq *the-string*
                               (make-instance 'ccl::ns-lisp-string
                                              :string &quot;Hello, Cocoa.&quot;))
                         (format t &quot;~&amp;The string is ~D characters long.~%&quot;
                                 (ccl::send *the-string* 'length)))
    (when *the-string*
      (ccl::send *the-string* 'dealloc))))
</programlisting>
        </refsect1>
        <refsect1 id="notes_in_c_ns-lisp-string">
          <title>Notes</title>
          <para>
	        Currently, ns-lisp-string is defined in
	        the file ccl/examples/cocoa-backtrace.lisp, which is a
	        rather awkward place.  It was probably not originally meant
	        as a public utility at all.  It would be good if it were
	        moved someplace else.  Use at your own risk.
	      </para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="understanding-and-configuring-the-garbage-collector">
    <title>Understanding and Configuring the Garbage Collector</title>
    <section id="heap-space-allocation">
      <title>Heap space allocation</title>
      <para>Release 0.10 or later of Clozure CL uses a different memory
      management scheme than previous versions did. Those earlier
      versions would allocate a block of memory (of specified size) at
      startup and would allocate lisp objects within that block. When
      that block filled with live (non-GCed) objects, the lisp would
      signal a &quot;heap full&quot; condition. The heap size imposed a limit on
      the size of the largest object that could be allocated.</para>
      <para>      The new strategy involves reserving a very large (2GB on
      DarwinPPC32, 1GB on LinuxPPC, &quot;very large&quot; on 64-bit
      implementations) block at startup and consuming (and
      relinquishing) its contents as the size of the live lisp heap
      data grows and shrinks. After the initial heap image loads and
      after each full GC, the lisp kernel will try to ensure that a
      specified amount (the &quot;lisp-heap-gc-threshold&quot;) of free memory
      is available. The initial value of this kernel variable is 16MB
      on 32-bit implementations and 32MB on 64-bit implementations ;
      it can be manipulated from Lisp (see below.)</para>
      <para>      The large reserved memory block consumes very little in
      the way of system resources; memory that's actually committed to
      the lisp heap (live data and the &quot;threshold&quot; area where
      allocation takes place) consumes finite resources (physical
      memory and swap space). The lisp's consumption of those
      resources is proportional to its actual memory usage, which is
      generally a good thing.</para>
      <para>      This scheme is much more flexible than the old one, but it
      may also increase the possibility that those resources can
      become exhausted.  Neither the new scheme nor the old handles
      that situation gracefully; under the old scheme, a program that
      consumes lots of memory may have run into an artificial limit on
      heap size before exhausting virtual memory.</para>
      <para>      The -R or -heap-reserve command-line option can be
      use to limit the size of the reserved block and therefore bound
      heap expansion. Running</para>
      <programlisting>
&gt; openmcl --heap-reserve 8M
</programlisting>
      <para>would provide an execution environment that's very similar to
that provided by earlier Clozure CL versions.</para>
    </section>
    <section id="ephemeral-gc">
      <title>Ephemeral GC</title>
      <para>For many programs, the following observations are true to
      a very large degree:</para>
      <blockquote>
        <orderedlist>
          <listitem><para>Most heap-allocated objects have very short lifetimes (&quot;are
	  ephemeral&quot;): they become inaccessible soon after they're created.</para></listitem>
          <listitem><para>Most non-ephemeral objects have very long lifetimes: it's
	  rarely productive for the GC to consider reclaiming them, since
	  it's rarely able to do so. (An object that has survived a large
	  number of GCs is likely to survive the next one. That's not always
	  true of course, but it's a reasonable heuristic.)</para></listitem>
          <listitem><para>It's relatively rare for an old object to be destructively
	  modified (via SETF) so that it points to a new one, therefore most
	  references to newly-created objects can be found in the stacks and
	  registers of active threads. It's not generally necessary to scan
	  the entire heap to find references to new objects (or to prove that
	  such references don't exists), though it is necessary to keep
	  track of the (hopefully exceptional) cases where old objects are
	  modified to point at new ones.</para></listitem>
        </orderedlist>
      </blockquote>
      <para>&quot;Ephemeral&quot; (or &quot;generational&quot;) garbage collectors try to
      exploit these observations: by concentrating on frequently
      reclaiming newly-created objects quickly, it's less often
      necessary to do more expensive GCs of the entire heap in order
      to reclaim unreferenced memory.  In some environments, the
      pauses associated with such full GCs can be noticeable and
      disruptive, and minimizing the frequency (and sometimes the
      duration) of these pauses is probably the EGC's primary goal
      (though there may be other benefits, such as increased locality
      of reference and better paging behavior.) The EGC generally
      leads to slightly longer execution times (and slightly higher,
      amortized GC time), but there are cases where it can improve
      overall performance as well; the nature and degree of its impact
      on performance is highly application-dependent.</para>
      <para>      Most EGC strategies (including the one employed by
      Clozure CL) logically or physically divide memory into one or more
      areas of relatively young objects (&quot;generations&quot;) and one or
      more areas of old objects.  Objects that have survived one or
      more GCs as members of a young generation are promoted (or
      &quot;tenured&quot;) into an older generation, where they may or may not
      survive long enough to be promoted to the next generation and
      eventually may become &quot;old&quot; objects that can only be reclaimed
      if a full GC proves that there are no live references to them.
      This filtering process isn't perfect - a certain amount of
      premature tenuring may take place - but it usually works very
      well in practice.</para>
      <para>      It's important to note that a GC of the youngest
      generation is typically very fast (perhaps a few milliseconds on
      a modern CPU, depending on various factors), Clozure CL's EGC is
      not concurrent and doesn't offer realtime guarantees.</para>
      <para>      Clozure CL's EGC maintains three ephemeral generations; all
      newly created objects are created as members of the youngest
      generation. Each generation has an associated
      <emphasis>threshold</emphasis>, which indicates the number of
      bytes in it and all younger generations that can be allocated
      before a GC is triggered. These GCs will involve the target
      generation and all younger ones (and may therefore cause some
      premature tenuring); since the older generations have larger
      thresholds, they're GCed less frequently and most short-lived
      objects that make it into an older generation tend not to
      survive there very long.</para>
      <para>      The EGC can be <emphasis>enabled</emphasis> or
      <emphasis>disabled</emphasis> under program control; under some
      circumstances, it may be enabled but
      <emphasis>inactive</emphasis> (because a full GC is imminent.)
      Since it may be hard to know or predict the consing behavior of
      other threads, the distinction between the &quot;active&quot; and
      &quot;inactive&quot; state isn't very meaningful, especially when native
      threads are involved.</para>
    </section>
    <section id="gc-page-reclamation-policy">
      <title>GC Page reclamation policy</title>
      <para>After a full GC finishes, it'll try to ensure that at
      least (LISP-HEAP-GC-THRESHOLD) of virtual memory are available;
      objects will be allocated in this block of memory until it fills
      up, the GC is triggered, and the process repeats itself.</para>
      <para>      Many programs reach near stasis in terms of the amount of
      logical memory that's in use after full GC (or run for long
      periods of time in a nearly static state), so the logical
      address range used for consing after the Nth full GC is likely
      to be nearly or entirely identical to the address range used by
      the N+1th full GC.</para>
      <para>      By default (and traditionally in Clozure CL), the GC's policy
      is to &quot;release&quot; the pages in this address range: to advise the
      virtual memory system that the pages contain garbage and any
      physical pages associated with them don't need to be swapped out
      to disk before being reused and to (re-)map the logical address
      range so that the pages will be zero-filled by the virtual
      memory system when they're next accessed.  This policy is
      intended to reduce the load on the VM system and keep Clozure CL's
      working set to a minimum.</para>
      <para>      For some programs (especially those that cons at a very
      high rate), the default policy may be less than ideal: releasing
      pages that are going to be needed almost immediately - and
      zero-fill-faulting them back in, lazily - incurs unnecessary
      overhead. (There's a false economy associated with minimizing
      the size of the working set if it's just going to shoot back up
      again until the next GC.) A policy of &quot;retaining&quot; pages between
      GCs might work better in such an environment.</para>
      <para>      Functions described below give the user some control over
      this behavior. An adaptive, feedback-mediated approach might
      yield a better solution.</para>
    </section>
    <section id="pure-areas-are-read-only-paged-from-image-file">
      <title>&quot;Pure&quot; areas are read-only, paged from image file</title>
      <para>SAVE-APPLICATION identifies code vectors and the pnames of
      interned symbols and copies these objects to a &quot;pure&quot; area of
      the image file it creates. (The &quot;pure&quot; area accounts for most of
      what the ROOM function reports as &quot;static&quot; space.)</para>
      <para>      When the resulting image file is loaded, the pure area of
      the file is now memory-mapped with read-only access. Code and
      pure data are paged in from the image file as needed (and don't
      compete for global virtual memory resources with other memory
      areas.)</para>
      <para>      Code-vectors and interned symbol pnames are immutable : it
      is an error to try to change the contents of such an
      object. Previously, that error would have manifested itself in
      some random way. In the new scheme, it'll manifest itself as an
      &quot;unhandled exception&quot; error in the Lisp kernel. The kernel could
      probably be made to detect a spurious, accidental write to
      read-only space and signal a lisp error in that case, but it
      doesn't yet do so.</para>
      <para>      The image file should be opened and/or mapped in some mode
      which disallows writing to the memory-mapped regions of the file
      from other processes. I'm not sure of how to do that; writing to
      the file when it's mapped by Clozure CL can have unpredictable and
      unpleasant results.  SAVE-APPLICATION will delete its output
      file's directory entry and create a new file; one may need to
      exercise care when using file system utilities (like tar, for
      instance) that might overwrite an existing image file.</para>
    </section>
    <section id="weak-references">
      <title>Weak References</title>
      <para>In general, a &quot;weak reference&quot; is a reference to an object
      which does not prevent the object from being garbage-collected.
      For example, suppose that you want to keep a list of all the
      objects of a certain type.  If you don't take special steps, the
      fact that you have a list of them will mean that the objects are
      always &quot;live&quot;, because you can always reference them through the
      list.  Therefore, they will never be garbage-collected, and
      their memory will never be reclaimed, even if they are
      referenced nowhere else in the program.  If you don't want this
      behavior, you need weak references.</para>
      <para>      Clozure CL supports weak references with two kinds of objects:
      weak hash tables and populations.</para>
      <para>      Weak hash tables are created with the standard Common Lisp
      function <literal>make-hash-table</literal>, which is extended
      to accept the keyword argument <literal>:weak</literal>.  Hash
      tables may be weak with respect to either their keys or their
      values.  To make a hash table with weak keys, invoke
      <literal>make-hash-table</literal> with the option :weak t, or,
      equivalently, :weak :key.  To make one with weak values, use
      :weak :value.  When the key is weak, the equality test must be
      #'eq (because it wouldn't make sense otherwise).</para>
      <para>      When garbage-collection occurs, key-value pairs are
      removed from the hash table if there are no non-weak references to
      the weak element of the pair (key or value).</para>
      <para>      In general, weak-key hash tables are useful when you want
      to use the hash to store some extra information about the
      objects you look up in it, while weak-value hash tables are
      useful when you want to use the hash as an index for looking up
      objects.</para>
      <para>      A population encapsulates an object, causing certain
      reference from the object to be considered weak.  Clozure CL supports
      two kinds of populations: lists, in which case the encapsulated
      object is a list of elements, which are spliced out of the list
      when there are no non-weak references to the element; and alists,
      in which case the encapsulated object is a list of conses which
      are spliced out of the list if there are no non-weak references
      to the car of the cons.</para>
      <para>      If you are experimenting with weak references
      interactively, remember that an object is not dead if it was
      returned by one of the last three interactively-evaluated
      expressions, because of the variables <literal>*</literal>,
      <literal>**</literal>, and <literal>***</literal>.  The easy
      workaround is to evaluate some meaningless expression before
      invoking <literal>gc</literal>, to get the object out of the
      REPL variables.</para>
    </section>
    <section id="weak-references-dictionary">
      <title>Weak References Dictionary</title>
      <refentry id="f_make-population">
        <indexterm zone="f_make-population"><primary><literal>MAKE-POPULATION</literal></primary></indexterm>
        <refnamediv>
          <refname>MAKE-POPULATION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>make-population <literal>&amp;key</literal> type initial-contents</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_make-population">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>type</parameter></term>
                <listitem><para>The type of population, one of <literal>:LIST</literal> (the default) or <literal>:ALIST</literal></para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>initial-contents</parameter></term>
                <listitem><para> A sequence of elements (or conses, for <literal>:alist</literal>) to be used to initialize the
              population. The sequence itself (and the conses in case of an
              alist) is not stored in the population, a new list or alist is created to hold the elements.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_make-population">
          <title>Description</title>
          <para>Creates a new population of the specified type.</para>
        </refsect1>
      </refentry>
      <refentry id="f_population-type">
        <indexterm zone="f_population-type"><primary><literal>POPULATION-TYPE</literal></primary></indexterm>
        <refnamediv>
          <refname>POPULATION-TYPE</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>population-type population</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_population-type">
          <title>Description</title>
          <para>returns the type of <literal>population</literal>, one of <literal>:LIST</literal> or <literal>:ALIST</literal></para>
        </refsect1>
      </refentry>
      <refentry id="f_population-contents">
        <indexterm zone="f_population-contents"><primary><literal>POPULATION-CONTENTS</literal></primary></indexterm>
        <refnamediv>
          <refname>POPULATION-CONTENTS</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>population-contents population</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_population-contents">
          <title>Description</title>
          <para>returns the list encapsulated in <literal>population</literal>.
        Note that as long as there is a direct (non-weak) reference to this
        list, it will not be modified by the garbage collector.  Therefore it is
        safe to traverse the list, and even modify it, no different from any
        other list. If you want the elements to become garbage-collectable
        again, you must stop refering to the list directly.</para>
        </refsect1>
      </refentry>
      <refentry id="f_setf_population-contents">
        <indexterm zone="f_setf_population-contents"><primary><literal>(SETF POPULATION-CONTENTS)</literal></primary></indexterm>
        <refnamediv>
          <refname>(SETF POPULATION-CONTENTS)</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>(setf ( population-contents population) contents)</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_setf_population-contents">
          <title>Description</title>
          <para>Sets the list encapsulated in <literal>population</literal> to
        <literal>contents</literal>.  <literal>Contents</literal> is not copied,
        it is used directly.</para>
        </refsect1>
      </refentry>
    </section>
    <section id="garbage-collection-dictionary">
      <title>Garbage-Collection Dictionary</title>
      <refentry id="f_gc">
        <indexterm zone="f_gc"><primary><literal>GC</literal></primary></indexterm>
        <refnamediv>
          <refname>GC</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>gc</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_gc">
          <title>Description</title>
          <para>Causes a full GC to occur as soon as possible. Returns NIL.</para>
        </refsect1>
      </refentry>
      <refentry id="f_lisp-heap-gc-threshold">
        <indexterm zone="f_lisp-heap-gc-threshold"><primary><literal>LISP-HEAP-GC-THRESHOLD</literal></primary></indexterm>
        <refnamediv>
          <refname>LISP-HEAP-GC-THRESHOLD</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>lisp-heap-gc-threshold</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_lisp-heap-gc-threshold">
          <title>Description</title>
          <para>Returns the value of the kernel variable that specifies the
	  amount of free space to leave in the heap after full GC.</para>
        </refsect1>
      </refentry>
      <refentry id="f_set-lisp-heap-gc-threshold">
        <indexterm zone="f_set-lisp-heap-gc-threshold"><primary><literal>SET-LISP-HEAP-GC-THRESHOLD</literal></primary></indexterm>
        <refnamediv>
          <refname>SET-LISP-HEAP-GC-THRESHOLD</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>set-lisp-heap-gc-threshold new-threshold</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_set-lisp-heap-gc-threshold">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>new-threshold</parameter></term>
                <listitem><para>The requested new lisp-heap-gc-threshold.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_set-lisp-heap-gc-threshold">
          <title>Description</title>
          <para>Sets the value of the kernel variable that specifies the
	  amount of free space to leave in the heap after full GC to
	  new-value, which should be a non-negative fixnum. Returns the
	  value of that kernel variable (which may be somewhat larger than
	  what was specified).</para>
        </refsect1>
      </refentry>
      <refentry id="f_use-lisp-heap-gc-threshold">
        <indexterm zone="f_use-lisp-heap-gc-threshold"><primary><literal>USE-LISP-HEAP-GC-THRESHOLD</literal></primary></indexterm>
        <refnamediv>
          <refname>USE-LISP-HEAP-GC-THRESHOLD</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>use-lisp-heap-gc-threshold</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_use-lisp-heap-gc-threshold">
          <title>Description</title>
          <para>Tries to grow or shrink lisp's heap space, so that the
	  free space is (approximately) equal to the current heap threshold.
	  Returns NIL</para>
        </refsect1>
      </refentry>
      <refentry id="f_egc">
        <indexterm zone="f_egc"><primary><literal>EGC</literal></primary></indexterm>
        <refnamediv>
          <refname>EGC</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>egc arg</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_egc">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>arg</parameter></term>
                <listitem><para>a generalized boolean</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_egc">
          <title>Description</title>
          <para>Enables the EGC if arg is non-nil, disables the EGC
	  otherwise. Returns the previous enabled status. Although this
	  function is thread-safe (in the sense that calls to it are
	  serialized), it doesn't make a whole lot of sense to be
	  turning the EGC on and off from multiple threads ...</para>
        </refsect1>
      </refentry>
      <refentry id="f_egc-enabled-p">
        <indexterm zone="f_egc-enabled-p"><primary><literal>EGC-ENABLED-P</literal></primary></indexterm>
        <refnamediv>
          <refname>EGC-ENABLED-P</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>egc-enabled-p</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_egc-enabled-p">
          <title>Description</title>
          <para>Returns T if the EGC was enabled at the time of the call,
	  NIL otherwise.</para>
        </refsect1>
      </refentry>
      <refentry id="f_egc-active-p">
        <indexterm zone="f_egc-active-p"><primary><literal>EGC-ACTIVE-P</literal></primary></indexterm>
        <refnamediv>
          <refname>EGC-ACTIVE-P</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>egc-active-p</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_egc-active-p">
          <title>Description</title>
          <para>Returns T if the EGC was active at the time of the call, NIL
	  otherwise. Since this is generally a volatile piece of
	  information, it's not clear whether this function serves a
	  useful purpose when native threads are involved.</para>
        </refsect1>
      </refentry>
      <refentry id="f_egc-configuration">
        <indexterm zone="f_egc-configuration"><primary><literal>EGC-CONFIGURATION</literal></primary></indexterm>
        <refnamediv>
          <refname>EGC-CONFIGURATION</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>egc-configuration</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_egc-configuration">
          <title>Description</title>
          <para>Returns, as multiple values, the sizes in kilobytes of the
	  thresholds associated with the youngest ephemeral generation, the
	  middle ephemeral generation, and the oldest ephemeral generation</para>
        </refsect1>
      </refentry>
      <refentry id="f_configure-egc">
        <indexterm zone="f_configure-egc"><primary><literal>CONFIGURE-EGC</literal></primary></indexterm>
        <refnamediv>
          <refname>CONFIGURE-EGC</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>configure-egc generation-0-size generation-1-size generation-2-size</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_configure-egc">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>generation-0-size</parameter></term>
                <listitem><para>the requested threshold size of the youngest
		generation, in kilobytes</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>generation-1-size</parameter></term>
                <listitem><para>the requested threshold size of the middle generation,
		in kilobytes</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>generation-2-size</parameter></term>
                <listitem><para>the requested threshold size of the oldest generation,
		in kilobytes</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_configure-egc">
          <title>Description</title>
          <para>Puts the indicated threshold sizes in effect.
          Each threshold indicates the total size that may be allocated
          in that and all younger generations before a GC is triggered.
          Disables EGC while setting the values.
	  (The provided threshold sizes are rounded up to a multiple of
	  64Kbytes in Clozure CL 0.14 and to a multiple of 32KBytes in earlier
	  versions.)</para>
        </refsect1>
      </refentry>
      <refentry id="f_gc-retain-pages">
        <indexterm zone="f_gc-retain-pages"><primary><literal>GC-RETAIN-PAGES</literal></primary></indexterm>
        <refnamediv>
          <refname>GC-RETAIN-PAGES</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>gc-retain-pages arg</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_gc-retain-pages">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>arg</parameter></term>
                <listitem><para>a generalized boolean</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_gc-retain-pages">
          <title>Description</title>
          <para>Tries to influence the GC to retain/recycle the pages
	  allocated between GCs if arg is true, and to release them
	  otherwise. This is generally a tradeoff between paging and other
	  VM considerations.</para>
        </refsect1>
      </refentry>
      <refentry id="f_gc-retaining-pages">
        <indexterm zone="f_gc-retaining-pages"><primary><literal>GC-RETAINING-PAGES</literal></primary></indexterm>
        <refnamediv>
          <refname>GC-RETAINING-PAGES</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>gc-retaining-pages</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_gc-retaining-pages">
          <title>Description</title>
          <para>Returns T if the GC tries to retain pages between full GCs
	  and NIL if it's trying to release them to improve VM paging
	  performance.</para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="implementation-details-of-clozure-cl">
    <title>Implementation Details of Clozure CL</title>
    <para>This chapter describes many aspects of OpenMCL's
    implementation as of (roughly) version 1.1. Details vary a bit
    between the three architectures (PPC32, PPC64, and x86-64)
    currently supported and those details change over time, so the
    definitive reference is the source code (especially some files in
    the ccl/compiler/ directory whose names contain the string &quot;arch&quot;
    and some files in the ccl/lisp-kernel/ directory whose names
    contain the string &quot;constants&quot;.) Hopefully, this chapter will make
    it easier for someone who's interested to read and understand the
    contents of those files.</para>
    <section id="threads-and-exceptions">
      <title>Threads and exceptions</title>
      <para>Clozure CL's threads are &quot;native&quot; (meaning that they're
        scheduled and controlled by the operating system.)  Most of the
        implications of this are discussed elsewhere; this section tries
        to describe how threads look from the lisp kernel's perspective
        (and especially from the GC's point of view.)</para>
      <para>        Clozure CL's runtime system tries to use machine-level
        exception mechanisms (conditional traps when available,
        illegal instructions, memory access protection in some cases)
        to detect and handle exceptional situations.  These situations
        include some TYPE-ERRORs and PROGRAM-ERRORS (notably
        wrong-number-of-args errors), and also include cases like &quot;not
        being able to allocate memory without GCing or obtaining more
        memory from the OS.&quot;  The general idea is that it's usually
        faster to pay (very occasional) exception-processing overhead
        and figure out what's going on in an exception handler than it
        is to maintain enough state and context to handle an
        exceptional case via a lighter-weight mechanism when that
        exceptional case (by definition) rarely occurs.</para>
      <para>        Some emulated execution environments (the Rosetta PPC
        emulator on x86 versions of Mac OS X) don't provide accurate
        exception information to exception handling functions. Clozure CL
        can't run in such environments.</para>
      <section id="the-thread-context-record">
        <title>The Thread Context Record</title>
        <para>When a lisp thread is first created (or when a thread
          created by foreign code first calls back to lisp), a data
          structure called a Thread Context Record (or TCR) is
          allocated and initialized.  On modern versions of Linux and
          FreeBSD, the allocation actually happens via a set of
          thread-local-storage ABI extensions, so a thread's TCR is
          created when the thread is created and dies when the thread
          dies.  (The World's Most Advanced Operating System-as
          Apple's marketing literature refers to Darwin-is not
          very advanced in this regard, and I know of no reason to
          assume that advances will be made in this area anytime
          soon.)</para>
        <para>          A TCR contains a few dozen fields (and is therefore a
          few hundred bytes in size.)  The fields are mostly
          thread-specific information about the thread's stacks'
          locations and sizes, information about the underlying (POSIX)
          thread, and information about the thread's dynamic binding
          history and pending CATCH/UNWIND-PROTECTs.  Some of this
          information could be kept in individual machine registers
          while the thread is running (and the PPC - which has more
          registers available - keeps a few things in registers that the
          X86-64 has to access via the TCR), but it's important to
          remember that the information is thread-specific and can't
          (for instance) be kept in a fixed global memory
          location.</para>
        <para>          When lisp code is running, the current thread's TCR is
          kept in a register.  On PPC platforms, a general purpose
          register is used; on x86-64, an (otherwise nearly useless)
          segment register works well (prevents the expenditure of a
          more generally useful general- purpose register for this
          purpose.)</para>
        <para>          The address of a TCR is aligned in memory in such a way
          that a FIXNUM can be used to represent it.  The lisp function
          CCL::%CURRENT-TCR returns the calling thread's TCR as a
          fixnum; actual value of the TCR's address is 4 or 8 times the
          value of this fixnum.</para>
        <para>          When the lisp kernel initializes a new TCR, it's added
          to a global list maintained by the kernel; when a thread
          exits, its TCR is removed from this list.</para>
        <para>          When a thread calls foreign code, lisp stack pointers
          are saved in its TCR, lisp registers (at least those whose
          value should be preserved across the call) are saved on the
          thread's value stack, and (on x86-64) RSP is switched to the
          control stack.  A field in the TCR (tcr.valence) is then set
          to indicate that the thread is running foreign code, foreign
          argument registers are loaded from a frame on the foreign
          stack, and the foreign function is called. (That's a little
          oversimplified and possibly inaccurate, but the important
          things to note are that the thread &quot;stops following lisp
          stack and register usage conventions&quot; and that it advertises
          the fact that it's done so.  Similar transitions in a
          thread's state (&quot;valence&quot;) occur when it enters or exits an
          exception handler (which is sort of an OS/hardware-mandated
          foreign function call where the OS thoughtfully saves the
          thread's register state for it beforehand.)</para>
      </section>
      <section id="exception-contexts-and-exception-handling-in-general">
        <title>Exception contexts, and exception-handling in general</title>
        <para>Unix-like OSes tend to refer to exceptions as &quot;signals&quot;;
          the same general mechanism (&quot;signal handling&quot;) is used to
          process both asynchronous OS-level events (such as the result
          of the keyboard driver noticing that ^C or ^Z has been
          pressed) and synchronous hardware-level events (like trying to
          execute an illegal instruction or access protected memory.)
          It makes some sense to defer (&quot;block&quot;) handling of
          asynchronous signals so that some critical code sequences
          complete without interruption; since it's generally not
          possible for a thread to proceed after a synchronous exception
          unless and until its state is modified by an exception
          handler, it makes no sense to talk about blocking synchronous
          signals (though some OSes will let you do so and doing so can
          have mysterious effects.)</para>
        <para>          On OSX/Darwin, the POSIX signal handling facilities
          coexist with lower-level Mach-based exception handling
          facilities.  Unfortunately, the way that this is implemented
          interacts poorly with debugging tools: GDB will generally stop
          whenever the target program encounters a Mach-level exception
          and offers no way to proceed from that point (and let the
          program's POSIX signal handler try to handle the exception);
          Apple's CrashReporter program has had a similar issue and,
          depending on how it's configured, may bombard the user with
          alert dialogs which falsely claim that an application has
          crashed (when in fact the application in question has
          routinely handled a routine exception.)  On Darwin/OSX,
          Clozure CL uses Mach thread-level exception handling facilities
          which run before GDB or CrashReporter get a chance to confuse
          themselves; Clozure CL's Mach exception handling tries to force
          the thread which received a synchronous exception to invoke a
          signal handling function (&quot;as if&quot; signal handling worked more
          usefully under Darwin.)  Mach exception handlers run in a
          dedicated thread (which basically does nothing but wait for
          exception messages from the lisp kernel, obtain and modify
          information about the state of threads in which exceptions
          have occurred, and reply to the exception messages with an
          indication that the exception has been handled.  The reply
          from a thread-level exception handler keeps the exception from
          being reported to GDB or CrashReporter and avoids the problems
          related to those programs.  Since Clozure CL's Mach exception
          handler doesn't claim to handle debugging-related exceptions
          (from breakpoints or single-step operations), it's possible to
          use GDB to debug Clozure CL.</para>
        <para>          On platforms where signal handling and debugging don't
          get in each other's way, a signal handler is entered with
          all signals blocked.  (This behavior is specified in the
          call to the sigaction() function which established the
          signal handler.)  The signal handler receives three
          arguments from the OS kernel; the first is an integer that
          identifies the signal, the second is a pointer to an object
          of type &quot;siginfo_t&quot;, which may or may not contain a few
          fields that would help to identify the cause of the
          exception, and the third argument is a pointer to a data
          structure (called a &quot;ucontext&quot; or something similar), which
          contains machine-dependent information about the state of
          the thread at the time that the exception/signal occurred.
          While asynchronous signals are blocked, the signal handler
          stores the pointer to its third argument (the &quot;signal
          context&quot;) in a field in the current thread's TCR, sets some
          bits in another TCR field to indicate that the thread is now
          waiting to handle an exception, unblocks asynchronous
          signals, and waits for a global exception lock that
          serializes exception processing.</para>
        <para>          On Darwin, the Mach exception thread creates a signal
          context (and maybe a siginfo_t structure), stores the signal
          context in the thread's TCR, sets the TCR field which describes
          the thread's state, and arranges that the thread resume
          execution at its signal handling function (with a signal
          handler, possibly NULL siginfo_t, and signal context as
          arguments.  When the thread resumes, it waits for the global
          exception lock.</para>
        <para>          On x86-64 platforms where signal handing can be used to
          handle synchronous exceptions, there's an additional
          complication: the OS kernel ordinarily allocates the signal
          context and siginfo structures on the stack of the thread
          that received the signal; in practice, that means &quot;wherever
          RSP is pointing.&quot;  Clozure CL's
          <xref linkend="register-and-stack-usage-conventions"/>
          require that the thread's value stack-where RSP is
          usually pointing while lisp code is running-contain
          only &quot;nodes&quot; (properly tagged lisp objects), and scribbling
          a signal context all over the value stack would violate this
          requirement.  To maintain consistency, the sigaltstack()
          mechanism is used to cause the signal to be delivered on
          (and the signal context and siginfo to be allocated on) a
          special stack area (the last few pages of the thread's
          control stack, in practice).  When the signal handler runs,
          it (carefully) copies the signal context and siginfo to the
          thread's control stack and makes RSP point into that stack
          before invoking the &quot;real&quot; signal handler. The effect of
          this hack is that the &quot;real&quot; signal handler always runs on
          the thread's control stack.</para>
        <para>          Once the exception handler has obtained the global
          exception lock, it uses the values of the signal number,
          siginfo_t, and signal context arguments to determine the
          (logical) cause of the exception.  Some exceptions may be
          caused by factors that should generate lisp errors or other
          serious conditions (stack overflow); if this is the case, the
          kernel code may release the global exception lock and call out
          to lisp code.  (The lisp code in question may need to repeat
          some of the exception decoding process; in particular, it
          needs to be able to interpret register values in the signal
          context that it receives as an argument.)</para>
        <para>          In some cases, the lisp kernel exception handler may not
          be able to recover from the exception (this is currently true
          of some types of memory-access fault and is also true of traps
          or illegal instructions that occur during foreign code
          execution.  In such cases, the kernel exception handler
          reports the exception as &quot;unhandled&quot;, and the kernel debugger
          is invoked.</para>
        <para>          If the kernel exception handler identifies the
          exception's cause as being a transient out-of-memory condition
          (indicating that the current thread needs more memory to cons
          in), it tries to make that memory available.  In some cases,
          doing so involves invoking the GC.</para>
      </section>
      <section id="threads-exceptions-and-the-gc">
        <title>Threads, exceptions, and the GC</title>
        <para>Clozure CL's GC is not concurrent: when the GC is invoked in
          response to an exception in a particular thread, all other
          lisp threads must stop until the GC's work is done.  The
          thread that triggered the GC iterates over the global TCR
          list, sending each other thread a distinguished &quot;suspend&quot;
          signal, then iterates over the list again, waiting for a
          per-thread semaphore that indicates that the thread has
          received the &quot;suspend&quot; signal and responded appropriately.
          Once all other threads have acknowledged the request to
          suspend themselves, the GC thread can run the GC proper (after
          doing any necessary <xref linkend="pc-lusering"/>.)  Once the
          GC's completed its work, the thread that invoked the GC
          iterates over the global TCR list, raising a per-thread
          &quot;resume&quot; semaphore for each other thread.</para>
        <para>          The signal handler for the asynchronous &quot;suspend&quot; signal
          is entered with all asynchronous signals blocked.  It saves
          its signal-context argument in a TCR slot, raises the tcr's
          &quot;suspend&quot; semaphore, then waits on the TCR's &quot;resume&quot;
          semaphore.</para>
        <para>          The GC thread has access to the signal contexts of all
          TCRs (including its own) at the time when the thread received
          an exception or acknowledged a request to suspend itself.
          This information (and information about stack areas in the TCR
          itself) allows the GC to identify the &quot;stack locations and
          register contents&quot; that are elements of the GC's root
          set.</para>
      </section>
      <section id="pc-lusering">
        <title>PC-lusering</title>
        <para>It's not quite accurate to say that Clozure CL's compiler
          and runtime follow precise stack and register usage
          conventions at all times; there are a few exceptions:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>On both PPC and x86-64 platforms, consing isn't
	          fully atomic.It takes at least a few instructions to
	          allocate an object in memory(and slap a header on it if
	          necessary); if a thread is interrupted in the middle of
	          that instruction sequence, the new object may or may
	          not have been created or fully initialized at the point in
	          time that the interrupt occurred.  (There are actually a
	          few different states of partial initialization)</para></listitem>
            <listitem><para>On the PPC, the common act of building a lisp
	          control stack frame involves allocating a four-word frame
	          and storing three register values into that frame.  (The
	          fourth word - the back pointer to the previous frame - is
	          automatically set when the frame is allocated.)  The
	          previous contents of those three words are unknown (there
	          might have been a foreign stack frame at the same address a
	          few instructions earlier),so interrupting a thread that's
	          in the process of initializing a PPC control stack frame
	          isn't GC-safe.</para></listitem>
            <listitem><para>There are similar problems with the initialization
	          of temp stackframes on the PPC.  (Allocation and
	          initialization doesn't happen atomically, and the newly
	          allocated stack memory may have undefined contents.)</para></listitem>
            <listitem><para><xref linkend="the-ephemeral-gc"/>'s write barrier
	          has to be implemented atomically (i.e.,both an
	          intergenerational store and the update of a
	          corresponding reference bit has to happen without
	          interruption, or neither of these events can
	          happen.)</para></listitem>
            <listitem><para>There are a few more similar cases.</para></listitem>
          </itemizedlist>
        </blockquote>
        <para>Fortunately, the number of these non-atomic instruction
          sequences is small, and fortunately it's fairly easy for the
          interrupting thread to recognize when the interrupted thread
          is in the middle of such a sequence.  When this is detected,
          the interrupting thread modifies the state of the interrupted
          thread (modifying its PC and other registers) so that it is no
          longer in the middle of such a sequence (it's either backed
          out of it or the remaining instructions are emulated.)</para>
        <para>          This works because (a) many of the troublesome
          instruction sequences are PPC-specific and it's relatively
          easy to partially disassemble the instructions surrounding the
          interrupted thread's PC on the PPC and (b) those instruction
          sequences are heavily stylized and intended to be easily
          recognized.</para>
      </section>
    </section>
    <section id="register-usage-and-tagging">
      <title>Register usage and tagging</title>
      <section id="overview_in_register-usage-and-tagging">
        <title>Overview</title>
        <para>Regardless of other details of its implementation, a
	      garbage collector's job is to partition the set of all
	      heap-allocated lisp objects (CONSes, STRINGs, INSTANCEs, etc.)
	      into two subsets.  The first subset contains all objects that
	      are transitively referenced from a small set of &quot;root&quot; objects
	      (the contents of the stacks and registers of all active
	      threads at the time the GC occurs and the values of some
	      global variables.)  The second subset contains everything
	      else: those lisp objects that are not transitively reachable
	      from the roots are garbage, and the memory occupied by garbage
	      objects can be reclaimed (since the GC has just proven that
 	      it's impossible to reference them.)</para>
        <para>          The set of live, reachable lisp objects basically form
          the nodes of a (usually large) graph, with edges from each
          node A to any other objects (nodes) that object A
          references.</para>
        <para>          Some nodes in this graph can never have outgoing edges:
          an array with a specialized numeric or character type usually
          represents its elements in some (possibly more compact)
          specialized way.  Some nodes may refer to lisp objects that
          are never allocated in memory (FIXNUMs, CHARACTERs,
          SINGLE-FLOATs on 64-bit platforms ..)  This latter class of
          objects are sometimes called &quot;immediates&quot;, but that's a little
          confusing because the term &quot;immediate&quot; is sometimes used to
          refer to things that can never be part of the big connectivity
          graph (e.g., the &quot;raw&quot; bits that make up a floating-point
          value, foreign address, or numeric value that needs to be used
          - at least fleetingly - in compiled code.)</para>
        <para>          For the GC to be able to build the connectivity graph
          reliably, it's necessary for it to be able to reliably tell
          (a) whether or not a &quot;potential root&quot; - the contents of a
          machine register or stack location - is in fact a node and (b)
          for any node, whether it may have components that refer to
          other nodes.</para>
        <para>          There's no reliable way to answer the first question on
          stock hardware.  (If everything was a node, as might be the
          case on specially microcoded &quot;lisp machine&quot; hardware, it
          wouldn't even need to be asked.)  Since there's no way to just
          look at a machine word (the contents of a machine register or
          stack location) and tell whether or not it's a node or just
          some random non-node value, we have to either adopt and
          enforce strict conventions on register and stack usage or
          tolerate ambiguity.</para>
        <para>          &quot;Tolerating ambiguity&quot; is an approach taken by some
          (&quot;conservative&quot;) GC schemes; by contrast, Clozure CL's GC is
          &quot;precise&quot;, which in this case means that it believes that the
          contents of certain machine registers and stack locations are
          always nodes and that other registers and stack locations are
          never nodes and that these conventions are never violated by
          the compiler or runtime system.  The fact that threads are
          preemptively scheduled means that a GC could occur (because of
          activity in some other thread) on any instruction boundary,
          which in turn means that the compiler and runtime system must
          follow precise <xref linkend="register-and-stack-usage-conventions"/> at all
          times.</para>
        <para>          Once we've decided that a given machine word is a node,
          a <xref linkend="tagging-scheme"/> describes how the node's
          value and type are encoded in that machine word.</para>
        <para>          Most of this discussion-so far-has treated
          things from the GC's very low-level perspective. From a much
          higher point of view, lisp functions accept nodes as
          arguments, return nodes as values, and (usually) perform
          some operations on those arguments in order to produce those
          results.  (In many cases, the operations in question involve
          raw non-node values.)  Higher-level parts of the lisp type
          system (functions like TYPE-OF and CLASS-OF, etc.) depend on
          the <xref linkend="tagging-scheme"/>.</para>
      </section>
      <section id="pc-locatives-on-the-ppc">
        <title>pc-locatives on the PPC</title>
        <para>On the PPC, there's a third case (besides &quot;node&quot; and
          &quot;immediate&quot; values).  As discussed below, a node that denotes
          a memory-allocated lisp object is a biased (tagged) pointer
          -to- that object; it's not generally possible to point -into-
          some composite (multi-element) object (such a pointer would
          not be a node, and the GC would have no way to update the
          pointer if it were to move the underlying object.)</para>
        <para>          Such a pointer (&quot;into&quot; the interior of a heap-allocated
          object) is often called a <emphasis>locative</emphasis>; the
          cases where locatives are allowed in Clozure CL mostly involve
          the behavior of function call and return instructions.  (To be
          technically accurate, the other case also arises on x86-64, but
          that case isn't as user-visible.)</para>
        <para>          On the PowerPC (both PPC32 and PPC64), all machine
          instructions are 32 bits wide and all instruction words are
          allocated on 32-bit boundaries.  In PPC Clozure CL, a CODE-VECTOR
          is a specialized type of vector-like object; its elements
          are 32-bit PPC machine instructions.  A CODE-VECTOR is an
          attribute of a FUNCTION object; a function call involves
          accessing the function's code-vector and jumping to the
          address of its first instruction.</para>
        <para>          As each instruction in the code vector sequentially
          executes, the hardware program counter (PC) register advances
          to the address of the next instruction (a locative into the
          code vector); since PPC instructions are always 32 bits wide
          and aligned on 32-bit boundaries, the low two bits of the PC
          are always 0.  If the function executes a call (simple call
          instructions have the mnemonic &quot;bl&quot; on the PPC, which stands
          for &quot;branch and link&quot;), the address of the next instruction
          (also a word-aligned locative into a code-vector) is copied
          into the special- purpose PPC &quot;link register&quot; (lr); a function
          returns to its caller via a &quot;branch to link register&quot; (blr)
          instruction.  Some cases of function call and return might
          also use the PPC's &quot;count register&quot; (ctr), and if either the
          lr or ctr needs to be stored in memory it needs to first be
          copied to a general-purpose register.</para>
        <para>          Clozure CL's GC understands that certain registers contain
          these special &quot;pc-locatives&quot; (locatives that point into
          CODE-VECTOR objects); it contains special support for
          finding the containing CODE-VECTOR object and for adjusting
          all of these &quot;pc-locatives&quot; if the containing object is
          moved in memory.  The first part of that
          operation-finding the containing object-is
          possible and practical on the PPC because of architectural
          artifacts (fixed-width instructions and arcana of
          instruction encoding.)  It's not possible on x86-64, but
          fortunately not necessary either (though the second part -
          adjusting the PC/RIP when the containing object moves) is
          both necessary and simple.</para>
      </section>
      <section id="register-and-stack-usage-conventions">
        <title>Register and stack usage conventions</title>
        <section id="stack-conventions">
          <title>Stack conventions</title>
          <para>On both PPC and X86 platforms, each lisp thread uses 3
            stacks; the ways in which these stacks are used differs
            between the PPC and X86.</para>
          <para>Each thread has:</para>
          <blockquote>
            <itemizedlist>
              <listitem><para>A &quot;control stack&quot;.  On both platforms, this is
	            &quot;the stack&quot; used by foreign code.  On the PPC, it
	            consists of a linked list of frames where the first word
	            in each frame points to the first word in the previous
	            frame (and the outermost frame points to 0.)  Some
	            frames on a PPC control stack are lisp frames; lisp
	            frames are always 4 words in size and contain (in
	            addition to the back pointer to the previous frame) the
	            calling function (a node), the return address (a
	            &quot;locative&quot; into the calling function's code-vector), and
	            the value to which the value-stack pointer (see below)
	            should be restored on function exit.  On the PPC, the GC
	            has to look at control-stack frames, identify which of
	            those frames are lisp frames, and treat the contents of
	            the saved function slot as a node (and handle the return
	            address locative specially.)  On x86-64, the control
	            stack is used for dynamic-extent allocation of immediate
	            objects.  Since the control stack never contains nodes
	            on x86-64, the GC ignores it on that platform.
	            Alignment of the control stack follows the ABI
	            conventions of the platform (at least at any point in
	            time where foreign code could run.)  On PPC, the r1
	            register always points to the top of the current
	            thread's control stack; on x86-64, the RSP register
	            points to the top of the current thread's control stack
	            when the thread is running foreign code and the address
	            of the top of the control stack is kept in the thread's
	            TCR (see <xref linkend="the-thread-context-record"/>
	            when not running foreign code.  The control stack &quot;grows
	            down.&quot;</para></listitem>
              <listitem><para>A &quot;value stack&quot;.  On both platforms, all values on
	            the value stack are nodes (including &quot;tagged return
	            addresses&quot; on x86-64.)  The value stack is always
	            aligned to the native word size; objects are always
	            pushed on the value stack using atomic instructions
	            (&quot;stwu&quot;/&quot;stdu&quot; on PPC, &quot;push&quot; on x86-64), so the
	            contents of the value stack between its bottom and top
	            are always unambiguously nodes; the compiler usually
	            tries to pop or discard nodes from the value stack as
	            soon as possible after their last use (as soon as they
	            may have become garbage.)  On x86-64, the RSP register
	            addresses the top of the value stack when running lisp
	            code; that address is saved in the TCR when running
	            foreign code.  On the PPC, a dedicated register (VSP,
	            currently r15) is used to address the top of the value
	            stack when running lisp code, and the VSP value is saved
	            in the TCR when running foreign code.  The value stack
	            grows down.</para></listitem>
              <listitem><para>A &quot;temp stack&quot;.  The temp stack consists of a
	            linked list of frames, each of which points to the
	            previous temp stack frame.  The number of native
	            machine words in each temp stack frame is always even,
	            so the temp stack is aligned on a two-word (64- or
	            128-bit) boundary.  The temp stack is used for
	            dynamic-extent objects on both platforms; on the PPC,
	            it's used for essentially all such objects (regardless
	            of whether or not the objects contain nodes); on the
	            x86-64, immediate dynamic-extent objects (strings,
	            foreign pointers, etc.)  are allocated on the control
	            stack and only node-containing dynamic-extent objects
	            are allocated on the temp stack.  Data structures used
	            to implement CATCH and UNWIND-PROTECT are stored on
	            the temp stack on both ppc and x86-64.  Temp stack
	            frames are always doublenode aligned and objects
	            within a temp stack frame are aligned on doublenode
	            boundaries.  The first word in each frame contains a
	            back pointer to the previous frame; on the PPC, the
	            second word is used to indicate to the GC whether the
	            remaining objects are nodes (if the second word is 0)
	            or immediate (otherwise.)  On x86-64, where temp stack
	            frames always contain nodes, the second word is always
	            0.  The temp stack grows down.  It usually takes
	            several instructions to allocate and safely initialize
	            a temp stack frame that's intended to contain nodes,
	            and the GC has to recognize the case where a thread is
	            in the process of allocating and initializing a temp
	            stack frame and take care not to interpret any
	            uninitialized words in the frame as nodes. The PPC
	            keeps the current top of the temp stack in a dedicated
	            register (TSP, currently r12) when running lisp code
	            and saves this register's value in the TCR when
	            running foreign code.  The x86-64 keeps the address of
	            the top of each thread's temp stack in the thread's
	            TCR.</para></listitem>
            </itemizedlist>
          </blockquote>
        </section>
        <section id="register-conventions">
          <title>Register conventions</title>
          <para>If there are a &quot;reasonable&quot; (for some value of
            &quot;reasonable&quot;) number of general-purpose registers and the
            instruction set is &quot;reasonably&quot; orthogonal (most
            instructions that operate on GPRs can operate on any GPR),
            then it's possible to statically partition the GPRs into at
            least two sets: &quot;immediate registers&quot; never contain nodes,
            and &quot;node registers&quot; always contain nodes.  (On the PPC, a
            few registers are members of a third set of &quot;PC locatives&quot;,
            and on both platforms some registers may have dedicated
            roles as stack or heap pointers; the latter class is treated
            as immediates by the GC proper but may be used to help
            determine the bounds of stack and heap memory areas.)</para>
          <para>            The ultimate definition of register partitioning is
            hardwired into the GC in functions like &quot;mark_xp()&quot; and
            &quot;forward_xp()&quot;, which process the values of some of the
            registers in an exception frame as nodes and may give some
            sort of special treatment to other register values they
            encounter there.)</para>
          <para>On x86-64, the static register partitioning scheme involves:</para>
          <blockquote>
            <itemizedlist>
              <listitem><para>(only) three &quot;immediate&quot; registers.</para><para>	            The RAX, RCX, and RDX registers are used as the
	            implicit operands and results of some extended-precision
	            multiply and divide instructions which generally involve
	            non-node values; since their use in these instructions
	            means that they can't be guaranteed to contain node
	            values at all times, it's natural to put these registers
	            in the &quot;immediate&quot; set. RAX is generally given the
	            symbolic name &quot;imm0&quot;, RDX is given the symbolic name
	            &quot;imm1&quot; and RCX is given the symbolic name &quot;imm2&quot;; you
	            may see these names in disassembled code, usually in
	            operations involving type checking, array indexing, and
	            foreign memory and function access.</para></listitem>
              <listitem><para>(only) two &quot;dedicated&quot; registers.</para><para>	            RSP and RBP have
	            dedicated functionality dictated by the hardware and
	            calling conventions.</para></listitem>
              <listitem><para>11 &quot;node&quot; registers.</para><para>	            All other registers (RBX, RSI, RDI, and R8-R15)
	            are asserted to contain node values at (almost) all
	            times; legacy &quot;string&quot; operations that implicitly use RSI
	            and/or RDI are not used.</para></listitem>
            </itemizedlist>
          </blockquote>
          <para>
		On 32-bit x86, the default register partitioning scheme
		involves:
	      </para>
          <blockquote>
            <itemizedlist>
              <listitem><para>
		  A single &quot;immediate&quot; register.</para><para>		    The EAX register is given the symbolic name
		    &quot;imm0&quot;.
		  </para></listitem>
              <listitem><para>
		    There are two &quot;dedicated&quot; registers.</para><para>		    ESP and EBP have dedicated functionality dictated by the
		    hardware and calling conventions.
		  </para></listitem>
              <listitem><para>
		    5 &quot;node&quot; registers.</para><para>		    The remaining registers, (EBX, ECX, EDX, ESI, EDI) normally
		    contain node values.  As on x86-64, string instructions
		    that implicity use ESI and EDI are not used.
		  </para></listitem>
            </itemizedlist>
          </blockquote>
          <para>
		There are times when this default partitioning scheme is
		inadequate.  As mentioned in the x86-64 section, there are
		instructions like the extended-precision MUL and DIV which
		require the use of EAX and EDX.  We therefore need a way to
		change this partitioning at run-time.</para>
          <para>		Two schemes are employed.  The first uses a mask in the TCR
		that contains a bit for each register.  If the bit is set,
		the register is interpreted by the GC as a node register; if it's
		clear, the register is treated as an immediate register.  The
		second scheme uses the direction flag in the EFLAGS register.
		If DF is set, EDX is treated as an immediate register.
		(We don't use the string instructions, so DF isn't otherwise
		used.)</para>
          <para>            On the PPC, the static register partitioning scheme
            involves:</para>
          <blockquote>
            <itemizedlist>
              <listitem><para>6 &quot;immediate&quot; registers.</para><para>	            Registers r3-r8 are given
	            the symbolic names imm0-imm5.  As a RISC architecture
	            with simpler addressing modes, the PPC probably
	            uses immediate registers a bit more often than the CISC
	            x86-64 does, but they're generally used for the same sort
	            of things (type checking, array indexing, FFI,
	            etc.)</para></listitem>
              <listitem><para>9 dedicated registers
	            </para><blockquote><itemizedlist><listitem><para>r0 (symbolic name rzero) always contains the
		              value 0 when running lisp code.  Its value is
		              sometimes read as 0 when it's used as the base
		              register in a memory address; keeping the value 0
		              there is sometimes convenient and avoids
		              asymmetry.</para></listitem><listitem><para>r1 (symbolic name sp) is the control stack
		              pointer, by PPC convention.</para></listitem><listitem><para>r2 is used to hold the current thread's TCR on
		              ppc64 systems; it's not used on ppc32.</para></listitem><listitem><para>r9 and r10 (symbolic names allocptr and
		              allocbase) are used to do per-thread memory
		              allocation</para></listitem><listitem><para>r11 (symbolic name nargs) contains the number
		              of function arguments on entry and the number of
		              return values in multiple-value returning
		              constructs.  It's not used more generally as either
		              a node or immediate register because of the way that
		              certain trap instruction encodings are
		              interpreted.</para></listitem><listitem><para>r12 (symbolic name tsp) holds the top of the
		              current thread's temp stack.</para></listitem><listitem><para>r13 is used to hold the TCR on PPC32 systems;
		              it's not used on PPC64.</para></listitem><listitem><para>r14 (symbolic name loc-pc) is used to copy
		              &quot;pc-locative&quot; values between main memory and
		              special-purpose PPC registers (LR and CTR) used in
		              function-call and return instructions.</para></listitem><listitem><para>r15 (symbolic name vsp) addresses the top of
		              the current thread's value stack.</para></listitem><listitem><para>lr and ctr are PPC branch-unit registers used
		              in function call and return instructions; they're
		              always treated as &quot;pc-locatives&quot;, which precludes
		              the use of the ctr in some PPC looping
		              constructs.</para></listitem></itemizedlist></blockquote></listitem>
              <listitem><para>17 &quot;node&quot; registers</para><para>	            r15-r31 are always treated as node
	            registers</para></listitem>
            </itemizedlist>
          </blockquote>
        </section>
      </section>
      <section id="tagging-scheme">
        <title>Tagging scheme</title>
        <para>Clozure CL always allocates lisp objects on double-node
          (64-bit for 32-bit platforms, 128-bit for 64-bit platforms)
          boundaries; this mean that the low 3 bits (32-bit lisp) or 4
          bits (64-bit lisp) are always 0 and are therefore redundant
          (we only really need to know the upper 29 or 60 bits in order
          to identify the aligned object address.)  The extra bits in a
          lisp node can be used to encode at least some information
          about the node's type, and the other 29/60 bits represent
          either an immediate value or a doublenode-aligned memory
          address.  The low 3 or 4 bits of a node are called the node's
          &quot;tag bits&quot;, and the conventions used to encode type
          information in those tag bits are called a &quot;tagging
          scheme.&quot;</para>
        <para>          It might be possible to use the same tagging scheme on
          all platforms (at least on all platforms with the same word
          size and/or the same number of available tag bits), but there
          are often some strong reasons for not doing so.  These
          arguments tend to be very machine-specific: sometimes, there
          are fairly obvious machine-dependent tricks that can be
          exploited to make common operations on some types of tagged
          objects faster; other times, there are architectural
          restrictions that make it impractical to use certain tags for
          certain types.  (On PPC64, the &quot;ld&quot; (load doubleword) and
          &quot;std&quot; (store doubleword) instructions - which load and store a
          GPR operand at the effective address formed by adding the
          value of another GPR operand and a 16-bit constant operand -
          require that the low two bits of that constant operand be 0.
          Since such instructions would typically be used to access the
          fields of things like CONS cells and structures, it's
          desirable that that the tags chosen for CONS cells and
          structures allow the use of these instructions as opposed to
          more expensive alternatives.)</para>
        <para>          One architecture-dependent tagging trick that works well
          on all architectures is to use a tag of 0 for FIXNUMs: a
          fixnum basically encodes its value shifted left a few bits
          and keeps those low bits clear. FIXNUM addition,
          subtraction, and binary logical operations can operate
          directly on the node operands, addition and subtraction can
          exploit hardware-based overflow detection, and (in the
          absence of overflow) the hardware result of those operations
          is a node (fixnum).  Some other slightly-less-common
          operations may require a few extra instructions, but
          arithmetic operations on FIXNUMs should be as cheap as
          possible and using a tag of zero for FIXNUMs helps to ensure
          that it will be.</para>
        <para>	      If we have N available tag bits (N = 3 for 32-bit Clozure CL
	      and N = 4 for 64-bit Clozure CL), this way of representing
	      fixnums with the low M bits forced to 0 works as long as M
	      &lt;= N.  The smaller we make M, the larger the values of
	      MOST-POSITIVE-FIXNUM and MOST-NEGATIVE become; the larger we
	      make N, the more distinct non-FIXNUM tags become available.
	      A reasonable compromise is to choose M = N-1; this basically
	      yields two distinct FIXNUM tags (one for even fixnums, one
	      for odd fixnums), gives 30-bit fixnums on 32-bit platforms
	      and 61-bit fixnums on 64-bit platforms, and leaves us with 6
	      or 14 tags to encoded other types.</para>
        <para>          Once we get past the assignment of FIXNUM tags, things
          quickly devolve into machine-dependencies.  We can fairly
          easily see that we can't directly tag all other primitive
          lisp object types with only 6 or 14 available tag values;
          the details of how types are encoded vary between the ppc32,
          ppc64, and x86-64 implementations, but there are some
          general common principles:</para>
        <blockquote>
          <itemizedlist>
            <listitem><para>CONS cells always contain exactly 2 elements and are
	          usually fairly common.It therefore makes sense to give
	          CONS cells their own tag.  Unlike the fixnum case -
	          where a tag value of 0 had positive implications - there
	          doesn't seem to be any advantage to using any particular
	          value.  (A longtime ago - in the case of 68K MCL - the
	          CONS tag and the order of CAR and CDR in memory were
	          chosen to allow smaller, cheaper addressing modes to be
	          used to &quot;cdr down a list.&quot;  That's not a factor on ppc
	          or x86-64, but all versions of Clozure CL still store the CDR
	          of a CONS cell first in memory.  It doesn't matter, but
	          doing it the way that the host system did made
	          boostrapping to a new target system a little easier.)
	        </para></listitem>
            <listitem><para>Any way you look at it, NIL is a bit
	          ... unusual. NIL is both a SYMBOL and a LIST (as well as
	          being a canonical truth value and probably a few other
	          things.)  Its role as a LIST is probably much more
	          important to most programs than its role as a SYMBOL is:
	          LISTP has to be true of NIL and primitives like CAR and
	          CDR do LISTP implicitly when safe and want that
	          operation to be fast. There are several possible
	          approaches to this problem; Clozure CL uses two of them. On
	          PPC32 and X86-64, NIL is basically a weird CONS cell
	          that straddles two doublenodes; the tag of NIL is unique
	          and congruent modulo 4 (modulo 8 on 64-bit) with the tag
	          used for CONS cells.  LISTP is therefore true of any
	          node whose low 2 (or 3) bits contain the appropriate tag
	          value (it's not otherwise necessary to special-case
	          NIL.)  SYMBOL accessors (SYMBOL-NAME, SYMBOL-VALUE,
	          SYMBOL-PLIST ..) -do- have to special-case NIL (and
	          access the components of an internal proxy symbol.) On
	          PPC64 (where architectural restrictions dictate the set
	          of tags that can be used to access fixed components of
	          an object), that approach wasn't practical.  NIL is just
	          a distinguished SYMBOL,and it just happens to be the
	          case that its pname slot and values slot are at the same
	          offsets from a tagged pointer as a CONS cell's CDR and
	          CAR would be.  NIL's pname is set to NIL (SYMBOL-NAME
	          checks for this and returns the string &quot;NIL&quot;), and LISTP
	          (and therefore safe CAR and CDR) has to check for (OR
	          NULL CONSP). At least in the case of CAR and CDR, the
	          fact that the PPC has multiple condition-code fields
	          keeps that extra test from being prohibitively
	          expensive.  On IA-32, we can't afford to dedicate a tag to
		  NIL. NIL is therefore just a distinguished CONS
		  cell, and we have to explicitly check for a NIL argument
		  in CONSP/RPLACA/RPLACD.
		</para></listitem>
            <listitem><para>Some objects are immediate (but not FIXNUMs). This
	          is true of CHARACTERs and, on 64-bit platforms,
	          SINGLE-FLOATs. It's also true of some nodes used in the
	          runtime system (special values used to indicate unbound
	          variables and slots, for instance.) On 64-bit platforms,
	          SINGLE-FLOATs have their own unique tag (making them a
	          little easier to recognize; on all platforms, CHARACTERs
	          share a tag with other immediate objects (unbound
	          markers) but are easy to recognize (by looking at
	          several of their low bits.)  The GC treats any node with
	          an immediate tag (and any node with a fixnum tag) as a
	          leaf.</para></listitem>
            <listitem><para>There are some advantages to treating everything
	          else-memory-allocated objects that aren't CONS
	          cells-uniformly.There are some disadvantages to
	          that uniform treatment as well, and the treatment of
	          &quot;memory-allocated non-CONS objects&quot; isn't entirely
	          uniform across all Clozure CL implementations.  Let's first
	          pretend that the treatment is uniform, then discuss the
	          ways in which it isn't.The &quot;uniform approach&quot; is to
	          treat all memory-allocated non-CONS objects as if they
	          were vectors; this use of the term is a little looser
	          than what's implied by the CL VECTOR type.  Clozure CL
	          actually uses the term &quot;uvector&quot; to mean &quot;a
	          memory-allocated lisp object other than a CONS cell,
	          whose first word is a header that describes the object's
	          type and the number of elements that it contains.&quot;  In
	          this view, a SYMBOL is a UVECTOR, as is a STRING, a
	          STANDARD-INSTANCE, a CL array or vector, a FUNCTION, and
	          even a DOUBLE-FLOAT. In the PPC implementations (where
	          things are a little more ... uniform), a single tag
	          value is used to denote any uvector; in order to
	          determine something more specific about the type of the
	          object in question, it's necessary to fetch the low byte
	          of the header word from memory.  On the x86-64 platform,
	          certain types of uvectors - SYMBOLs and FUNCTIONs -are
	          given their own unique tags.  The good news about the
	          x86-64 approach is that SYMBOLs and FUNCTIONs can be
	          recognized without referencing memory; the slightly bad
	          news is that primitive operations that work on
	          UVECTOR-tagged objects-like the function
	          CCL:UVREF-don't work on SYMBOLs or FUNCTIONs on
	          x86-64 (but -do- work on those types of objects in the
	          PPC ports.) The header word that precedes a UVECTOR's
	          data in memory contains 8 bits of type information in
	          the low byte and either 24 or 56 bits of &quot;element-count&quot;
	          information in the rest of the word.  (This is where the
	          sometimes-limiting value of 2^24 for
	          ARRAY-TOTAL-SIZE-LIMIT on 32-bit platforms comes from.)
	          The low byte of the header-sometimes called the
	          uvector's subtag-is itself tagged (which means
	          that the header is tagged.)  The (3 or 4) tag bits in
	          the subtag are used to determine whether the uvector's
	          elements are nodes or immediates. (A UVECTOR whose
	          elements are nodes is called a GVECTOR; a UVECTOR whose
	          elements are immediates is called an IVECTOR.  This
	          terminology came from Spice Lisp, which was a
	          predecessor of CMUCL.)  Even though a uvector header is
	          tagged, a header is not a node.  There's no (supported)
	          way to get your hands on one in lisp and doing so could
	          be dangerous.  (If the value of a header wound up in a
	          lisp node register and that register wound up getting
	          pushed on a thread's value stack, the GC might
	          misinterpret that situation to mean that there was a
	          stack-allocated UVECTOR on the value stack.)</para></listitem>
          </itemizedlist>
        </blockquote>
      </section>
    </section>
    <section id="heap-allocation">
      <title>Heap Allocation</title>
      <para>When the Clozure CL kernel first
        starts up, a large contiguous chunk of the process's address
        space is mapped as &quot;anonymous, no access&quot; memory. (&quot;Large&quot;
        means different things in different contexts; on LinuxPPC32,
        it means &quot;about 1 gigabyte&quot;, on DarwinPPC32, it means &quot;about 2
        gigabytes&quot;, and on current 64-bit platforms it ranges from 128
        to 512 gigabytes, depending on OS. These values are both
        defaults and upper limits;
        the <literal>--heap-reserve</literal> argument can be used to
        try to reserve less than the default.)</para>
      <para>        Reserving address space that can't (yet) be read or
        written to doesn't cost much; in particular, it doesn't require
        that corresponding swap space or physical memory be available.
        Marking the address range as being &quot;mapped&quot; helps to ensure that
        other things (results from random calls to malloc(), dynamically
        loaded shared libraries) won't be allocated in this region that
        lisp has reserved for its own heap growth.</para>
      <para>        A small portion (around 1/32 on 32-bit platforms and 1/64
        on 64-bit platforms) of that large chunk of address space is
        reserved for GC data structures.  Memory pages reserved for
        these data structures are mapped read-write as pages are made
        writable in the main portion of the heap.</para>
      <para>        The initial heap image is mapped into this reserved
        address space and an additional (LISP-HEAP-GC-THRESHOLD) bytes
        are mapped read-write.  GC data structures grow to match the
        amount of GC-able memory in the initial image plus the gc
        threshold, and control is transferred to lisp code.
        Inevitably, that code spoils everything and starts consing;
        there are basically three layers of memory allocation that can
        go on.</para>
      <section id="per-thread-object-allocation">
        <title>Per-thread object allocation</title>
        <para>Each lisp thread has a private &quot;reserved memory
          segment&quot;; when a thread starts up, its reserved memory segment
          is empty.  PPC ports maintain the highest unallocated address
          and the lowest allocatable address in the current segment in
          registers when running lisp code; on x86-664, these values are
          maintained in the current threads's TCR.  (An &quot;empty&quot; heap
          segment is one whose high pointer and low pointer are equal.)
          When a thread is not in the middle of allocating something, the
          low 3 or 4 bits of the high and low pointers are clear (the
          pointers are doublenode-aligned.)</para>
        <para>          A thread tries to allocate an object whose physical size
          in bytes is X and whose tag is Y by:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>decrementing the &quot;high&quot; pointer by (- X Y)</para></listitem>
            <listitem><para>trapping if the high pointer is less than the low
	          pointer</para></listitem>
            <listitem><para>using the (tagged) high pointer to initialize the
	          object, if necessary</para></listitem>
            <listitem><para>clearing the low bits of the high pointer</para></listitem>
          </orderedlist>
        </blockquote>
        <para>On PPC32, where the size of a CONS cell is 8 bytes and
          the tag of a CONS cell is 1, machine code which sets the arg_z
          register to the result of doing (CONS arg_y arg_z) looks
          like:</para>
        <programlisting>
  (SUBI ALLOCPTR ALLOCPTR 7)    ; decrement the high pointer by (- 8 1)
  (TWLLT ALLOCPTR ALLOCBASE)    ; trap if the high pointer is below the base
  (STW ARG_Z -1 ALLOCPTR)       ; set the CDR of the tagged high pointer
  (STW ARG_Y 3 ALLOCPTR)        ; set the CAR
  (MR ARG_Z ALLOCPTR)           ; arg_z is the new CONS cell
  (RLWINM ALLOCPTR ALLOCPTR 0 0 28)     ; clear tag bits
	    </programlisting>
        <para>On x86-64, the idea's similar but the implementation is
          different.  The high and low pointers to the current thread's
          reserved segment are kept in the TCR, which is addressed by
          the gs segment register. An x86-64 CONS cell is 16 bytes wide
          and has a tag of 3; we canonically use the temp0 register to
          initialize the object</para>
        <programlisting>
  (subq ($ 13) ((% gs) 216))    ; decrement allocptr
  (movq ((% gs) 216) (% temp0)) ; load allocptr into temp0
  (cmpq ((% gs) 224) (% temp0)) ; compare to allocabase
  (jg L1)                       ; skip trap
  (uuo-alloc)                   ; uh, don't skip trap
L1
  (andb ($ 240) ((% gs) 216))   ; untag allocptr in the tcr
  (movq (% arg_y) (5 (% temp0))) ; set the car
  (movq (% arg_z) (-3 (% temp0))); set the cdr
  (movq (% temp0) (% arg_z))    ; return the cons
	    </programlisting>
        <para>If we don't take the trap (if allocating 8-16 bytes
          doesn't exhaust the thread's reserved memory segment), that's
          a fairly short and simple instruction sequence.  If we do take
          the trap, we'll have to do some additional work in order to
          get a new segment for the current thread.</para>
      </section>
      <section id="allocation-of-reserved-heap-segments">
        <title>Allocation of reserved heap segments</title>
        <para>After the lisp image is first mapped into memory - and after
          each full GC - the lisp kernel ensures that
          (LISP-HEAP-GC-TRESHOLD) additional bytes beyond the current
          end of the heap are mapped read-write.</para>
        <para>          If a thread traps while trying to allocate memory, the
          thread goes through the usual exception-handling protocol (to
          ensure that any other thread that GCs &quot;sees&quot; the state of the
          trapping thread and to serialize exception handling.)  When
          the exception handler runs, it determines the nature and size
          of the failed allocation and tries to complete the allocation
          on the thread's behalf (and leave it with a reasonably large
          thread-specific memory segment so that the next small
          allocation is unlikely to trap.</para>
        <para>          Depending on the size of the requested segment
          allocation, the number of segment allocations that have
          occurred since the last GC, and the EGC and GC thresholds, the
          segment allocation trap handler may invoke a full or ephemeral
          GC before returning a new segment.  It's worth noting that the
          [E]GC is triggered based on the number of and size of these
          segments that have been allocated since the last GC; it doesn't
          have much to do with how &quot;full&quot; each of those per-thread
          segments are.  It's possible for a large number of threads to
          do fairly incidental memory allocation and trigger the GC as a
          result; avoiding this involves tuning the per-thread
          allocation quantum and the GC/EGC thresholds
          appropriately.</para>
      </section>
      <section id="heap-growth">
        <title>Heap growth</title>
        <para>All OSes on which Clozure CL currently runs use an
          &quot;overcommit&quot; memory allocation strategy by default (though
          some of them provide ways of overriding that default.)  What
          this means in general is that the OS doesn't necessarily
          ensure that backing store is available when asked to map pages
          as read-write; it'll often return a success indicator from the
          mapping attempt (mapping the pages as &quot;zero-fill,
          copy-on-write&quot;), and only try to allocate the backing store
          (swap space and/or physical memory) when non-zero contents are
          written to the pages.</para>
        <para>          It -sounds- like it'd be better to have the mmap() call
          fail immediately, but it's actually a complicated issue.
          (It's possible that other applications will stop using some
          backing store before lisp code actually touches the pages that
          need it, for instance.)  It's also not guaranteed that lisp
          code would be able to &quot;cleanly&quot; signal an out-of-memory
          condition if lisp is ... out of memory</para>
        <para>	      I don't know that I've ever seen an abrupt out-of-memory
	      failure that wasn't preceded by several minutes of excessive
	      paging activity.  The most expedient course in cases like this
	      is to either (a) use less memory or (b) get more memory; it's
	      generally hard to use memory that you don't have.</para>
      </section>
    </section>
    <section id="gc-details">
      <title>GC details</title>
      <para>The GC uses a Mark/Compact algorithm; its
        execution time is essentially a factor of the amount of live
        data in the heap. (The somewhat better-known Mark/Sweep
        algorithms don't compact the live data but instead traverse the
        garbage to rebuild free-lists; their execution time is therefore
        a factor of the total heap size.)</para>
      <para>        As mentioned in <xref linkend="heap-allocation"/>, two
        auxiliary data structures (proportional to the size of the lisp
        heap) are maintained. These are</para>
      <blockquote>
        <orderedlist>
          <listitem><para>the markbits bitvector, which contains a bit for
	        every doublenode in the dynamic heap (plus a few extra words
	        for alignment and so that sub-bitvectors can start on word
	        boundaries.)</para></listitem>
          <listitem><para>the relocation table, which contains a native word for
	        every 32 or 64 doublenodes in the dynamic heap, plus an
	        extra word used to keep track of the end of the heap.</para></listitem>
        </orderedlist>
      </blockquote>
      <para>The total GC space overhead is therefore on the order of
        3% (2/64 or 1/32).</para>
      <para>The general algorithm proceeds as follows:</para>
      <section id="mark-phase">
        <title>Mark phase</title>
        <para>Each doublenode in the dynamic heap has a corresponding
          bit in the markbits vector. (For any doublenode in the heap,
          the index of its mark bit is determined by subtracting the
          address of the start of the heap from the address of the
          object and dividing the result by 8 or 16.) The GC knows the
          markbit index of the free pointer, so determining that the
          markbit index of a doubleword address is between the start of
          the heap and the free pointer can be done with a single
          unsigned comparison.</para>
        <para>          The markbits of all doublenodes in the dynamic heap are
          zeroed before the mark phase begins. An object is
          <emphasis>marked</emphasis> if the markbits of all of its
          constituent doublewords are set and unmarked otherwise;
          setting an object's markbits involves setting the corresponding
          markbits of all constituent doublenodes in the object.</para>
        <para>          The mark phase traverses each root. If the tag of the
          value of the root indicates that it's a non-immediate node
          whose address lies in the lisp heap, then:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>If the object is already marked, do nothing.</para></listitem>
            <listitem><para>Set the object's markbit(s).</para></listitem>
            <listitem><para>If the object is an ivector, do nothing further.</para></listitem>
            <listitem><para>If the object is a cons cell, recursively mark its
	          car and cdr.</para></listitem>
            <listitem><para>Otherwise, the object is a gvector. Recursively mark
	          its elements.</para></listitem>
          </orderedlist>
        </blockquote>
        <para>Marking an object thus involves ensuring that its mark
          bits are set and then recursively marking any pointers
          contained within the object if the object was originally
          unmarked. If this recursive step was implemented in the
          obvious manner, marking an object would take stack space
          proportional to the length of the pointer chain from some root
          to that object. Rather than storing that pointer chain
          implicitly on the stack (in a series of recursive calls to the
          mark subroutine), the Clozure CL marker uses mixture of recursion
          and a technique called <emphasis>link inversion</emphasis> to
          store the pointer chain in the objects themselves.  (Recursion
          tends to be simpler and faster; if a recursive step notes that
          stack space is becoming limited, the link-inversion technique
          is used.)</para>
        <para>Certain types of objects are treated a little specially:</para>
        <blockquote>
          <orderedlist>
            <listitem><para>To support a feature called <emphasis>GCTWA</emphasis>
                (an acronym that I believe comes from MACLISP,
		            where it stood for &quot;Garbage Collection of Truly
		            Worthless Atoms&quot;),
                   the vector that contains the internal
	          symbols of the current package is marked on entry to the
	          mark phase, but the symbols themselves are not marked at
	          this time. Near the end of the mark phase, symbols
	          referenced from this vector which are not otherwise
	          marked are marked if and only if they're somehow
	          distinguishable from newly created symbols (by virtue of
	          their having function bindings, value bindings, plists,
	          or other attributes.)</para></listitem>
            <listitem><para>Pools have their first element set to NIL before any
	          other elements are marked.</para></listitem>
            <listitem><para>All hash tables have certain fields (used to cache
	          previous results) invalidated.</para></listitem>
            <listitem><para>Weak Hash Tables and other weak objects are put on a
	          linkedlist as they're encountered; their contents are only
	          retained if there are other (non-weak) references to
	          them.</para></listitem>
          </orderedlist>
        </blockquote>
        <para>At the end of the mark phase, the markbits of all
          objects that are transitively reachable from the roots are
          set and all other markbits are clear.</para>
      </section>
      <section id="relocation-phase">
        <title>Relocation phase</title>
        <para>The <emphasis>forwarding address</emphasis> of a
	      doublenode in the dynamic heap is (&lt;its current address&gt; -
	      (size_of_doublenode * &lt;the number of unmarked markbits that
	      precede it&gt;)) or alternately (&lt;the base of the heap&gt; +
	      (size_of_doublenode * &lt;the number of marked markbits that
	      precede it &gt;)). Rather than count the number of preceding
	      markbits each time, the relocation table is used to precompute
	      an approximation of the forwarding addresses for all
	      doublewords. Given this approximate address and a pointer into
	      the markbits vector, it's relatively easy to compute the exact
	      forwarding address.</para>
        <para>	      The relocation table contains the forwarding addresses
	      of each <emphasis>pagelet</emphasis>, where a pagelet is 256
	      bytes (or 32 doublenodes). The forwarding address of the first
	      pagelet is the base of the heap. The forwarding address of the
	      second pagelet is the sum of the forwarding address of the
	      first and 8 bytes for each mark bit set in the first 32-bit
	      word in the markbits table. The last entry in the relocation
	      table contains the forwarding address that the freepointer
	      would have, e.g., the new value of the freepointer after
	      compaction.</para>
        <para>	      In many programs, old objects rarely become garbage and
	      new objects often do. When building the relocation table, the
	      relocation phase notes the address of the first unmarked
	      object in the dynamic heap. Only the area of the heap between
	      the first unmarked object and the freepointer needs to be
	      compacted; only pointers to this area will need to be
	      forwarded (the forwarding address of all other pointers to the
	      dynamic heap is the address of that pointer.)  Often, the
	      first unmarked object is much nearer the free pointer than it
	      is to the base of the heap.</para>
      </section>
      <section id="forwarding-phase">
        <title>Forwarding phase</title>
        <para>The forwarding phase traverses all roots and the &quot;old&quot;
          part of the dynamic heap (the part between the base of the
          heap and the first unmarked object.) All references to objects
          whose address is between the first unmarked object and the
          free pointer are updated to point to the address the object
          will have after compaction by using the relocation table and
          the markbits vector and interpolating.</para>
        <para>	      The relocation table entry for the pagelet nearest the
	      object is found. If the pagelet's address is less than the
	      object's address, the number of set markbits that precede
	      the object on the pagelet is used to determine the object's
	      address; otherwise, the number of set markbits that follow
	      the object on the pagelet is used.</para>
        <para>          Since forwarding views the heap as a set of doublewords,
          locatives are (mostly) treated like any other pointers. (The
          basic difference is that locatives may appear to be tagged as
          fixnums, in which case they're treated as word-aligned
          pointers into the object.)</para>
        <para>          If the forward phase changes the address of any hash
          table key in a hash table that hashes by address (e.g., an EQ
          hash table), it sets a bit in the hash table's header. The
          hash table code will rehash the hash table's contents if it
          tries to do a lookup on a key in such a table.</para>
        <para>          Profiling reveals that about half of the total time
          spent in the GC is spent in the subroutine which determines a
          pointer's forwarding address. Exploiting GCC-specific idioms,
          hand-coding the routine, and inlining calls to it could all be
          expected to improve GC performance.</para>
      </section>
      <section id="compact-phase">
        <title>Compact phase</title>
        <para>The compact phase compacts the area between the first
          unmarked object and the freepointer so that it contains only
          marked objects.  While doing so, it forwards any pointers it
          finds in the objects it copies.</para>
        <para>          When the compact phase is finished, so is the GC (more
          or less): the free pointer and some other data structures are
          updated and control returns to the exception handler that
          invoked the GC. If sufficient memory has been freed to satisfy
          any allocation request that may have triggered the GC, the
          exception handler returns; otherwise, a &quot;seriously low on
          memory&quot; condition is signaled, possibly after releasing a
          small emergency pool of memory.</para>
      </section>
    </section>
    <section id="the-ephemeral-gc">
      <title>The ephemeral GC</title>
      <para>In the Clozure CL memory management scheme, the relative age
        of two objects in the dynamic heap can be determined by their
        addresses: if addresses X and Y are both addresses in the
        dynamic heap, X is younger than Y (X was created more recently
        than Y) if it is nearer to the free pointer (and farther from
        the base of the heap) than Y.</para>
      <para>        Ephemeral (or generational) garbage collectors attempt to
        exploit the following assumptions:</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>most newly created objects become garbage soon after
	        they'recreated.</para></listitem>
          <listitem><para>most objects that have already survived several GCs
	        are unlikely to ever become garbage.</para></listitem>
          <listitem><para>old objects can only point to newer objects as the
	        result of a destructive modification (e.g., via
	        SETF.)</para></listitem>
        </itemizedlist>
      </blockquote>
      <para>By concentrating its efforts on (frequently and quickly)
        reclaiming newly created garbage, an ephemeral collector hopes
        to postpone the more costly full GC as long as possible. It's
        important to note that most programs create some long-lived
        garbage, so an EGC can't typically eliminate the need for full
        GC.</para>
      <para>        An EGC views each object in the heap as belonging to
        exactly one <emphasis>generation</emphasis>; generations are
        sets of objects that are related to each other by age: some
        generation is the youngest, some the oldest, and there's an age
        relationship between any intervening generations. Objects are
        typically assigned to the youngest generation when first
        allocated; any object that has survived some number of GCs in
        its current generation is promoted (or
        <emphasis>tenured</emphasis>) into an older generation.</para>
      <para>        When a generation is GCed, the roots consist of the
        stacks, registers, and global variables as always and also of
        any pointers to objects in that generation from other
        generations. To avoid the need to scan those (often large) other
        generations looking for such intergenerational references, the
        runtime system must note all such intergenerational references
        at the point where they're created (via Setf). (This is
            sometimes called &quot;The Write Barrier&quot;: all assignments which
            might result in intergenerational references must be noted, as
            if the other generations were write-protected). The
        set of pointers that may contain intergenerational references is
        sometimes called <emphasis>the remembered set</emphasis>.</para>
      <para>        In Clozure CL's EGC, the heap is organized exactly the same
        as otherwise; &quot;generations&quot; are merely structures which contain
        pointers to regions of the heap (which is already ordered by
        age.) When a generation needs to be GCed, any younger generation
        is incorporated into it; all objects which survive a GC of a
        given generation are promoted into the next older
        generation. The only intergenerational references that can exist
        are therefore those where an old object is modified to contain a
        pointer to a new object.</para>
      <para>        The EGC uses exactly the same code as the full GC. When a
        given GC is &quot;ephemeral&quot;,</para>
      <blockquote>
        <itemizedlist>
          <listitem><para>the &quot;base of the heap&quot; used to determine an object's
	        markbit address is the base of the generation
	        being collected;</para></listitem>
          <listitem><para>the markbits vector is actually a pointer into the
	        middle of the global markbits table; preceding entries in
	        this table are used to note doubleword addresses in older
	        generations that (may) contain intergenerational
	        references;</para></listitem>
          <listitem><para>some steps (notably GCTWA and the handling of weak
	        objects) are not performed;</para></listitem>
          <listitem><para>the intergenerational references table is used to
	        find additional roots for the mark and forward phases. If a
	        bit is set in the intergenerational references table, that
	        means that the corresponding doubleword (in some &quot;old&quot;
	        generation, in some &quot;earlier&quot; part of the heap) may have had
	        a pointer to an object in a younger generation stored into
	        it.</para></listitem>
        </itemizedlist>
      </blockquote>
      <para>With one exception (the implicit setfs that occur on entry
        to and exit from the binding of a special variable), all setfs
        that might introduce an intergenerational reference must be
        memoized.
        Note that the implicit setfs that occur when
        initializing an object - as in the case of a call to cons or
        vector - can't introduce intergenerational references, since
        the newly created object is always younger than the objects
        used to initialize it. It's always safe to
        push any cons cell or gvector locative onto the memo stack;
        it's never safe to push anything else.</para>
      <para>        Typically, the intergenerational references bitvector is
        sparse: a relatively small number of old locations are stored
        into, although some of them may have been stored into many
        times. The routine that scans the memoization buffer does a lot
        of work and usually does it fairly often; it uses a simple,
        brute-force method but might run faster if it was smarter about
        recognizing addresses that it'd already seen.</para>
      <para>        When the EGC mark and forward phases scan the
        intergenerational reference bits, they can clear any bits that
        denote doublewords that definitely do not contain
        intergenerational references.
      </para>
    </section>
    <section id="fasl-files">
      <title>Fasl files</title>
      <para>Saving and loading of Fasl files is implemented in
        xdump/faslenv.lisp, level-0/nfasload.lisp, and lib/nfcomp.lisp.
        The information here is only an overview, which might help when
        reading the source.</para>
      <para>        The Clozure CL Fasl format is forked from the old MCL Fasl
        format; there are a few differences, but they are minor.  The
        name &quot;nfasload&quot; comes from the fact that this is the so-called
        &quot;new&quot; Fasl system, which was true in 1986 or so.  </para>
      <para>        A Fasl file begins with a &quot;file header&quot;, which contains
        version information and a count of the following &quot;blocks&quot;.
        There's typically only one &quot;block&quot; per Fasl file.  The blocks
        are part of a mechanism for combining multiple logical files
        into a single physical file, in order to simplify the
        distribution of precompiled programs. </para>
      <para>        Each block begins with a header for itself, which just
        describes the size of the data that follows.</para>
      <para>        The data in each block is treated as a simple stream of
        bytes, which define a bytecode program.  The actual bytecodes,
        &quot;fasl operators&quot;, are defined in xdump/faslenv.lisp.  The
        descriptions in the source file are terse, but, according to
        Gary, &quot;probably accurate&quot;.</para>
      <para>        Some of the operators are used to create a per-block
        &quot;object table&quot;, which is a vector used to keep track of
        previously-loaded objects and simplify references to them.  When
        the table is created, an index associated with it is set to
        zero; this is analogous to an array fill-pointer, and allows the
        table to be treated like a stack.</para>
      <para>        The low seven bits of each bytecode are used to specify
        the fasl operator; currently, about fifty operators are defined.
        The high byte, when set, indicates that the result of the
        operation should be pushed onto the object table.</para>
      <para>        Most bytecodes are followed by operands; the operand data
        is byte-aligned.  How many operands there are, and their type,
        depend on the bytecode.  Operands can be indices into the object
        table, immediate values, or some combination of these.</para>
      <para>        An exception is the bytecode #xFF, which has the symbolic
        name ccl::$faslend; it is used to mark the end of the
        block.</para>
    </section>
    <section id="the-objective-c-bridge_in_implementation-details-of-clozure-cl">
      <title>The Objective-C Bridge</title>
      <section id="how-clozure-cl-recognizes-objective-c-objects">
        <title>How Clozure CL Recognizes Objective-C Objects</title>
        <para>In most cases, pointers to instances of Objective-C
          classes are recognized as such; the recognition is (and
          probably always will be) slightly heuristic. Basically, any
          pointer that passes basic sanity checks and whose first word
          is a pointer to a known ObjC class is considered to be an
          instance of that class; the Objective-C runtime system would
          reach the same conclusion.</para>
        <para>          It's certainly possible that a random pointer to an
          arbitrary memory address could look enough like an ObjC
          instance to fool the lisp runtime system, and it's possible
          that pointers could have their contents change so that
          something that had either been a true ObjC instance (or had
          looked a lot like one) is changed (possibly by virtue of
          having been deallocated.)</para>
        <para>          In the first case, we can improve the heuristics
          substantially: we can make stronger assertions that a
          particular pointer is really &quot;of type :ID&quot; when it's a
          parameter to a function declared to take such a pointer as an
          argument or a similarly declared function result; we can be
          more confident of something we obtained via SLOT-VALUE of a
          slot defined to be of type :ID than if we just dug a pointer
          out of memory somewhere.</para>
        <para>          The second case is a little more subtle: ObjC memory
          management is based on a reference-counting scheme, and it's
          possible for an object to ... cease to be an object while lisp
          is still referencing it.  If we don't want to deal with this
          possibility (and we don't), we'll basically have to ensure
          that the object is not deallocated while lisp is still
          thinking of it as a first-class object. There's some support
          for this in the case of objects created with MAKE-INSTANCE,
          but we may need to give similar treatment to foreign objects
          that are introduced to the lisp runtime in other ways (as
          function arguments, return values, SLOT-VALUE results, etc. as
          well as those instances that are created under lisp
          control.)</para>
        <para>          This doesn't all work yet (in fact, not much of it works
          yet); in practice, this has not yet been as much of a problem
          as anticipated, but that may be because existing Cocoa code
          deals primarily with relatively long-lived objects such as
          windows, views, menus, etc.</para>
      </section>
      <section id="recommended-reading_in_the-objective-c-bridge">
        <title>Recommended Reading</title>
        <blockquote>
          <variablelist>
            <varlistentry>
              <term><ulink url="http://developer.apple.com/documentation/Cocoa/">Cocoa Documentation</ulink></term>
              <listitem><para>
	            This is the top page for all of Apple's documentation on
	            Cocoa.  If you are unfamiliar with Cocoa, it is a good
	            place to start.
	          </para></listitem>
            </varlistentry>
            <varlistentry>
              <term><ulink url="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html">Foundation Reference for Objective-C</ulink></term>
              <listitem><para>
	            This is one of the two most important Cocoa references; it
	            covers all of the basics, except for GUI programming.  This is
	            a reference, not a tutorial.
	          </para></listitem>
            </varlistentry>
          </variablelist>
        </blockquote>
      </section>
    </section>
  </chapter>
  <chapter id="modifying-clozure-cl">
    <title>Modifying Clozure CL</title>
    <section id="contributing-code-back-to-the-clozure-cl-project">
      <title>Contributing Code Back to the Clozure CL Project</title>
      <para>This section is a placeholder, added as of August 2004.  The
      full text is being written, and will be added as soon as it is
      available.</para>
    </section>
    <section id="using-clozure-cl-in-development-and-in-user-mode">
      <title>Using Clozure CL in &quot;development&quot; and in  &quot;user&quot; mode</title>
      <para>As it's distributed, Clozure CL starts up with *PACKAGE* set to
      the CL-USER package and with most predefined functions and
      methods protected against accidental redefinition.  The package
      setting is of course a requirement of ANSI CL, and the
      protection of predefined functions and methods is intended to
      catch certain types of programming errors (accidentally
      redefining a CL or CCL function) before those errors have a
      chance to do much damage.</para>
      <para>      These settings may make using Clozure CL to develop Clozure CL a bit
      awkward, because much of that process assumes you are working in
      the CCL package is current, and a primary purpose of Clozure CL
      development is to redefine some predefined, builtin functions.
      The standard, &quot;routine&quot; ways of building Clozure CL from sources (see
      ) - COMPILE-CCL, XCOMPILE-CCL, and XLOAD-LEVEL-0 - bind
      *PACKAGE* to the &quot;CCL&quot; package and enable the redefinition of
      predefined functions; the symbols COMPILE-CCL, XCOMPILE-CCL, and
      XLOAD-LEVEL-0 are additionally now exported from the &quot;CCL&quot;
      package.</para>
      <para>      Some other (more ad-hoc) ways of doing development on
      Clozure CL-compiling and/or loading individual files,
      incrementally redefining individual functions-may be
      awkward unless one reverts to the mode of operation which was
      traditionally offered in Clozure CL. Some Clozure CL source files -
      especially those that comprise the bootstrapping image sources
      and the first few files in the &quot;cold load&quot; sequence - are
      compiled and loaded in the &quot;CCL&quot; package but don't contain
      (IN-PACKAGE &quot;CCL&quot;) forms, since IN-PACKAGE doesn't work until
      later in the cold load sequence.</para>
      <para>      The somewhat bizarre behavior of both SET-USER-ENVIRONMENT
      and SET-DEVELOPMENT-ENVIRONMENT with respect to the special
      variables they affect is intended to allow those constructs to
      take effect when the read-eval-print loop next returns to a
      top-level '? ' prompt; the constructs can meaningfully be used
      inside LOAD, for instance (recall that LOAD binds *PACKAGE*),
      though using both constructs within the same LOAD call would
      likely be pretty confusing.</para>
      <para>      &quot;user&quot; and &quot;development&quot; are otherwise very generic terms;
      here they're intended to enforce the distinction between &quot;using&quot;
      Clozure CL and &quot;developing&quot; it.</para>
      <para>      The initial environment from which Clozure CL images are
      saved is one where (SET-USER-ENVIRONMENT T) has just been
      called; in previous versions, it was effectively as if
      (SET-DEVELOPMENT-ENVIRONMENT T) had just been called.</para>
      <para>      Hopefully, most users of Clozure CL can safely ignore these
      issues most of the time. Note that doing (SET-USER-ENVIRONMENT
      T) after loading one's own code (or 3rd-party code) into Clozure CL
      would protect that code (as well as Clozure CL's) from accidental
      redefinition; that may be useful in some cases.</para>
    </section>
    <section id="the-kernel-debugger">
      <title>The Kernel Debugger</title>
      <para> In a perfect world, something like this couldn't
      happen:</para>
      <programlisting><para>
Welcome to Clozure CL Version x.y!
? (defun foo (x)
    (declare (cons x))
    (cdr x))
FOO</para><para>? (foo -1) ;Oops. Too late ...
Unhandled exception 11 at 0x300e90c8, context-&gt;regs at #x7ffff6b8
Continue/Debugger/eXit &lt;enter&gt;?
    </para></programlisting>
      <para>As you may have noticed, it's not a perfect world; it's rare
      that the cause (attempting to reference the CDR of -1, and therefore
      accessing unmapped memory near location 0) of this effect (an
      &quot;Unhandled exception ...&quot; message) is so obvious.</para>
      <para>      The addresses printed in the message above aren't very useful
      unless you're debugging the kernel with GDB (and they're often
      very useful if you are.)</para>
      <para>      Aside from causing an exception that the lisp kernel doesn't
      know how to handle, one can also enter the kernel debugger (more)
      deliberately:</para>
      <programlisting><para>
? (defun classify (n)
    (cond ((&gt; n 0) &quot;Greater&quot;)
          ((&lt; n 0) &quot;Less&quot;)
          (t
           ;; Sheesh ! What else could it be ?
           (ccl::bug &quot;I give up. How could this happen ?&quot;))))
CLASSIFY</para><para>? (classify 0)
Bug in Clozure CL system code:
I give up. How could this happen ?
? for help
[12345] Clozure CL kernel debugger:
    </para></programlisting>
      <para>CCL::BUG isn't quite the right tool for this example (a
      call to BREAK or PRINT might do a better job of clearing up the
      mystery), but it's sometimes helpful when those other tools
      can't be used.  The lisp error system notices, for instance, if
      attempts to signal errors themselves cause errors to be
      signaled; this sort of thing can happen if CLOS or the I/O
      system are broken or missing. After some small number of
      recursive errors, the error system gives up and calls
      CCL::BUG.</para>
      <para>      If one enters a '?' at the kernel debugger prompt, one
      will see output like:</para>
      <programlisting>
(S)  Find and describe symbol matching specified name
(B)  Show backtrace
(X)  Exit from this debugger, asserting that any exception was handled
(K)  Kill Clozure CL process
(?)  Show this help
    </programlisting>
      <para>CCL::BUG just does an FF-CALL into the lisp kernel.  If
      the kernel debugger was invoked because of an unhandled
      exception (such as an illegal memory reference) the OS kernel
      saves the machine state (&quot;context&quot;) in a data structure for us,
      and in that case some additional options can be used to display
      the contents of the registers at the point of the
      exception. Another function-CCL::DBG-causes a special
      exception to be generated and enters the lisp kernel debugger
      with a non-null &quot;context&quot;:</para>
      <programlisting><para>
? (defun classify2 (n)
    (cond ((&gt; n 0) &quot;Greater&quot;)
          ((&lt; n 0) &quot;Less&quot;)
          (t (dbg n))))
CLASSIFY2</para><para>? (classify2 0)
Lisp Breakpoint
While executing: #&lt;Function CLASSIFY2 #x08476cfe&gt;
? for help
[12345] Clozure CL kernel debugger: ?
(G)  Set specified GPR to new value
(A)  Advance the program counter by one instruction (use with caution!)
(D)  Describe the current exception in greater detail
(R)  Show raw GPR/SPR register values
(L)  Show Lisp values of tagged registers
(F)  Show FPU registers
(S)  Find and describe symbol matching specified name
(B)  Show backtrace
(X)  Exit from this debugger, asserting that any exception was handled
(P)  Propagate the exception to another handler (debugger or OS)
(K)  Kill Clozure CL process
(?)  Show this help
    </para></programlisting>
      <para>CCL::DBG takes an argument, whose value is copied into the register
      that Clozure CL uses to return a function's primary value (arg_z, which
      is r23 on the PowerPC). If we were to choose the (L) option at this point,
      we'd see a dislay like:</para>
      <programlisting>
rnil = 0x01836015
nargs = 0
r16 (fn) = #&lt;Function CLASSIFY2 #x30379386&gt;
r23 (arg_z) = 0
r22 (arg_y) = 0
r21 (arg_x) = 0
r20 (temp0) = #&lt;26-element vector subtag = 2F @#x303793ee&gt;
r19 (temp1/next_method_context) = 6393788
r18 (temp2/nfn) = #&lt;Function CLASSIFY2 #x30379386&gt;
r17 (temp3/fname) = CLASSIFY2
r31 (save0) = 0
r30 (save1) = *TERMINAL-IO*
r29 (save2) = 0
r28 (save3) = (#&lt;RESTART @#x01867f2e&gt; #&lt;RESTART @#x01867f56&gt;)
r27 (save4) = ()
r26 (save5) = ()
r25 (save6) = ()
r24 (save7) = ()
    </programlisting>
      <para>From this we can conclude that the problematic argument to CLASSIFY2
      was 0 (see r23/arg_z), and that I need to work on a better example.</para>
      <para>      The R option shows the values of the ALU (and PPC branch unit)
      registers in hex; the F option shows the values of the FPU registers.</para>
      <para>      The (B) option shows a raw stack backtrace; it'll try to
      identify foreign functions as well as lisp functions. (Foreign function
      names are guesses based on the nearest preceding exported symbol.)</para>
      <para>      If you ever unexpectedly find yourself in the &quot;lisp kernel
      debugger&quot;, the output of the (L) and (B) options are often the most
      helpful things to include in a bug report.</para>
    </section>
    <section id="using-altivec-in-clozure-cl-lap-functions">
      <title>Using AltiVec in Clozure CL LAP functions</title>
      <section id="overview_in_using-altivec-in-clozure-cl-lap-functions">
        <title>Overview</title>
        <para>It's now possible to use AltiVec instructions in PPC LAP
        (assembler) functions.</para>
        <para>        The lisp kernel detects the presence or absence of
        AltiVec and preserves AltiVec state on lisp thread switch and
        in response to exceptions, but the implementation doesn't
        otherwise use vector operations.</para>
        <para>        This document doesn't document PPC LAP programming in
        general.  Ideally, there would be some document that
        did.</para>
        <para>        This document does explain AltiVec register-usage
        conventions in Clozure CL and explains the use of some lap macros
        that help to enforce those conventions.</para>
        <para>        All of the global symbols described below are exported
        from the CCL package. Note that lap macro names, ppc
        instruction names, and (in most cases) register names are
        treated as strings, so this only applies to functions and
        global variable names.</para>
        <para>        Much of the Clozure CL support for AltiVec LAP programming
        is based on work contributed to MCL by Shannon Spires.</para>
      </section>
      <section id="register-usage-conventions">
        <title>Register usage conventions</title>
        <para>Clozure CL LAP functions that use AltiVec instructions must
        interoperate with each other and with C functions; that fact
        suggests that they follow C AltiVec register usage
        conventions. (vr0-vr1 scratch, vr2-vr13 parameters/return
        value, vr14-vr19 temporaries, vr20-vr31 callee-save
        non-volatile registers.)</para>
        <para>        The EABI (Embedded Application Binary Interface) used in
        LinuxPPC doesn't ascribe particular significance to the vrsave
        special-purpose register; on other platforms (notably MacOS),
        it's used as a bitmap which indicates to system-level code
        which vector registers contain meaningful values.</para>
        <para>        The WITH-ALTIVEC-REGISTERS lap macro generates code that
        saves, updates, and restores VRSAVE on platforms where this is
        required (as indicated by the value of the special variable
        that controls this behavior) and ignores VRSAVE on platforms
        that don't require it to be maintained.</para>
        <para>        On all PPC platforms, it's necessary to save any non-volatile
        vector registers (vr20 .. vr31) before assigning to them and to restore
        such registers before returning to the caller.</para>
        <para>        On platforms that require that VRSAVE be maintained, it's
        not necessary to mention the &quot;use&quot; of vector registers that
        are used as incoming parameters. It's not incorrect to mention
        their use in a WITH-ALTIVEC-REGISTERS form, but it may be
        unnecessary in many interesting cases. One can likewise assume
        that the caller of any function that returns a vector value in
        vr2 has already set the appropriate bit in VRSAVE to indicate
        that this register is live. One could therefore write a leaf
        function that added the bytes in vr3 and vr2 and returned the
        result in vr2 as:</para>
        <programlisting>
(defppclapfunction vaddubs ((y vr3) (z vr2))
  (vaddubs z y z)
  (blr))
      </programlisting>
        <para>When vector registers that aren't incoming parameters are used
        in a LAP function, WITH-ALTIVEC-REGISTERS takes care of maintaining VRSAVE
        and of saving/restoring any non-volatile vector registers:</para>
        <programlisting>
(defppclapfunction load-array ((n arg_z))
  (check-nargs 1)
  (with-altivec-registers (vr1 vr2 vr3 vr27) ; Clobbers imm0
    (li imm0 arch::misc-data-offset)
    (lvx vr1 arg_z imm0)                ; load MSQ
    (lvsl vr27 arg_z imm0)              ; set the permute vector
    (addi imm0 imm0 16)                 ; address of LSQ
    (lvx vr2 arg_z imm0)                ; load LSQ
    (vperm vr3 vr1 vr2 vr27)           ; aligned result appears in VR3
    (dbg t))                         ; Look at result in some debugger
  (blr))
      </programlisting>
        <para>AltiVec registers are not preserved by CATCH and UNWIND-PROTECT.
        Since AltiVec is only accessible from LAP in Clozure CL and since LAP
        functions rarely use high-level control structures, this should rarely be
        a problem in practice.</para>
        <para>        LAP functions that use non-volatile vector registers and
        that call (Lisp ?) code which may use CATCH or UNWIND-PROTECT
        should save those vector registers before such a call and
        restore them on return. This is one of the intended uses of
        the WITH-VECTOR-BUFFER lap macro.</para>
      </section>
    </section>
    <section id="development-mode-dictionary">
      <title>Development-Mode Dictionary</title>
      <refentry id="v_warn-if-redefine-kernel">
        <indexterm zone="v_warn-if-redefine-kernel"><primary><literal>*WARN-IF-REDEFINE-KERNEL*</literal></primary></indexterm>
        <refnamediv>
          <refname>*WARN-IF-REDEFINE-KERNEL*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*WARN-IF-REDEFINE-KERNEL*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_warn-if-redefine-kernel">
          <title>Description</title>
          <para>When true, attempts to redefine (via DEFUN or DEFMETHOD)
	      functions and methods that are marked as being
	      &quot;predefined&quot; signal continuable errors.</para>
          <para>	      Note that these are CERRORs, not warnings, and that
	      no lisp functions or methods have been defined in the kernel
	      in MCL or Clozure CL since 1987 or so.</para>
        </refsect1>
      </refentry>
      <refentry id="f_set-development-environment">
        <indexterm zone="f_set-development-environment"><primary><literal>SET-DEVELOPMENT-ENVIRONMENT</literal></primary></indexterm>
        <refnamediv>
          <refname>SET-DEVELOPMENT-ENVIRONMENT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>set-development-environment <literal>&amp;optional</literal> unmark-builtin-functions</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_set-development-environment">
          <title>Description</title>
          <para>Arranges that the outermost special bindings of *PACKAGE*
	      and *WARN-IF-REDEFINE-KERNEL* restore values of the &quot;CCL&quot;
	      package and NIL to these variables, respectively. If the optional
	      argument is true, marks all globally defined functions and methods
	      as being &quot;not predefined&quot; (this is a fairly expensive
	      operation.)</para>
        </refsect1>
      </refentry>
      <refentry id="f_set-user-environment">
        <indexterm zone="f_set-user-environment"><primary><literal>SET-USER-ENVIRONMENT</literal></primary></indexterm>
        <refnamediv>
          <refname>SET-USER-ENVIRONMENT</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>set-user-environment <literal>&amp;optional</literal> mark-builtin-functions</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_set-user-environment">
          <title>Description</title>
          <para>Arranges that the outermost special bindings of *PACKAGE*
	      and *WARN-IF-REDEFINE-KERNEL* restore values of the
	      &quot;CL-USER&quot; package and T to these variables, respectively.
	      If the optional argument is true, marks all globally defined
	      functions and methods as being &quot;predefined&quot; (this is a
	      fairly expensive operation.)</para>
        </refsect1>
      </refentry>
      <refentry id="v_altivec-available">
        <indexterm zone="v_altivec-available"><primary><literal>*ALTIVEC-AVAILABLE*</literal></primary></indexterm>
        <refnamediv>
          <refname>*ALTIVEC-AVAILABLE*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*ALTIVEC-AVAILABLE*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_altivec-available">
          <title>Description</title>
          <para>This variable is initialized each time an Clozure CL session
	      starts based on information provided by the lisp kernel. Its value
	      is true if AltiVec is present and false otherwise. This variable
	      shouldn't be set by user code.</para>
        </refsect1>
      </refentry>
      <refentry id="f_altivec-available-p">
        <indexterm zone="f_altivec-available-p"><primary><literal>ALTIVEC-AVAILABLE-P</literal></primary></indexterm>
        <refnamediv>
          <refname>ALTIVEC-AVAILABLE-P</refname>
          <refpurpose/>
          <refclass>Function</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>altivec-available-p</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_f_altivec-available-p">
          <title>Description</title>
          <para>Returns non-NIL if AltiVec is available.</para>
        </refsect1>
      </refentry>
      <refentry id="v_altivec-lapmacros-maintain-vrsave-p">
        <indexterm zone="v_altivec-lapmacros-maintain-vrsave-p"><primary><literal>*ALTIVEC-LAPMACROS-MAINTAIN-VRSAVE-P*</literal></primary></indexterm>
        <refnamediv>
          <refname>*ALTIVEC-LAPMACROS-MAINTAIN-VRSAVE-P*</refname>
          <refpurpose/>
          <refclass>Variable</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>*ALTIVEC-LAPMACROS-MAINTAIN-VRSAVE-P*</synopsis></refsynopsisdiv>
        <refsect1 id="description_in_v_altivec-lapmacros-maintain-vrsave-p">
          <title>Description</title>
          <para>Intended to control the expansion of certain lap macros.
	      Initialized to NIL on LinuxPPC; initialized to T on platforms
	      (such as MacOS X/Darwin) that require that the VRSAVE SPR contain
	      a bitmask of active vector registers at all times.</para>
        </refsect1>
      </refentry>
      <refentry id="f_with-altivec-registers">
        <indexterm zone="f_with-altivec-registers"><primary><literal>CCL::WITH-ALTIVEC-REGISTERS</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::WITH-ALTIVEC-REGISTERS</refname>
          <refpurpose/>
          <refclass>Lap Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-altivec-registers reglist <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_with-altivec-registers">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>reglist</parameter></term>
                <listitem><para>A list of vector register names (vr0 .. vr31).</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>A sequence of PPC LAP instructions.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_with-altivec-registers">
          <title>Description</title>
          <para>Specifies the set of AltiVec registers used in body. If
	      *altivec-lapmacros-maintain-vrsave-p* is true when the macro is
	      expanded, generates code to save the VRSAVE SPR and updates VRSAVE
	      to include a bitmask generated from the specified register list.
	      Generates code which saves any non-volatile vector registers which
	      appear in the register list, executes body, and restores the saved
	      non-volatile vector registers (and, if
	      *altivec-lapmacros-maintain-vrsave-p* is true, restores VRSAVE as
	      well. Uses the IMM0 register (r3) as a temporary.</para>
        </refsect1>
      </refentry>
      <refentry id="f_with-vector-buffer">
        <indexterm zone="f_with-vector-buffer"><primary><literal>CCL::WITH-VECTOR-BUFFER</literal></primary></indexterm>
        <refnamediv>
          <refname>CCL::WITH-VECTOR-BUFFER</refname>
          <refpurpose/>
          <refclass>Lap Macro</refclass>
        </refnamediv>
        <refsynopsisdiv><synopsis>with-vector-buffer base n <literal>&amp;body</literal> body</synopsis></refsynopsisdiv>
        <refsect1 id="arguments-and-values_in_f_with-vector-buffer">
          <title>Arguments and Values</title>
          <blockquote>
            <variablelist>
              <varlistentry>
                <term><parameter>base</parameter></term>
                <listitem><para>Any available general-purpose register.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>n</parameter></term>
                <listitem><para>An integer between 1 and 254, inclusive. (Should
		        typically be much, much closer to 1.) Specifies the size of
		        the buffer, in 16-byte units.</para></listitem>
              </varlistentry>
              <varlistentry>
                <term><parameter>body</parameter></term>
                <listitem><para>A sequence of PPC LAP instructions.</para></listitem>
              </varlistentry>
            </variablelist>
          </blockquote>
        </refsect1>
        <refsect1 id="description_in_f_with-vector-buffer">
          <title>Description</title>
          <para>Generates code which allocates a 16-byte aligned buffer
	      large enough to contain N vector registers; the GPR base points to
	      the lowest address of this buffer. After processing body, the
	      buffer will be deallocated. The body should preserve the value of
	      base as long as it needs to reference the buffer. It's
	      intended that base be used as a base register in stvx and lvx
	      instructions within the body.</para>
        </refsect1>
      </refentry>
    </section>
  </chapter>
  <chapter id="questions-and-answers">
    <title>Questions and Answers</title>
    <section id="how-can-i-do-nonblocking-aka-unbuffered-and-raw-io">
      <title>How can I do nonblocking (aka &quot;unbuffered&quot; and &quot;raw&quot;) IO?</title>
      <para>There's some code for manipulating TTY modes in
      &quot;ccl:library;pty.lisp&quot;.</para>
      <programlisting><para>
? (require &quot;PTY&quot;)</para><para>? (ccl::disable-tty-local-modes 0 #$ICANON)
T
      </para></programlisting>
      <para>will turn off &quot;input canonicalization&quot; on file descriptor
      0, which is at least part of what you need to do here.  This
      disables the #$ICANON mode, which tells the OS not to do any
      line-buffering or line-editing.  Of course, this only has any
      effect in situations where the OS ever does that, which means
      when stdin is a TTY or PTY.</para>
      <para>If the #$ICANON mode is disabled, you can do things like:</para>
      <programlisting>
? (progn (read-char) (read-char))
a
#\a
      </programlisting>
      <para>(where the first READ-CHAR consumes the newline, which
      isn't really necessary to make the reader happy anymore.)  So,
      you can do:</para>
      <programlisting>
? (read-char)
#\Space
</programlisting>
      <para>(where there's a space after the close-paren) without
      having to type a newline.</para>
    </section>
    <section id="i-m-using-the-graphics-demos.-why-doesn-t-the-menubar-change">
      <title>I'm using the graphics demos. Why doesn't the menubar
      change?</title>
      <para>When you interact with text-only Clozure CL, you're either
      in Terminal or in Emacs, running Clozure CL as a subprocess.  When
      you load Cocoa or the graphical environment, the subprocess does
      some tricky things that turn it into a full-fledged Application,
      as far as the OS is concerned.</para>
      <para>      So, it gets its own icon in the dock, and its own menubar,
      and so on.  It can be confusing, because standard input and
      output will still be connected to Terminal or Emacs, so you can
      still type commands to Clozure CL from there.  To see the menubar
      you loaded, or the windows you opened, just click on the Clozure CL
      icon in the dock.</para>
    </section>
    <section id="i-m-using-slime-and-cocoa.-why-doesn-t-standard-output-seem-to-work">
      <title>I'm using Slime and Cocoa. Why doesn't *standard-output*
      seem to work? </title>
      <para>This comes up if you're using the Slime interface
      to run Clozure CL under Emacs, and you are doing Cocoa programming
      which involves printing to *standard-output*.  It seems as
      though the output goes nowhere; no error is reported, but it
      doesn't appear in the *slime-repl* buffer.</para>
      <para>      For the most part, this is only relevant when you are
      trying to insert debug code into your event handlers.  The SLIME
      listener runs in a thread where the standard stream variables
      (like <literal>*STANDARD-OUTPUT* and</literal> and
      <literal>*TERMINAL-IO*</literal> are bound to the stream used to
      communicate with Emacs; the Cocoa event thread has its own
      bindings of these standard stream variables, and output to these
      streams goes to the *inferior-lisp* buffer instead.  Look for it
      there.</para>
    </section>
  </chapter>
  <glossary id="glossary-of-terms"><title>Glossary of Terms</title><glossentry id="application_bundle"><glossterm>application bundle</glossterm><glossdef><para>A specially-structured directory that Mac OS X
		recognizes as a
		launchable <indexterm><primary>Cocoa</primary></indexterm><glossterm linkend="cocoa">Cocoa</glossterm>
		application. Graphical applications on Mac OS X are
		represented as application bundles.</para></glossdef></glossentry><glossentry id="cocoa"><glossterm>Cocoa</glossterm><glossdef><para>The standard user-interface libraries and frameworks
		provided by Apple for development of applications on Mac OS
		X.</para></glossdef></glossentry><glossentry id="creator_code"><glossterm>creator code</glossterm><glossdef><para>A four-character identifier used in Mac OS X to uniquely
		identify an application.</para></glossdef></glossentry><glossentry id="displaced_array"><glossterm>displaced array</glossterm><glossdef><para>An array with no storage of its own for elements, which
		points to the storage of another array, called its
		target. Reading or writing the elements of the displaced array
		returns or changes the contents of the target.</para></glossdef></glossentry><glossentry id="fasl_file"><glossterm>fasl file</glossterm><glossdef><para>A file containing compiled lisp code that the Lisp is
		able to quickly load and use. A &quot;fast-load&quot; file.</para></glossdef></glossentry><glossentry id="hemlock"><glossterm>Hemlock</glossterm><glossdef><para>A text editor, written in Common Lisp, similar in
		features to Emacs. Hemlock was originally developed as part of
		CMU Common Lisp. A portable version of Hemlock is built into
		the Clozure CL <indexterm><primary>IDE</primary></indexterm><glossterm linkend="ide">IDE</glossterm>.</para></glossdef></glossentry><glossentry id="ide"><glossterm>IDE</glossterm><glossdef><para>&quot;Integrated Development Environment&quot;. In the context of
		Clozure CL, &quot;the IDE&quot; refers to the experimental <indexterm><primary>Cocoa</primary></indexterm><glossterm linkend="cocoa">Cocoa</glossterm>
		windowing development environment provided in source form with
		Clozure CL distributions.</para></glossdef></glossentry><glossentry id="image"><glossterm>image</glossterm><glossdef><para>The in-memory state of a running Lisp system, containing
		functions, data structures, variables, and so on. Also, a file
		containing archived versions of these data in a format that
		can be loaded and reconstituted by the
		Lisp <indexterm><primary>kernel</primary></indexterm><glossterm linkend="kernel">kernel</glossterm>. A
		working Clozure CL system consists of the kernel and
		an <indexterm><primary>image</primary></indexterm><glossterm linkend="image">image</glossterm>.</para></glossdef></glossentry><glossentry id="interfacebuilder"><glossterm>InterfaceBuilder</glossterm><glossdef><para>An application supplied by Apple with their developer
		tools that can be used to interactively build user-interface
		elements for <indexterm><primary>Cocoa</primary></indexterm><glossterm linkend="cocoa">Cocoa</glossterm>
		applications.</para></glossdef></glossentry><glossentry id="kernel"><glossterm>kernel</glossterm><glossdef><para>The binary executable program that implements the lowest
		levels of the Lisp system. A working Clozure CL system consists of
		the kernel and
		an <indexterm><primary>image</primary></indexterm><glossterm linkend="image">image</glossterm>.</para></glossdef></glossentry><glossentry id="listener_window"><glossterm>listener window</glossterm><glossdef><para>In the <indexterm><primary>IDE</primary></indexterm><glossterm linkend="ide">IDE</glossterm>,
		a <indexterm><primary>Cocoa</primary></indexterm><glossterm linkend="cocoa">Cocoa</glossterm>
		window that contains a pseudo-terminal session that
		communicates with a Lisp <indexterm><primary>REPL</primary></indexterm><glossterm linkend="repl">REPL</glossterm>.</para></glossdef></glossentry><glossentry id="memory-mapped_file"><glossterm>memory-mapped file</glossterm><glossdef><para>A file whose contents are accessible as a range of
		memory addresses. Some operating systems support this feature,
		in which the virtual memory subsystem arranges for a range of
		virtual memory addresses to point to the contents of an open
		file. Programs can then gain access to the file's contents by
		operating on memory addresses in that range. Access to the
		file's contents is valid only as long as the file remains
		open.</para></glossdef></glossentry><glossentry id="nibfile"><glossterm>nibfile</glossterm><glossdef><para>A data file created by
		Apple's <indexterm><primary>InterfaceBuilder</primary></indexterm><glossterm linkend="interfacebuilder">InterfaceBuilder</glossterm>
		application, which contains archived Objective-C objects that
		define user-interface elements for
		a <indexterm><primary>Cocoa</primary></indexterm><glossterm linkend="cocoa">Cocoa</glossterm>
		application. Under Mac OS
		X, <indexterm><primary>Cocoa</primary></indexterm><glossterm linkend="cocoa">Cocoa</glossterm> applications
		typically create their user interface elements by reading
		nibfiles and unarchiving the objects in them.</para></glossdef></glossentry><glossentry id="repl"><glossterm>REPL</glossterm><glossdef><para>&quot;Read-eval-print loop&quot;. The interactive shell provided
		by Clozure CL for interaction with Lisp.</para></glossdef></glossentry><glossentry id="s-expression"><glossterm>s-expression</glossterm><glossdef><para>The simplest, most general element of Lisp syntax. An
		s-expression may be an atom (such as a symbol, integer, or
		string), or it may be a list of s-expressions.</para></glossdef></glossentry><glossentry id="special_variable"><glossterm>special variable</glossterm><glossdef><para>A variable whose binding is in the dynamic
		environment. Special variables are essentially equivalent to
		global variables in languages other than Lisp. A special
		variable binding is visible in any lexical environment, so
		long as a lexical binding has not shadowed it.</para></glossdef></glossentry><glossentry id="static_variable"><glossterm>static variable</glossterm><glossdef><para>In Clozure CL, a variable whose value is shared across all
		threads, and which may not be dynamically rebound. Changing a
		static variable's value in one thread causes all threads to
		see the new value. Attempting to dynamically rebind the
		variable (for instance, by using <literal>LET</literal>, or using
		the variable name as a parameter in a <literal>LAMBDA</literal>
		form) signals an error.</para></glossdef></glossentry><glossentry id="toplevel_function"><glossterm>toplevel function</glossterm><glossdef><para>The function executed by Lisp automatically once its
		startup is complete. Clozure CL's default toplevel is the
		interactive <indexterm><primary>read-eval-print loop</primary></indexterm><glossterm linkend="repl">read-eval-print loop</glossterm> that you normally use to interact with
		Lisp. You can, however, replace the toplevel with a function
		of your own design, changing Clozure CL from a Lisp development
		system into some tool of your making.</para></glossdef></glossentry><glossentry id="type-specifier"><glossterm>type-specifier</glossterm><glossdef><para>An expression that denotes a type. Type specifiers may
		be symbols (such as <literal>CONS</literal>
		and <literal>STRING</literal>), or they may be more complex
		<indexterm><primary>S-expressions</primary></indexterm><glossterm linkend="s-expression">S-expressions</glossterm>
		(such as (UNSIGNED-BYTE 8)).</para></glossdef></glossentry></glossary>
  <index id="symbol-index"><title>Symbol Index</title></index>
</book>